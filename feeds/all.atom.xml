<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>陌辞寒</title><link href="/" rel="alternate"></link><link href="/feeds/all.atom.xml" rel="self"></link><id>/</id><updated>2017-09-18T20:29:00+08:00</updated><entry><title>AHK 优势劣势之我见</title><link href="/ahk-you-shi-lie-shi-zhi-wo-jian.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ahk-you-shi-lie-shi-zhi-wo-jian.html</id><summary type="html">&lt;p&gt;这算是第一篇非技术的文章吧。转眼间也陆续写了十多篇 AHK 教程，今天整理了下，没有找到特别想写的话题，就简单写下自己对 AHK 这门编程语言的看法吧，或许也会提一些其他或有关或无关的事情。&lt;/p&gt;
&lt;p&gt;前些天在 AHK 官网论坛看到这样一个帖子：&lt;a href="https://autohotkey.com/board/topic/90892-why-doesnt-ahk-get-the-respect-it-deserves/"&gt;Why doesn't AHK get the respect it deserves? &lt;/a&gt;（为什么 AHK 没有得到应有的尊重）。里边一些人的观点还是比较有参考意义的，我昨天想翻译一下其中的部分内容，现在只翻译了一部分，等完成了可能会发出来。然后我又一想，为什么不先表达一下我自己的观点呢？&lt;/p&gt;
&lt;p&gt;AHK 对于很多用户来说似乎扮演着一门启蒙编程语言的角色，用户慢慢发现 AHK 有着一些限制，于是转而使用 Python 等其他编程语言。而我不是这样的。我第一次系统学习的编程语言是 JavaScript，距离现在也已经有十年之久。在之后的十年里，我陆续学习和使用过各种各样的编程语言，在工作中用的最多的则是 C++、Shell 和 Python。而我开始对 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;这算是第一篇非技术的文章吧。转眼间也陆续写了十多篇 AHK 教程，今天整理了下，没有找到特别想写的话题，就简单写下自己对 AHK 这门编程语言的看法吧，或许也会提一些其他或有关或无关的事情。&lt;/p&gt;
&lt;p&gt;前些天在 AHK 官网论坛看到这样一个帖子：&lt;a href="https://autohotkey.com/board/topic/90892-why-doesnt-ahk-get-the-respect-it-deserves/"&gt;Why doesn't AHK get the respect it deserves? &lt;/a&gt;（为什么 AHK 没有得到应有的尊重）。里边一些人的观点还是比较有参考意义的，我昨天想翻译一下其中的部分内容，现在只翻译了一部分，等完成了可能会发出来。然后我又一想，为什么不先表达一下我自己的观点呢？&lt;/p&gt;
&lt;p&gt;AHK 对于很多用户来说似乎扮演着一门启蒙编程语言的角色，用户慢慢发现 AHK 有着一些限制，于是转而使用 Python 等其他编程语言。而我不是这样的。我第一次系统学习的编程语言是 JavaScript，距离现在也已经有十年之久。在之后的十年里，我陆续学习和使用过各种各样的编程语言，在工作中用的最多的则是 C++、Shell 和 Python。而我开始对 AHK 感兴趣是在今年（2016）年初。那么我为什么会对 AHK 感兴趣？本来想简单提下我的经历，但写着写着发现写成回忆录了，所以还是闲言少叙吧。&lt;/p&gt;
&lt;p&gt;简单说，我需要这样的一门编程语言，在 Windows 下可以比较容易的写图形界面软件，但发布后的文件要小（至多 5 M），同时开发环境尽量简单（尽量 1 G 以内），还有一点不能是已经过时无人维护的东西。&lt;/p&gt;
&lt;p&gt;找来找去，我发现 AHK 是一个看起来合适的选择。&lt;/p&gt;
&lt;p&gt;然后我罗列了所有我能想到的选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;C/C++ + Windows API。发布后的文件够小，开发环境也不算太大（可以使用 MinGW），但开发效率极低。&lt;/li&gt;
&lt;li&gt;C++ + MFC。发布后的文件够小，开发环境比较大，开发效率比较低，而且 MFC 已经属于过时技术。&lt;/li&gt;
&lt;li&gt;C++ + Qt。发布后的文件比较大，开发环境比较大，开发效率中等。&lt;/li&gt;
&lt;li&gt;C/C++ + 其他图形界面库。没有发布后文件大小、开发环境大小、开发效率能权衡成满意的，顾此失彼。而且很多可选项都是无人维护状态。&lt;/li&gt;
&lt;li&gt;Python + Qt。发布后的文件很大，开发环境比较大，开发效率高。&lt;/li&gt;
&lt;li&gt;Python + 其他图形界面库。发布后的文件都比较大，因为带一个 Python 就不小了，如果是简单的图形界面库，用起来不方便，复杂的体积就更大。&lt;/li&gt;
&lt;li&gt;JavaScript + 各种框架。如果是系统自带的，存在 IE 版本等问题。如果是第三方的，存在体积过大的问题。&lt;/li&gt;
&lt;li&gt;Delphi。Delphi。&lt;/li&gt;
&lt;/ol&gt;</content></entry><entry><title>AHK 语言介绍</title><link href="/ahk-yu-yan-jie-shao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ahk-yu-yan-jie-shao.html</id><summary type="html">&lt;p&gt;&lt;a href="http://autohotkey.com"&gt;&lt;strong&gt;AHK&lt;/strong&gt;（AutoHotkey）&lt;/a&gt; 是面向普通电脑用户的自由开源的自动化软件工具，它让用户能够快捷或自动执行重复性任务。&lt;/p&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;体积小巧、语法简明、易学易用。开发环境简单，只需要一个不足 1M 的解释器和一个顺手的编辑器，就可以开发了。&lt;/li&gt;
&lt;li&gt;API 丰富。AHK 提供了很多桌面软件需要用到的 API，而且调用 Windows API 非常方便，这是很多其他脚本语言所无法比拟的。&lt;/li&gt;
&lt;li&gt;AHK 对热键、热字符串有专门支持，写起来非常容易，而这在其他语言基本上都要费费尽周折。&lt;/li&gt;
&lt;li&gt;AHK 没有官方自带或者第三方实现的完善的标准库，这样如果需要实现非内置的功能通常需要直接调用 Windows API 或寻找别人封装好的函数。AHK 语言本身并不强大，缺少很多现代语言所具备的高级特性，同时也缺乏对多线程等操作系统特性的支持。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;AHK 的优点和缺点同样明显，我们需要慎重考虑，针对具体场景选择合适的工具。&lt;/p&gt;
&lt;h2&gt;当前版本&lt;/h2&gt;
&lt;h3&gt;AHK v1&lt;/h3&gt;
&lt;p&gt;AHK v1 是当前 AHK 的主流版本 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://autohotkey.com"&gt;&lt;strong&gt;AHK&lt;/strong&gt;（AutoHotkey）&lt;/a&gt; 是面向普通电脑用户的自由开源的自动化软件工具，它让用户能够快捷或自动执行重复性任务。&lt;/p&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;体积小巧、语法简明、易学易用。开发环境简单，只需要一个不足 1M 的解释器和一个顺手的编辑器，就可以开发了。&lt;/li&gt;
&lt;li&gt;API 丰富。AHK 提供了很多桌面软件需要用到的 API，而且调用 Windows API 非常方便，这是很多其他脚本语言所无法比拟的。&lt;/li&gt;
&lt;li&gt;AHK 对热键、热字符串有专门支持，写起来非常容易，而这在其他语言基本上都要费费尽周折。&lt;/li&gt;
&lt;li&gt;AHK 没有官方自带或者第三方实现的完善的标准库，这样如果需要实现非内置的功能通常需要直接调用 Windows API 或寻找别人封装好的函数。AHK 语言本身并不强大，缺少很多现代语言所具备的高级特性，同时也缺乏对多线程等操作系统特性的支持。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;AHK 的优点和缺点同样明显，我们需要慎重考虑，针对具体场景选择合适的工具。&lt;/p&gt;
&lt;h2&gt;当前版本&lt;/h2&gt;
&lt;h3&gt;AHK v1&lt;/h3&gt;
&lt;p&gt;AHK v1 是当前 AHK 的主流版本，也是官方网站下载地址中的版本。写此文时，最新版本为 1.1.23.05。&lt;/p&gt;
&lt;p&gt;其中又包含三个构建版本：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Unicode 32-bit。32 位 Unicode 版本，如无特殊需求，推荐使用此版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Unicode 64-bit。64 位 Unicode 版本，性能比 Unicode 32-bit 版本稍好，但占用更多内存。兼容性方面不如 Unicode 32-bit 版本。适合对性能敏感的场景使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ANSI 32-bit 。32 位 ANSI 版本，对历史遗留下来的老 AHK 脚本兼容性较好。如果写新脚本，无需关注此版本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;AHK v2&lt;/h3&gt;
&lt;p&gt;AHK v2 是试验分支，包含一些新的语言特性和平台相关功能等，语法上和 AHK v1 并不兼容，稳定性也不如 AHK v1。如果需要一些 AHK v2 的新特性，或者对 AHK 未来的发展方向感兴趣，可以关注此版本。&lt;/p&gt;
&lt;p&gt;下载地址：https://autohotkey.com/v2&lt;/p&gt;
&lt;h3&gt;其他版本&lt;/h3&gt;
&lt;p&gt;AutoHotkey_H: http://hotkeyit.github.io/v2
IronAHK: https://github.com/polyethene/IronAHK&lt;/p&gt;
&lt;p&gt;仅供有兴趣的朋友参考。&lt;/p&gt;
&lt;h2&gt;用法示例&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 热键示例，按 Win + n 启动记事本
#n::
    Run, notepad
return

; 热字符串示例，按 web 打开 AHK 官网
::web::
    Run, http://autohotkey.com
return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;更多用法请参考 &lt;a href="https://autohotkey.com/docs/AutoHotkey.htm"&gt;官网文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/AutoHotkey"&gt;中文维基百科 AutoHotkey 词条&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://autohotkey.com"&gt;AHK 官方网站&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content></entry><entry><title>Apache Drill 学习笔记二：Dremel 原理</title><link href="/apache-drill-xue-xi-bi-ji-er-dremel-yuan-li.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/apache-drill-xue-xi-bi-ji-er-dremel-yuan-li.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;《Apache Drill学习笔记一：环境搭建和简单试用》提到过Apache Drill是受Google的Dremel系统启发而设计实现的，这出于Google公开于2010年的论文“&lt;a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36632.pdf"&gt;Dremel Interactive Analysis of WebScaleDatasets&lt;/a&gt;”。为了弄清楚Apache Drill的运行机制，这篇论文是一定要先仔细研读的，否则就只能像我之前那样仅仅将其作为CSV或者JSON的SQL查询工具使用了，而不能真正发挥其强大的性能优势。&lt;/p&gt;
&lt;p&gt;简单说Dremel是Google的“交互式”数据分析系统，可以组建成规模上千的集群，处理PB级别的数据。虽然MapReduce也可以处理这样规模的数据，但它所需要的时间相对比较长，适合数据的批处理，而不适合交互式查询的场景，Dremel正是这样的一个有力补充。&lt;/p&gt;
&lt;p&gt;Dremel有2个显著特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可以在秒级别的时间查询PB级别的数据。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据模型是嵌套(nested)的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这正是其他数据库、查询引擎的痛点所在，也正是我们需要着重了解的地方。&lt;/p&gt;
&lt;h2&gt;数据模型&lt;/h2&gt;
&lt;p&gt;Dremel使用的数据就是我们熟悉的Protocol Buffer格式，但通常情况我们都是作为序列化方法或者在RPC中传输等场景使用，较少用它来存放大量数据。对于没有接触过Protocol Buffer的读者，可以用JSON类比，二者结构很相似，一个不同是Protocol Buffer不支持JSON的map（或者说是dict、hashmap）。&lt;/p&gt;
&lt;p&gt;一个Protocol Buffer的 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;《Apache Drill学习笔记一：环境搭建和简单试用》提到过Apache Drill是受Google的Dremel系统启发而设计实现的，这出于Google公开于2010年的论文“&lt;a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36632.pdf"&gt;Dremel Interactive Analysis of WebScaleDatasets&lt;/a&gt;”。为了弄清楚Apache Drill的运行机制，这篇论文是一定要先仔细研读的，否则就只能像我之前那样仅仅将其作为CSV或者JSON的SQL查询工具使用了，而不能真正发挥其强大的性能优势。&lt;/p&gt;
&lt;p&gt;简单说Dremel是Google的“交互式”数据分析系统，可以组建成规模上千的集群，处理PB级别的数据。虽然MapReduce也可以处理这样规模的数据，但它所需要的时间相对比较长，适合数据的批处理，而不适合交互式查询的场景，Dremel正是这样的一个有力补充。&lt;/p&gt;
&lt;p&gt;Dremel有2个显著特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可以在秒级别的时间查询PB级别的数据。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据模型是嵌套(nested)的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这正是其他数据库、查询引擎的痛点所在，也正是我们需要着重了解的地方。&lt;/p&gt;
&lt;h2&gt;数据模型&lt;/h2&gt;
&lt;p&gt;Dremel使用的数据就是我们熟悉的Protocol Buffer格式，但通常情况我们都是作为序列化方法或者在RPC中传输等场景使用，较少用它来存放大量数据。对于没有接触过Protocol Buffer的读者，可以用JSON类比，二者结构很相似，一个不同是Protocol Buffer不支持JSON的map（或者说是dict、hashmap）。&lt;/p&gt;
&lt;p&gt;一个Protocol Buffer的&lt;code&gt;Document.proto&lt;/code&gt;文件示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="no"&gt;Document&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;DocId&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="no"&gt;Links&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;Backward&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;Forward&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="no"&gt;Name&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="no"&gt;Language&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Country&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Url&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意的不是数据本身，而是数据的类型，或者说是数据的schema。但从中已经可以看出2个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型是可以嵌套的。&lt;/li&gt;
&lt;li&gt;同一种类型的数据是可以重复（repeated）和可选（optional）的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对如此复杂的数据做SQL查询看起来是很让人头疼的，我们自然想到先简化一下，从最简单的情况考虑。&lt;/p&gt;
&lt;p&gt;这种数据格式用数学方法严格表示是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dom&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="ss"&gt;A1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;[*|&lt;/span&gt;&lt;span class="sc"&gt;?]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;An&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;[*|&lt;/span&gt;&lt;span class="sc"&gt;?]&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起来有点复杂，但理解起来很容易。t（原文是希腊字母τ，但为了书写方便这里改成英文字母t）是一个数据类型的定义，而.proto文件就是定义一个或多个数据类型。t有两种可能（|和c语言一样是“或”的意思，一种是基本类型dom（如int、string、float等），另一种是使用递归方式定义的，即t可以由其他之前定义好的t组成，就像c中的结构体一样，与结构体不大相同的是，每个包含的t的值可以有多个（*，repeated，类似c中的数组），还可以是可选的（?，optional，之前那个数组可以不包含任何元素）。A1-An是这些t的命名（也就是A1是某个t类型的变量）。其实从这个定义中更容易看出之前总结的2个特点。&lt;/p&gt;
&lt;h2&gt;简单情况&lt;/h2&gt;
&lt;p&gt;现在我们来考虑简单的Protocol Buffer数据，以及如何查询。&lt;/p&gt;
&lt;p&gt;这是一个简化的&lt;code&gt;Document.proto&lt;/code&gt;，可以看到它只有一层结构，而且没有&lt;code&gt;repeated&lt;/code&gt;和&lt;code&gt;optional&lt;/code&gt;字段。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="no"&gt;Document&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;DocId&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Url&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Country&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;Code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而&lt;code&gt;Document&lt;/code&gt;的数据就是一张普通的二维表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;DocId&lt;/th&gt;
&lt;th&gt;Url&lt;/th&gt;
&lt;th&gt;Country&lt;/th&gt;
&lt;th&gt;Code&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10001&lt;/td&gt;
&lt;td&gt;http://1&lt;/td&gt;
&lt;td&gt;America&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10002&lt;/td&gt;
&lt;td&gt;http://2&lt;/td&gt;
&lt;td&gt;America&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10003&lt;/td&gt;
&lt;td&gt;http://3&lt;/td&gt;
&lt;td&gt;China&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10004&lt;/td&gt;
&lt;td&gt;http://4&lt;/td&gt;
&lt;td&gt;America&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10005&lt;/td&gt;
&lt;td&gt;http://5&lt;/td&gt;
&lt;td&gt;Japan&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10006&lt;/td&gt;
&lt;td&gt;http://6&lt;/td&gt;
&lt;td&gt;America&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出我们用二维的方式组织数据，但实际是数据在磁盘的地址是一维的，也就是我们需要按某种方式把它拼接成一维的数据。那最基本的方式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按行存：&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;10001&lt;/th&gt;
&lt;th&gt;http://1&lt;/th&gt;
&lt;th&gt;America&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;10002&lt;/th&gt;
&lt;th&gt;http://2&lt;/th&gt;
&lt;th&gt;America&lt;/th&gt;
&lt;th&gt;20&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;按列存：&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;10001&lt;/th&gt;
&lt;th&gt;10002&lt;/th&gt;
&lt;th&gt;1003&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;th&gt;http://1&lt;/th&gt;
&lt;th&gt;http://2&lt;/th&gt;
&lt;th&gt;http://3&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们先考虑下对这个表进行&lt;code&gt;select&lt;/code&gt;，如&lt;code&gt;select Url, Code from Document;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果是按行存的话，每读一个&lt;code&gt;Url&lt;/code&gt;后，都需要跳到下一个&lt;code&gt;Url&lt;/code&gt;的位置，所有要查出的字段都不是连续存放的。而且因为有字符串这样的非定长字段（如果使用定长的预留空间，又会造成大量的空间浪费），不能通过简单计算就可以得到地址，查起来非常痛苦，效率自然不会很高。&lt;/p&gt;
&lt;p&gt;而按列存的情况就好很多，只需要找到第一个&lt;code&gt;Url&lt;/code&gt;和第一个&lt;code&gt;Code&lt;/code&gt;的首地址，然后顺序读取到结尾即可。不仅实现简单，而且磁盘顺序读取好比随机读取要快，加上更容易优化（比如把临近地址的数据预读到内存，连续的同类型数据更容易压缩存放），效率自然不可同日而语。&lt;/p&gt;
&lt;p&gt;那是不是所有情况都需要按列来存数据呢？显然不是。虽然按列读的情况比较多，但写入一般是按行写的，无论是追加、删除、修改，一般都是按行处理的。数据按列存的话，追加时需要把一行数据按字段拆开，分别插入到不同的地方，删除也是一样，修改更加痛苦。因为如果是类似字符串的不定长字段，按行存的话可以以&lt;strong&gt;行&lt;/strong&gt;为单位预留空间，而按列存的话需要以&lt;strong&gt;字段&lt;/strong&gt;为单位预留空间，或者使用更复杂的方法。想一想就要麻烦许多。&lt;/p&gt;
&lt;p&gt;数据库往往需要同时照顾到读和写的效率，简单的按行存或者按列存都存在明显的问题（包括下文提到的表join效率等问题），所以往往需要存储复杂的meta数据、添加各类索引、使用各种树型甚至图型结构，来在读和写之间谋得一个平衡点。&lt;/p&gt;
&lt;p&gt;而Dremel要轻松一些，因为它被设计成一个查询引擎，即使也有写入功能也不会过多考虑写入的效率，那么显然按列存是合适的。这样即使一张表字段很多，数据量很大，只要记录每个字段的类型以及对应数据的起始地址等少量信息，查起来就游刃有余。所以如果只是用来查一个巨大的二维表的后，并不是很难。&lt;/p&gt;
&lt;p&gt;但我们知道，平时使用的数据很难在一张二维表里表达清楚，往往需要多张表，互相还有关联，查询起来就需要各种join。数据量小还好，数据量一大，join效率直线下降，单表select再快也没用，这才是真正棘手的问题。&lt;/p&gt;
&lt;h2&gt;有嵌套数据的情况&lt;/h2&gt;
&lt;p&gt;Dremel的解决方法不是设法提高join的效率，而是换一种思路，使用嵌套的数据解决简单二维表表达能力太弱的缺点。&lt;/p&gt;
&lt;p&gt;再拿出之前的&lt;code&gt;Document.proto&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="no"&gt;Document&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;DocId&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="no"&gt;Links&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;Backward&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;Forward&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="no"&gt;Name&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="no"&gt;Language&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Country&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Url&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的数据如果用二维表来存放一般需要多张才能描述清楚，处理重复字段也比较痛苦，而一个Protocol Buffer类型就可以描述，但在磁盘的实际存放还是要动不少脑筋的。&lt;/p&gt;
&lt;p&gt;现在就需要搬出论文里的这张图了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="record-wise-vs-columnar-representation-of-nested-data" src="/images/015.png"&gt;&lt;/p&gt;
&lt;p&gt;虽然嵌套的数据比之前的二维表更加复杂，还是有按行存和按列存两种基本方法，而且正如我们之前提到的，为了查询效率，我们采用按列存的方法（图中的&lt;code&gt;column-oriented&lt;/code&gt;）。我们重点关注A、B、C、D、E这些树型关系如何存储。&lt;/p&gt;
&lt;p&gt;我们来准备一些符合&lt;code&gt;Document.proto&lt;/code&gt;的简单的数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ss"&gt;DocId&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="no"&gt;Links&lt;/span&gt;
    &lt;span class="ss"&gt;Forward&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;
    &lt;span class="ss"&gt;Forward&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;
    &lt;span class="ss"&gt;Forward&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;
&lt;span class="no"&gt;Name&lt;/span&gt;
    &lt;span class="no"&gt;Language&lt;/span&gt;
        &lt;span class="ss"&gt;Code&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;en-us&amp;#39;&lt;/span&gt;
        &lt;span class="ss"&gt;Country&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;us&amp;#39;&lt;/span&gt;
    &lt;span class="no"&gt;Language&lt;/span&gt;
        &lt;span class="ss"&gt;Code&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;en&amp;#39;&lt;/span&gt;
        &lt;span class="ss"&gt;Url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;http://A&amp;#39;&lt;/span&gt;
&lt;span class="no"&gt;Name&lt;/span&gt;
    &lt;span class="ss"&gt;Url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;http://B&amp;#39;&lt;/span&gt;
&lt;span class="no"&gt;Name&lt;/span&gt;
    &lt;span class="no"&gt;Language&lt;/span&gt;
        &lt;span class="ss"&gt;Code&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;en-gb&amp;#39;&lt;/span&gt;
        &lt;span class="ss"&gt;Country&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;gb&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ss"&gt;DocId&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;
&lt;span class="no"&gt;Links&lt;/span&gt;
    &lt;span class="ss"&gt;Backward&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="ss"&gt;Backward&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;
    &lt;span class="ss"&gt;Forward&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;
&lt;span class="no"&gt;Name&lt;/span&gt;
    &lt;span class="ss"&gt;Url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;http://C&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;code&gt;DocId: 10&lt;/code&gt;和&lt;code&gt;DocId: 20&lt;/code&gt;是两个&lt;code&gt;Document&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Dremel是这样拆解数据的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="record-wise-vs-columnar-representation-of-nested-data" src="/images/016.png"&gt;&lt;/p&gt;
&lt;p&gt;可以看出每个需要存放实际数据的叶子节点都变成了一张二维表，但表中除了字段自身的值。如果是&lt;code&gt;repeated&lt;/code&gt;字段，则在表中增添行；如果是&lt;code&gt;optional&lt;/code&gt;字段，并且数据中不填充，则用&lt;code&gt;NULL&lt;/code&gt;代替（而不是去掉这一行）。但还出现了&lt;code&gt;r&lt;/code&gt;和&lt;code&gt;d&lt;/code&gt;，这两个又是什么东西，而且为何要记录&lt;code&gt;NULL&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;试想如果去掉上图中&lt;code&gt;r&lt;/code&gt;和&lt;code&gt;d&lt;/code&gt;两列，则每个二维表都变成了一个一维表（list），那么我们试图把数据还原回去，&lt;code&gt;DocId&lt;/code&gt;没问题，一定是属于两个&lt;code&gt;Document&lt;/code&gt;的。&lt;code&gt;Name.Url&lt;/code&gt;就出现了问题，因为&lt;code&gt;Name&lt;/code&gt;是&lt;code&gt;repeated&lt;/code&gt;的，我怎么知道这3个&lt;code&gt;Name.Url&lt;/code&gt;是全属于第一个&lt;code&gt;Document&lt;/code&gt;，还是其他情况呢？丢失的信息太多无法还原了。所有我们需要记录每个值是否是重复的以及在哪一层重复的（比如是在第一个&lt;code&gt;Name&lt;/code&gt;的第二个&lt;code&gt;Code&lt;/code&gt;，还是第二个&lt;code&gt;Name&lt;/code&gt;的第一个&lt;code&gt;Code&lt;/code&gt;）。有了这个信息，我们就可以根据之前的记录一个一个往上拼接来还原原始的数据结构。&lt;code&gt;r&lt;/code&gt;就是做这个的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;r&lt;/code&gt;是重复层次（Repetition Level）&lt;/strong&gt;，记录该列的值是在哪一个层次上重。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;r&lt;/code&gt;是0，则表示是第一个（非重复）的元素，如上图中的&lt;code&gt;DocId&lt;/code&gt;，两个DocId都是第一个元素，比较简单。但其他的字段就比较复杂了，如&lt;code&gt;Name.Language.Code&lt;/code&gt;，一共有五行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;en-us&lt;/code&gt;是第一个&lt;code&gt;Document&lt;/code&gt;（不同的&lt;code&gt;Document&lt;/code&gt;不算重复，不影响&lt;code&gt;r&lt;/code&gt;和&lt;code&gt;d&lt;/code&gt;的取值，只有&lt;code&gt;repeated&lt;/code&gt;类型的字段才算）里第一个&lt;code&gt;Name&lt;/code&gt;中的第一个&lt;code&gt;Language&lt;/code&gt;里的，重复还没有发生，所以&lt;code&gt;r&lt;/code&gt;是0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;en&lt;/code&gt;是第一个&lt;code&gt;Document&lt;/code&gt;里第一个&lt;code&gt;Name&lt;/code&gt;中第二个&lt;code&gt;Language&lt;/code&gt;里的，&lt;code&gt;Language&lt;/code&gt;发生了重复，在/Name/Language层次结构中处于第二层，所以&lt;code&gt;r&lt;/code&gt;是2。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;en-gb&lt;/code&gt;是第一个&lt;code&gt;Document&lt;/code&gt;里第三个&lt;code&gt;Name&lt;/code&gt;中第一个&lt;code&gt;Language&lt;/code&gt;里的，&lt;code&gt;Name&lt;/code&gt;发生了重复，在/Name/Language层次结构中处于第一层，所以&lt;code&gt;r&lt;/code&gt;是1。&lt;/li&gt;
&lt;li&gt;第一个&lt;code&gt;NULL&lt;/code&gt;是第一个&lt;code&gt;Document&lt;/code&gt;里第二个&lt;code&gt;Name&lt;/code&gt;中的，&lt;code&gt;Name&lt;/code&gt;发生了重复，在/Name/Language层次结构中处于第一层，所以&lt;code&gt;r&lt;/code&gt;是1。&lt;/li&gt;
&lt;li&gt;第二个&lt;code&gt;NULL&lt;/code&gt;是第二个&lt;code&gt;Document&lt;/code&gt;里第一个&lt;code&gt;Name&lt;/code&gt;中的，没有发生重复，所以&lt;code&gt;r&lt;/code&gt;是0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里例子中没有出现多个字段都发生重复的情况，如第二个&lt;code&gt;Name&lt;/code&gt;中的第二个&lt;code&gt;Language&lt;/code&gt;的&lt;code&gt;Code&lt;/code&gt;。如果是这种情况，那么&lt;code&gt;r&lt;/code&gt;取最大的，也就是最近发生重复的字段，这里例子中就是&lt;code&gt;Language&lt;/code&gt;的2。（&lt;strong&gt;待验证&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;之前还有个问题没有回答，为何要记录&lt;code&gt;NULL&lt;/code&gt;呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果把图中所有的&lt;code&gt;NULL&lt;/code&gt;都去掉，看会发生什么。 拿&lt;code&gt;Links.Backward&lt;/code&gt;举例，去掉第一行的&lt;code&gt;NULL&lt;/code&gt;后，我们读到第一个&lt;code&gt;Links.Backward&lt;/code&gt;，必然认为它是属于第一个&lt;code&gt;Document&lt;/code&gt;的，但实际数据中第一个&lt;code&gt;Document&lt;/code&gt;里没有&lt;code&gt;Links.Backward&lt;/code&gt;，完全搞错了。所以即使是&lt;code&gt;NULL&lt;/code&gt;也必须记录，为了后续的数据知道自己在哪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么有了&lt;code&gt;r&lt;/code&gt;后，是否信息就完善了呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们还是假设去掉&lt;code&gt;d&lt;/code&gt;的一列，试图还原数据。&lt;code&gt;DocId&lt;/code&gt;依然没问题，&lt;code&gt;Name.Url&lt;/code&gt;也没问题了，直接看&lt;code&gt;Name.Language.Country&lt;/code&gt;吧：&lt;/p&gt;
&lt;p&gt;读完第一行我们得到了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Document&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;us&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二行是个&lt;code&gt;NULL&lt;/code&gt;，是在第二层也就是&lt;code&gt;Language&lt;/code&gt;重复的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Document&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;us&amp;#39;&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第三行又是个&lt;code&gt;NULL&lt;/code&gt;，是在第一层也就是&lt;code&gt;Name&lt;/code&gt;重复的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Document&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;us&amp;#39;&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第四行是在第一层也就是&lt;code&gt;Name&lt;/code&gt;重复的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Document&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;us&amp;#39;&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;gb&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起来似乎没问题，不过对比原始数据发现第二个&lt;code&gt;Name&lt;/code&gt;不只没有&lt;code&gt;Country&lt;/code&gt;，连上层的&lt;code&gt;Language&lt;/code&gt;也没有。也就是单看&lt;code&gt;Name.Language.Country&lt;/code&gt;这个表，还是把数据还原错了。虽然把所有的表都还原出来，然后去掉所有的&lt;code&gt;NULL&lt;/code&gt;以及&lt;code&gt;NULL&lt;/code&gt;上边多余的部分，还是可以准确还原，但如果只是去查询某个字段，难道需要把其他所有字段全部分析一遍吗？另外没有发生重复的字段，具体是&lt;code&gt;required&lt;/code&gt;、&lt;code&gt;repeated&lt;/code&gt;、还是&lt;code&gt;optional&lt;/code&gt;的信息也丢了。（&lt;strong&gt;此处似乎还有其他问题&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;为了解决这个问题，&lt;code&gt;d&lt;/code&gt;被引入了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;d&lt;/code&gt;是定义层次（Definition Level）&lt;/strong&gt;，记录这个值是在哪一层被定义的。需要注意的是如果这个值是&lt;code&gt;required&lt;/code&gt;的，则层数不包括自身，否则如果是&lt;code&gt;repeated&lt;/code&gt;或&lt;code&gt;optional&lt;/code&gt;的，则包括自身。目的主要是区分是否是&lt;code&gt;required&lt;/code&gt;字段（&lt;strong&gt;但如何区分只有一行的&lt;code&gt;repeated&lt;/code&gt;和&lt;code&gt;optional&lt;/code&gt;呢？&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Document.Links.Backward&lt;/code&gt;的&lt;code&gt;d&lt;/code&gt;是2（&lt;code&gt;Document&lt;/code&gt;是0）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Document.Name.Language.Code&lt;/code&gt;也是2（因为&lt;code&gt;Code&lt;/code&gt;是&lt;code&gt;required&lt;/code&gt;的，所以不包括它自己）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于一般的数据，这个值看起来没什么意义（除了可以区分是否是&lt;code&gt;required&lt;/code&gt;字段），因为已经有值了，从根到它自身整条路径必然是存在的，但对于&lt;code&gt;NULL&lt;/code&gt;则不同，&lt;code&gt;d&lt;/code&gt;可以说明这个&lt;code&gt;NULL&lt;/code&gt;是在哪一层定义的，也就是解决我们之前还原&lt;code&gt;Name.Language.Country&lt;/code&gt;数据遇到的问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;r&lt;/code&gt;和&lt;code&gt;d&lt;/code&gt;这两个值还是需要好好理解一下，而且还有一些没弄清楚的细节，以及具体查询的复杂逻辑，只能后续继续学习了。&lt;/p&gt;
&lt;p&gt;因为种种原因，这一系列学习笔记最近可能不会更新了。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.yankay.com/google-dremel-rationale/"&gt;Google Dremel 原理 - 如何能3秒分析1PB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36632.pdf"&gt;Dremel Interactive Analysis of WebScaleDatasets.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Apache Drill 学习笔记一：环境搭建和简单试用</title><link href="/apache-drill-xue-xi-bi-ji-yi-huan-jing-da-jian-he-jian-dan-shi-yong.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/apache-drill-xue-xi-bi-ji-yi-huan-jing-da-jian-he-jian-dan-shi-yong.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;Apache Drill是一个低延迟的分布式海量数据（涵盖结构化、半结构化以及嵌套数据）交互式查询引擎，使用ANSI SQL兼容语法，支持本地文件、HDFS、HBase、MongoDB等后端存储，支持Parquet、JSON、CSV、TSV、PSV等数据格式。受Google的Dremel启发，Drill满足上千节点的PB级别数据的交互式商业智能分析场景。&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;Drill可以安装在单机或者集群环境上，支持Linux、Windows、Mac OS X系统。简单起见，我们在Linux单机环境（CentOS 6.3）搭建以供试用。&lt;/p&gt;
&lt;p&gt;准备安装包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jdk 7：&lt;a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html"&gt;jdk-7u75-linux-x64.tar.gz&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;Drill：&lt;a href="http://getdrill.org/drill/download/apache-drill-0.8.0.tar.gz"&gt;apache-drill-0.8.0.tar.gz&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在$WORK（/path/to/work）目录中安装 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;Apache Drill是一个低延迟的分布式海量数据（涵盖结构化、半结构化以及嵌套数据）交互式查询引擎，使用ANSI SQL兼容语法，支持本地文件、HDFS、HBase、MongoDB等后端存储，支持Parquet、JSON、CSV、TSV、PSV等数据格式。受Google的Dremel启发，Drill满足上千节点的PB级别数据的交互式商业智能分析场景。&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;Drill可以安装在单机或者集群环境上，支持Linux、Windows、Mac OS X系统。简单起见，我们在Linux单机环境（CentOS 6.3）搭建以供试用。&lt;/p&gt;
&lt;p&gt;准备安装包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jdk 7：&lt;a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html"&gt;jdk-7u75-linux-x64.tar.gz&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;Drill：&lt;a href="http://getdrill.org/drill/download/apache-drill-0.8.0.tar.gz"&gt;apache-drill-0.8.0.tar.gz&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在$WORK（/path/to/work）目录中安装，将jdk和drill分别解压到java和drill目录中，并打软连以便升级：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;.
├── drill
│   ├── apache-drill -&amp;gt; apache-drill-0.8.0
│   └── apache-drill-0.8.0
├── init.sh
└── java
    ├── jdk -&amp;gt; jdk1.7.0_75
    └── jdk1.7.0_75
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;并添加一init.sh脚本初始化java相关环境变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;WORK&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/path/to/work&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;JAVA&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$WORK&lt;/span&gt;&lt;span class="s2"&gt;/java/jdk/bin/java&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;JAVA_HOME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$WORK&lt;/span&gt;&lt;span class="s2"&gt;/java/jdk&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;启动&lt;/h2&gt;
&lt;p&gt;在单机环境运行只需要启动bin/sqlline便可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; &lt;span class="nv"&gt;$WORK&lt;/span&gt;
$ . ./init.sh
$ ./drill/apache-drill/bin/sqlline -u jdbc:drill:zk&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;local&lt;/span&gt;
Drill log directory /var/log/drill does not exist or is not writable, defaulting to ...
Apr &lt;span class="m"&gt;06&lt;/span&gt;, &lt;span class="m"&gt;2015&lt;/span&gt; &lt;span class="m"&gt;12&lt;/span&gt;:47:30 AM org.glassfish.jersey.server.ApplicationHandler initialize
INFO: Initiating Jersey application, version Jersey: &lt;span class="m"&gt;2&lt;/span&gt;.8 &lt;span class="m"&gt;2014&lt;/span&gt;-04-29 &lt;span class="m"&gt;01&lt;/span&gt;:25:26...
sqlline version &lt;span class="m"&gt;1&lt;/span&gt;.1.6
&lt;span class="m"&gt;0&lt;/span&gt;: jdbc:drill:zk&lt;span class="o"&gt;=&lt;/span&gt;local&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;-u jdbc:drill:zk=local&lt;/code&gt;表示使用本机的Drill，无需启动ZooKeeper，如果是集群环境则需要配置和启动ZooKeeper并填写地址。启动后便可以在&lt;code&gt;0: jdbc:drill:zk=local&amp;gt;&lt;/code&gt;后敲入命令使用了。&lt;/p&gt;
&lt;h2&gt;试用&lt;/h2&gt;
&lt;p&gt;Drill的sample-data目录有Parquet格式的演示数据可供查询：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/apache-drill/sample-data/&lt;/span&gt;&lt;span class="n"&gt;nation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;parquet&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="n"&gt;limit&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+-------------+------------+-------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;N_NATIONKEY&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;N_NAME&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;N_REGIONKEY&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;N_COMMENT&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+-------------+------------+-------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ALGERIA&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;haggle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;carefully&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ARGENTINA&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;foxes&lt;/span&gt; &lt;span class="n"&gt;promise&lt;/span&gt; &lt;span class="n"&gt;sly&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;BRAZIL&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;alongside&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;CANADA&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;eas&lt;/span&gt; &lt;span class="n"&gt;hang&lt;/span&gt; &lt;span class="n"&gt;ironic&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;EGYPT&lt;/span&gt;      &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;above&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;carefull&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+-------------+------------+-------------+------------+&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.741&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里用的库名格式为dfs.`本地文件（Parquet、JSON、CSV等文件）绝对路径`。可以看出只要熟悉SQL语法几乎没有学习成本。但Parquet格式文件需要专用工具查看、编辑，不是很方便，后续再专门介绍，下文先使用更通用的CSV和JSON文件进行演示。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;$WORK/data&lt;/code&gt;中创建如下&lt;code&gt;test.csv&lt;/code&gt;文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="m"&gt;1101&lt;/span&gt;,SteveEurich,Steve,Eurich,16,StoreT
&lt;span class="m"&gt;1102&lt;/span&gt;,MaryPierson,Mary,Pierson,16,StoreT
&lt;span class="m"&gt;1103&lt;/span&gt;,LeoJones,Leo,Jones,16,StoreTem
&lt;span class="m"&gt;1104&lt;/span&gt;,NancyBeatty,Nancy,Beatty,16,StoreT
&lt;span class="m"&gt;1105&lt;/span&gt;,ClaraMcNight,Clara,McNight,16,Store
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后查询：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;csv&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;columns&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1101&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;SteveEurich&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Steve&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Eurich&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;16&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;StoreT&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1102&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;MaryPierson&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Mary&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Pierson&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;16&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;StoreT&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1103&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;LeoJones&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Leo&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Jones&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;16&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;StoreTem&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1104&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;NancyBeatty&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Nancy&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Beatty&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;16&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;StoreT&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1105&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ClaraMcNight&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Clara&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;McNight&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;16&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Store&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.082&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到结果和之前的稍有不同，因为CSV文件没有地方存放列列名，所以统一用&lt;code&gt;columns&lt;/code&gt;代替，如果需要具体制定列则需要用&lt;code&gt;columns[n]&lt;/code&gt;，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt; &lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;csv&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$0&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$1&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1101&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Eurich&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1102&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Pierson&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1103&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Jones&lt;/span&gt;      &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1104&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Beatty&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1105&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;McNight&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CSV文件格式比较简单，发挥不出Drill的强大优势，下边更复杂的功能使用和Parquet更接近的JSON文件进行演示。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;$WORK/data&lt;/code&gt;中创建如下&lt;code&gt;test.json&lt;/code&gt;文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;ka1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kb1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;1.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kc1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;vc11&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kd1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;ka2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;kb2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;10.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;kc2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;vc1010&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;ka1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kb1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;2.2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kc1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;vc22&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kd1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;ka2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;kb2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;20.2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;kc2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;vc2020&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;ka1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kb1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;3.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kc1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;vc33&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kd1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;ka2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;kb2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;30.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;kc2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;vc3030&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到这个JSON文件内容是有多层嵌套的，结构比之前那个CSV文件要复杂不少，而查询嵌套数据正是Drill的优势所在。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;json&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;ka1&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;kb1&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;kc1&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;kd1&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;1.1&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc11&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ka2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kb2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;10.1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kc2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;vc1010&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;}]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;2.2&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc22&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ka2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kb2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;20.2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kc2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;vc2020&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;}]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;3.3&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc33&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ka2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kb2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;30.3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kc2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;vc3030&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;}]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+------------+------------+&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.098&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;select *&lt;/code&gt;只查出第一层的数据，更深层的数据只以原本的JSON数据呈现出来，我们显然不应该只关心第一层的数据，具体怎么查完全随心所欲：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ka1&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="n"&gt;avg&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kd1&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;].&lt;/span&gt;&lt;span class="n"&gt;kb2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;json&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$0&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$1&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;20.2&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.136&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以通过&lt;code&gt;kd1[0]&lt;/code&gt;来访问嵌套到第二层的这个表。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;kc1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kd1&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;].&lt;/span&gt;&lt;span class="n"&gt;kc2&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;json&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;kd1&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;].&lt;/span&gt;&lt;span class="n"&gt;kb2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;10.1&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;ka1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;kc1&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$1&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc11&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc1010&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.181&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;创建view：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;tmpview&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;kd1&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;].&lt;/span&gt;&lt;span class="n"&gt;kb2&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;json&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;     &lt;span class="n"&gt;ok&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;summary&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;tmpview&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt; &lt;span class="n"&gt;successfully&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;dfs.tmp&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;schema&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.055&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;tmpview&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$0&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;10.1&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;20.2&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;30.3&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.193&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以把嵌套的第二层表打平（整合kd1[0]..kd1[n]）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;kddb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;kdtable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;kc2&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;flatten&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kd1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;kdtable&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;json&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;kddb&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$0&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc1010&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc2020&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc3030&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.083&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用细节上和mysql还是有所不同的，另外涉及到多层表的复杂逻辑，要想用得得心应手还需要仔细阅读官方文档并多多练习。这次先走马观花了，之后会深入了解语法层面的特性。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://cwiki.apache.org/confluence/display/DRILL/Apache+Drill+in+10+Minutes"&gt;Apache Drill in 10 Minutes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cwiki.apache.org/confluence/display/DRILL/Analyzing+Yelp+JSON+Data+with+Apache+Drill"&gt;Analyzing Yelp JSON Data with Apache Drill&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>不恰当地夸一个人比骂一个人还要糟糕</title><link href="/bu-qia-dang-di-kua-yi-ge-ren-bi-ma-yi-ge-ren-huan-yao-zao-gao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/bu-qia-dang-di-kua-yi-ge-ren-bi-ma-yi-ge-ren-huan-yao-zao-gao.html</id><summary type="html">&lt;p&gt;不恰当地夸一个人比骂一个人还要糟糕，这是我较早之前听一个文学作品赏析节目时产生的的观点，印象深刻。我想很多人都会有类似的观点，但刚才我去网上搜了一圈，似乎没有搜到。&lt;/p&gt;
&lt;p&gt;我这里说的夸或者骂一个人，都是指在当事人不在的场合，或者说是在背地里说一个人的好话或者坏话。在背地里骂一个人是很糟糕的行为，大家都非常清楚，无需过多讨论，这里仔细讲在背地里夸一个人的情况。&lt;/p&gt;
&lt;p&gt;比如 a 对一个或多个人夸 b。如果 a 说的话全部如实，通常是没有问题的。但是人在夸另一个人时，往往会夸大其词，这可能有很多原因，比如因为 a 很崇拜 b，或者 a 的见识有限，所以自然而然地把话说得比较大，也可能是故意说得夸张一点。这样就很容易出问题。在场的人可以大致分成两类，第一类是对 b 了解较多的人，第二类是完全不知道 b 或者知道 b 但对他了解较少的人。&lt;/p&gt;
&lt;p&gt;第一类人很容易发现 a 说得有些夸张，但因为他们了解 b，不会对 b …&lt;/p&gt;</summary><content type="html">&lt;p&gt;不恰当地夸一个人比骂一个人还要糟糕，这是我较早之前听一个文学作品赏析节目时产生的的观点，印象深刻。我想很多人都会有类似的观点，但刚才我去网上搜了一圈，似乎没有搜到。&lt;/p&gt;
&lt;p&gt;我这里说的夸或者骂一个人，都是指在当事人不在的场合，或者说是在背地里说一个人的好话或者坏话。在背地里骂一个人是很糟糕的行为，大家都非常清楚，无需过多讨论，这里仔细讲在背地里夸一个人的情况。&lt;/p&gt;
&lt;p&gt;比如 a 对一个或多个人夸 b。如果 a 说的话全部如实，通常是没有问题的。但是人在夸另一个人时，往往会夸大其词，这可能有很多原因，比如因为 a 很崇拜 b，或者 a 的见识有限，所以自然而然地把话说得比较大，也可能是故意说得夸张一点。这样就很容易出问题。在场的人可以大致分成两类，第一类是对 b 了解较多的人，第二类是完全不知道 b 或者知道 b 但对他了解较少的人。&lt;/p&gt;
&lt;p&gt;第一类人很容易发现 a 说得有些夸张，但因为他们了解 b，不会对 b 产生不良的印象，只会感觉 a 是一个比较轻浮或者目光短浅的人，而 a 在夸夸其谈时往往不清楚就这样给别人留下了不好的印象。这还是较好的一种情况。&lt;/p&gt;
&lt;p&gt;但第二类人因为并不是很了解 b，所以会根据自己的知识和经验来判断 a 说的是恰如其分还是夸大其词。这里举一个例子，比如 a 在公共场合讲《红楼梦》时说曹雪芹诗词写得多么多么好，用了很多溢美之词。认真读过红楼梦的人清楚不能说《红楼梦》里的诗词不好，但比起那些流传千古的诗词还是有相当差距的，他们会感觉 a 说得有些夸张了，而不会对曹雪芹或者《红楼梦》产生不好的印象。但没有仔细读过《红楼梦》的人想法可能就不一样了，他们很可能会想曹雪芹的诗词好？比他诗词好的人大有人在，曹雪芹算什么，你去大街上顺便找一个人，问他能背下来一首完整的曹雪芹写的诗么？因此他就很可能对曹雪芹或者《红楼梦》产生偏见，本来可能想着有时间去读读，有了偏见反而不想去读了。这样矛头就从 a 转到 b 了，b 成了无辜躺枪的角色。&lt;/p&gt;
&lt;p&gt;这样结果是虽然 a 夸了 b，认为自己的行为对宣传 b 起了很多正面作用。但第一类人中的大多数因为本来就很了解 b，宣传效果没有起到，却又让他们对 a 自身产生了负面印象。而第二类人中的一部分（甚至可能是一大部分）很可能对 b 产生了负面的印象，a 不仅没有起到宣传作用，却抹黑了一把。&lt;/p&gt;
&lt;p&gt;这又让我想起来前些天看和《东方时空》相关的一个纪录片的片段，里边好像是时间说大概这样一句话，作为记者采访时不要随便称被采访对象为老师，除非他的职业就是老师，即使是幼儿园老师，你可能因为尊敬他称他是老师并且感觉没什么问题，但可能季羡林也在看这个节目，那么季老也应该和你一同称呼他老师吗？&lt;/p&gt;
&lt;p&gt;当然如果真是季羡林在看，倒也没有问题。但很多喜欢较真的人会想他也配被称作老师，从而抓他一招之错对他产生负面的印象？这样就无形中抹黑了被采访人了。仅仅是一个礼貌的称呼就会产生这样的效果，夸张地夸一个人产生的负面效果就更严重了，而这一切当事人可能是完全没有察觉到的。&lt;/p&gt;
&lt;p&gt;那么怎样夸别人不会让人反感呢？&lt;/p&gt;
&lt;p&gt;首先，最忌讳的一个字是“最”，在任何情况都不应该使用这个字。有人会说公认的也不行吗？不行，所谓的公认最多只能覆盖多数人，甚至多数人也覆盖不了，只是一些文人或者特定领域的人“内定”的。还是拿之前的《红楼梦》节目举例，其中频繁使用“最好的文学”、“最好的文字”等，基本无时无刻不在给红楼梦抹黑，让人非常反感。&lt;/p&gt;
&lt;p&gt;其次，尽量明确说明自己所说的是自己个人的看法。比如“我认为他是一个怎样的人”，“在我看来他的作品有怎样的特点”。这样别人听了后，即使不认同也不大会将矛头转到“他”那。&lt;/p&gt;
&lt;p&gt;最后，尽量不要宽泛地评价一个人或者他的作品等。如果我说某个人做了一件怎样的事，从这件事中我可以看出他有怎样的特点。这样有理有据，只要我说得不是特别夸张，逻辑不是特别混乱，基本是可以让别人信服的。但如果我没有前边的铺垫，直接对他或者他的作品进行评价，就会很容易产生问题，即使我说明了是自己的个人观点，并且说得不是特别夸张，还是会给很多其他人留下不好的印象。&lt;/p&gt;
&lt;p&gt;那么夸一个人本来应该是一件很善意的事情，为什么会产生这么多问题呢？其实很多情况夸别人的目的并不单纯，当事人往往在夸别人的同时也借他来彰显自己，或者说很多情况夸别人其实是自夸。比如他可能会想夸这个人说明我很有品位，说明我见多识广，说明我独具慧眼等等，结果就很容易搬起石头砸自己的脚了。&lt;/p&gt;</content></entry><entry><title>从 Cygwin 迁移到 MSYS2 的原因和步骤</title><link href="/cong-cygwin-qian-yi-dao-msys2-de-yuan-yin-he-bu-zou.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/cong-cygwin-qian-yi-dao-msys2-de-yuan-yin-he-bu-zou.html</id><summary type="html">&lt;h2&gt;为什么从cygwin迁移到msys2&lt;/h2&gt;
&lt;p&gt;习惯Linux后，再使用Windows的话，cygwin基本是必须的。&lt;strong&gt;但cygwin有一些痛点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有一个好用的包管理工具，无论是官方的setup.exe，还是第三方的几个apt-cyg，都存在使用不方便和功能不全的问题：&lt;ul&gt;
&lt;li&gt;setup.exe选包很累人&lt;/li&gt;
&lt;li&gt;apt-cyg和它的依赖得额外安装&lt;/li&gt;
&lt;li&gt;cygwin的已安装软件数据库不区分是直接安装的还是被依赖的包，一旦装上想等卸载就只能自己手动分辨了&lt;/li&gt;
&lt;li&gt;apt-cyg不支持软件升级操作，我自己加上了这个功能（&lt;a href="https://github.com/goreliu/apt-cyg"&gt;goreliu/apt-cyg&lt;/a&gt;），虽然基本能用，但还是存在一些问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cygwin的软件打包方式不方便，并且为官方软件仓库提交新的包需要走加邮件列表、发邮件、确认、上传等诸多流程&lt;/li&gt;
&lt;li&gt;cygwin里不少软件的版本还是比较老的，比如git还是2.1.4版本的，升级缓慢（一个好消息是python和ruby最近几天升级到最新版本了，之前还是python 2.7.8/3.2.2、ruby 2.0.0，盼了好久）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;而msys2基本上解决了这些问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用从archlinux移植过来的pacman，功能完整，使用方便&lt;/li&gt;
&lt;li&gt;PKGBUILD好写，用过archlinux的话无学习成本 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h2&gt;为什么从cygwin迁移到msys2&lt;/h2&gt;
&lt;p&gt;习惯Linux后，再使用Windows的话，cygwin基本是必须的。&lt;strong&gt;但cygwin有一些痛点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有一个好用的包管理工具，无论是官方的setup.exe，还是第三方的几个apt-cyg，都存在使用不方便和功能不全的问题：&lt;ul&gt;
&lt;li&gt;setup.exe选包很累人&lt;/li&gt;
&lt;li&gt;apt-cyg和它的依赖得额外安装&lt;/li&gt;
&lt;li&gt;cygwin的已安装软件数据库不区分是直接安装的还是被依赖的包，一旦装上想等卸载就只能自己手动分辨了&lt;/li&gt;
&lt;li&gt;apt-cyg不支持软件升级操作，我自己加上了这个功能（&lt;a href="https://github.com/goreliu/apt-cyg"&gt;goreliu/apt-cyg&lt;/a&gt;），虽然基本能用，但还是存在一些问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cygwin的软件打包方式不方便，并且为官方软件仓库提交新的包需要走加邮件列表、发邮件、确认、上传等诸多流程&lt;/li&gt;
&lt;li&gt;cygwin里不少软件的版本还是比较老的，比如git还是2.1.4版本的，升级缓慢（一个好消息是python和ruby最近几天升级到最新版本了，之前还是python 2.7.8/3.2.2、ruby 2.0.0，盼了好久）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;而msys2基本上解决了这些问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用从archlinux移植过来的pacman，功能完整，使用方便&lt;/li&gt;
&lt;li&gt;PKGBUILD好写，用过archlinux的话无学习成本，为官方源提交新包可以直接在github发PR&lt;/li&gt;
&lt;li&gt;msys2里的软件总体是要比cygwin新的（一个特例，最近cygwin的ruby升级到了最新的2.2，而msys2的还是2.1）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;迁移的麻烦&lt;/h2&gt;
&lt;p&gt;我几个月前就在垂涎msys2，但因为&lt;strong&gt;几个麻烦的问题&lt;/strong&gt;，每次都作罢：
1. cygwin是可以使用acl选项挂载文件系统的，这种情况下chmod基本可用（虽然也有些问题），而msys2只能使用noacl选项挂载，chmod基本无法工作（只能修改第一个w），每个用户都有文件的读权限，是否有执行权限根据文件扩展名和内容决定。直接的影响就是使用git时无法使本地文件权限和远程的一致。
2. 我使用的一些软件cygwin里有，而msys2里没有，比如w3m、dig、atool、bvi、cygstart。
3. 有些软件支持直接在cygwin编译，而在msys2编译的话需要打patch。&lt;/p&gt;
&lt;p&gt;之前主要是阻塞在第1个问题上了，查了好久如何开启acl，无果。今天突然想到是否可以让git忽略本机权限，果然有方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config core.filemode false
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外还有.ssh目录无法修改成700的麻烦，好在我不需要在msys2开sshd，可以不考虑这个。那么权限的文件基本就没有了。&lt;/p&gt;
&lt;p&gt;第2个问题就相对好处理了，自己编译打包了bviplus、atool、w3m、cygutils（里边有cygstart）等，因为之前在archlinux就经常自己打包，轻车熟路，PKGBUILD见https://github.com/goreliu/my-MSYS2-Packages。Dig不好编译，但有现成的可以&lt;a href="http://ftp.isc.org/isc/bind9/"&gt;下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;第3个问题只是稍微麻烦些，可以写个脚本搞定，基本不用考虑。&lt;/p&gt;
&lt;p&gt;折腾了一下午，终于迁移了过了，删掉了cygwin。&lt;/p&gt;
&lt;h2&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从&lt;a href="http://sourceforge.net/projects/msys2/"&gt;官网&lt;/a&gt;下载最新的安装包，安装到c:\msys64。&lt;/li&gt;
&lt;li&gt;将之前cygwin的home目录直接替换到msys64/home&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkpasswd &amp;gt; /etc/passwd; mkgroup &amp;gt; /etc/group&lt;/code&gt;，和cygwin里一样&lt;/li&gt;
&lt;li&gt;注释掉/etc/fstab中的那一行，保留/cygdrive目录，以和cygwin一致（可选）&lt;/li&gt;
&lt;li&gt;修改/etc/etc/pacman.d/mirrorlist.*，改成国内地址，如http://mirror.bit.edu.cn/msys2/&lt;/li&gt;
&lt;li&gt;使用pacman安装需要的软件&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在文件浏览器的邮件添加Open MSYS2 here的菜单：&lt;/p&gt;
&lt;p&gt;Windows Registry Editor Version 5.00&lt;/p&gt;
&lt;p&gt;[HKEY_CLASSES_ROOT\Directory\Background\shell\open_msys2]
@="Open MSYS2 here"&lt;/p&gt;
&lt;p&gt;[HKEY_CLASSES_ROOT\Directory\Background\shell\open_msys2\command]
@="c:\msys64\usr\bin\mintty.exe /bin/sh -lc 'cd \"$(cygpath \"%V\")\"; exec zsh'"&lt;/p&gt;
&lt;p&gt;[HKEY_CLASSES_ROOT\Folder\shell\open_msys2]
@="Open MSYS2 here"&lt;/p&gt;
&lt;p&gt;[HKEY_CLASSES_ROOT\Folder\shell\open_msys2\command]
@="c:\msys64\usr\bin\mintty.exe /bin/sh -lc 'cd \"$(cygpath \"%V\")\"; exec zsh'"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建指向&lt;code&gt;C:\msys64\usr\bin\mintty.exe /usr/bin/zsh --login&lt;/code&gt;的快捷方式，并绑定快捷键&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;设置&lt;code&gt;export MSYS="winsymlinks:lnk"&lt;/code&gt;关键变量，不然打软连直接变成了复制&lt;/li&gt;
&lt;li&gt;在需要忽略本地文件权限的git repo目录运行&lt;code&gt;git config core.filemode false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从&lt;a href="http://ftp.isc.org/isc/bind9/"&gt;isc.org&lt;/a&gt;下载windows版本的bind，包含host、dig等命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone git@github.com:goreliu/my-MSYS2-Packages.git&lt;/code&gt;，进入需要的目录，运行 &lt;code&gt;makepkg&lt;/code&gt;和&lt;code&gt;pacman -U xxx.tar.xz&lt;/code&gt;安装自己打的包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后环境就和之前的cygwin没有什么区别了。&lt;/p&gt;</content></entry><entry><title>从更长远的视角看人生的目的</title><link href="/cong-geng-chang-yuan-de-shi-jiao-kan-ren-sheng-de-mu-de.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/cong-geng-chang-yuan-de-shi-jiao-kan-ren-sheng-de-mu-de.html</id><summary type="html">&lt;p&gt;人生目的是一个经久不衰的话题。它并无统一的答案，往往因人而异。简单说，一个人过对他来说最绚烂的一生，便是他的人生目的。但是有些时候我们需要更细致地探讨这个问题，而不是简单绕过。&lt;/p&gt;
&lt;p&gt;如果每个人生来的初始条件都是相同的，那么恐怕问题会简化很多，就像每个人出生后都用同样的笔在一张纸上作画一样。而实际上初始条件并不相同，就像有人得到了一张如同一面墙的平整画布和五彩绚烂的画笔，有人却只得到一块抹布般的褶皱画布和时常折断的破旧铅笔，两个人作出的画显然是不同的。这不公平，成了某些人心中永久的刺。&lt;/p&gt;
&lt;p&gt;解释这个问题比想象的要复杂很多，也难有一个能让所有人接受的答案。在之前我也有一些疑问，虽然无关公平，但也同属一类问题。而最近，我仔细阅读了一份至关重要的资料后，化解了一些疑问，打算尽量简略地分析一下。&lt;/p&gt;
&lt;p&gt;首先需要明确的是一个人并不是只活这一世，死后也不会烟消雾散。生命是生生不息的，出生和死亡仅仅是一种生命形式的转换。这一点不是猜想或者信仰，而是毫无争议的事实。凡是对生命有过仔细思考和求证的人不会对此有所怀疑。而不接受这个前提的话，问题则无从谈起。然而也不像某些宗教里的轮回转世那样简单。&lt;/p&gt;</summary><content type="html">&lt;p&gt;人生目的是一个经久不衰的话题。它并无统一的答案，往往因人而异。简单说，一个人过对他来说最绚烂的一生，便是他的人生目的。但是有些时候我们需要更细致地探讨这个问题，而不是简单绕过。&lt;/p&gt;
&lt;p&gt;如果每个人生来的初始条件都是相同的，那么恐怕问题会简化很多，就像每个人出生后都用同样的笔在一张纸上作画一样。而实际上初始条件并不相同，就像有人得到了一张如同一面墙的平整画布和五彩绚烂的画笔，有人却只得到一块抹布般的褶皱画布和时常折断的破旧铅笔，两个人作出的画显然是不同的。这不公平，成了某些人心中永久的刺。&lt;/p&gt;
&lt;p&gt;解释这个问题比想象的要复杂很多，也难有一个能让所有人接受的答案。在之前我也有一些疑问，虽然无关公平，但也同属一类问题。而最近，我仔细阅读了一份至关重要的资料后，化解了一些疑问，打算尽量简略地分析一下。&lt;/p&gt;
&lt;p&gt;首先需要明确的是一个人并不是只活这一世，死后也不会烟消雾散。生命是生生不息的，出生和死亡仅仅是一种生命形式的转换。这一点不是猜想或者信仰，而是毫无争议的事实。凡是对生命有过仔细思考和求证的人不会对此有所怀疑。而不接受这个前提的话，问题则无从谈起。然而也不像某些宗教里的轮回转世那样简单。&lt;/p&gt;</content></entry><entry><title>大脑与电脑类比的一些思考</title><link href="/da-nao-yu-dian-nao-lei-bi-de-yi-xie-si-kao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/da-nao-yu-dian-nao-lei-bi-de-yi-xie-si-kao.html</id><summary type="html">&lt;p&gt;大脑是一个很复杂的结构，涉及到的其中很多问题至今没有定论，而电脑是一种相对简单和确定的结构。很多人喜欢用大脑和电脑做类比，来解释一下问题，虽然这样的类比也有很多不完美的地方，但仔细分析还是会有所收获。&lt;/p&gt;
&lt;p&gt;把大脑当黑盒分析是相对容易的。人体有视觉、听觉、触觉、嗅觉、味觉等输入，有肢体动作、声音等输出，这些输入和输出有一定的联系。我们可以想象一下，有这样一个机器人，也可以处理这些输入，同时具有这些输出功能，输出是由内部的电脑接受到输入信息，然后通过程序计算出来的。这样从外部看这个机器人和人看起来就很像了，如果将来科技发展到足够发达的程度，这样的机器人很可能在很多方面都比人要强大，以至于在很多地方可以取代人。&lt;/p&gt;
&lt;p&gt;但一旦深入大脑的内部功能，复杂度就陡然上升。比如我会汉语和英语两种语言，所以我可以将汉语翻译成英语，一个电脑程序也可以。但二者的原来不尽相同。我看到一句汉语后，理解了它的含义，然后用英语重新表述出来。而电脑程序是根据汉语词语和英语单词的对应关系，对汉语和英语进行转换，这个转换策略并不简单，但我们可以确定的是这个程序未必理解这句汉语的真正含义。我也可以模仿这个程序的功能，摆一本汉英词典在面前，查出每个汉语词语（为了忽略分词的功能，假设汉语语句已经分词处理过了）在汉英词典里的含义，得到对于的英文后，根据固定的语法规则调整排列顺序、词态、语态等，就翻译完成了 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;大脑是一个很复杂的结构，涉及到的其中很多问题至今没有定论，而电脑是一种相对简单和确定的结构。很多人喜欢用大脑和电脑做类比，来解释一下问题，虽然这样的类比也有很多不完美的地方，但仔细分析还是会有所收获。&lt;/p&gt;
&lt;p&gt;把大脑当黑盒分析是相对容易的。人体有视觉、听觉、触觉、嗅觉、味觉等输入，有肢体动作、声音等输出，这些输入和输出有一定的联系。我们可以想象一下，有这样一个机器人，也可以处理这些输入，同时具有这些输出功能，输出是由内部的电脑接受到输入信息，然后通过程序计算出来的。这样从外部看这个机器人和人看起来就很像了，如果将来科技发展到足够发达的程度，这样的机器人很可能在很多方面都比人要强大，以至于在很多地方可以取代人。&lt;/p&gt;
&lt;p&gt;但一旦深入大脑的内部功能，复杂度就陡然上升。比如我会汉语和英语两种语言，所以我可以将汉语翻译成英语，一个电脑程序也可以。但二者的原来不尽相同。我看到一句汉语后，理解了它的含义，然后用英语重新表述出来。而电脑程序是根据汉语词语和英语单词的对应关系，对汉语和英语进行转换，这个转换策略并不简单，但我们可以确定的是这个程序未必理解这句汉语的真正含义。我也可以模仿这个程序的功能，摆一本汉英词典在面前，查出每个汉语词语（为了忽略分词的功能，假设汉语语句已经分词处理过了）在汉英词典里的含义，得到对于的英文后，根据固定的语法规则调整排列顺序、词态、语态等，就翻译完成了。注意即使我对汉语和英语都一窍不通，这个过程还是可以完成，只是最后我对那句汉语的含义一无所知。事实上现在的翻译程序就是这么做的。&lt;/p&gt;
&lt;p&gt;那么为了模拟大脑，我们必须让这个翻译程序理解原文的含义。我们读取汉语后，实际上是将其转化成了内部语言，比如我看到苹果两个字后，自己想到的就不只是两个字这么简单了，因为以往的经历，我想到了苹果的形状、颜色、味道等等，这些都不是从苹果两个字中得到的。而颜色、味道等是一种主观的感觉，是无法无损地转换成文字的。&lt;/p&gt;
&lt;p&gt;电脑程序的几个部分。
处理输入信息
处理输出信息
数据库
内部语言处理逻辑
观察者&lt;/p&gt;</content></entry><entry><title>带权轮询算法</title><link href="/dai-quan-lun-xun-suan-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/dai-quan-lun-xun-suan-fa.html</id><summary type="html">&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;有Q1、Q2、……、Qn n个队列，每个队列有一个权值W1、W2、……、Wn，需要每次从其中一个队列取出一个元素，使得从不同队列取出的元素数量比例服从权值的比例。&lt;/p&gt;
&lt;h3&gt;解释&lt;/h3&gt;
&lt;p&gt;这正是网络流量调度场景中的“带权轮询调度”（Weighted Round-Robin Scheduling，WRR），有现成的算法可用。&lt;/p&gt;
&lt;p&gt;为了简单起见，先考虑最简单的情况，令 W1 = W2 = ... = Wn，那么“带权轮询调度”退化成“轮询调度”（Round-Robin Scheduling，RR），RR实现很简单，然后考虑权值不同的情况。&lt;/p&gt;
&lt;h3&gt;实现（python代码）&lt;/h3&gt;
&lt;h4&gt;RR&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# count
N = 3

# Round-Robin Scheduling
def rr_select():
    last = N - 1
    while True:
        current = (last …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;有Q1、Q2、……、Qn n个队列，每个队列有一个权值W1、W2、……、Wn，需要每次从其中一个队列取出一个元素，使得从不同队列取出的元素数量比例服从权值的比例。&lt;/p&gt;
&lt;h3&gt;解释&lt;/h3&gt;
&lt;p&gt;这正是网络流量调度场景中的“带权轮询调度”（Weighted Round-Robin Scheduling，WRR），有现成的算法可用。&lt;/p&gt;
&lt;p&gt;为了简单起见，先考虑最简单的情况，令 W1 = W2 = ... = Wn，那么“带权轮询调度”退化成“轮询调度”（Round-Robin Scheduling，RR），RR实现很简单，然后考虑权值不同的情况。&lt;/p&gt;
&lt;h3&gt;实现（python代码）&lt;/h3&gt;
&lt;h4&gt;RR&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# count
N = 3

# Round-Robin Scheduling
def rr_select():
    last = N - 1
    while True:
        current = (last + 1) % N
        last = current
        yield current

rr_test = rr_select()
for i in range(1000):
    print(rr_test.__next__())
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;N是队列的个数，0到N-1数字代表这N个队列。&lt;/p&gt;
&lt;p&gt;RR会依次从每个队列取出元素，很简单无需过多叙述。&lt;/p&gt;
&lt;h4&gt;WRR&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# count
N = 3

weight = (60, 30, 10)

# 最大公约数
def gcd(nums):
    m = nums[0]
    for n in nums[1:]:
        while n != 0:
            m, n = n, m % n
    return m

# Weighted Round-Robin Scheduling
def wrr_select():
    current = N - 1
    current_weight = 0

    while True:
        current = (current + 1) % N
        if current == 0:
            current_weight -= gcd(weight)
            if current_weight &amp;lt;= 0:
                current_weight = max(weight)
        if weight[current] &amp;gt;= current_weight:
            yield current

wrr_test = wrr_select()
for i in range(1000):
    print(wrr_test.__next__())
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个算法需要解释一下。&lt;/p&gt;
&lt;p&gt;先看一下取前10个元素的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;current_weight     从哪些队列取出了元素
60                 0
50                 0
40                 0
30                 0 1
20                 0 1
10                 0 1 2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也就是每次&lt;code&gt;for i in (0, 1, 2)&lt;/code&gt;的小周期内，当&lt;code&gt;current_weight &amp;gt; weight[i]&lt;/code&gt;时，就把&lt;code&gt;i&lt;/code&gt;选出来。当&lt;code&gt;current_weight&lt;/code&gt;等于&lt;code&gt;0&lt;/code&gt;了，就再从头开始，这算一个大周期。一个大周期包含&lt;code&gt;max(weight)/gcd(weight)&lt;/code&gt;个小周期。&lt;/p&gt;
&lt;p&gt;那如何证明这样取是符合权值比例的？&lt;/p&gt;
&lt;p&gt;可以看到每个小周期中，都是要从权值最大的队列里拿走一个元素的，可以看作拿权值最大的那个作为基准，然后权值较小的直接拿它对比。那仅看权值为10的便可，10是60的1/6，把60分6分，只有1份是应该给10的，所以60知道降到10才满足10的条件。权值30的同理。&lt;/p&gt;
&lt;p&gt;其实max(weight)和gcd(weight)都可以选择别的，但选它们两个可以满足最细粒度的平均，即每取出任意10个连续的中间结果，就必然服从权值比例，可以认为是最优的。&lt;/p&gt;
&lt;h3&gt;随机性考虑&lt;/h3&gt;
&lt;p&gt;WRR的运行结果是固定的，如果需要考虑随机性的话，需要再做一些额外工作。简单的话可以先对队列的顺序做随机，但这样实际的顺序还是固定的。可以按实际需要频繁暂存一定（随机）数量的结果，再随机处理后依次输出。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.163.com/s_u/blog/static/1330836720105233102894/"&gt;轮询调度算法(Round-Robin Scheduling)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.163.com/tianle_han/blog/static/661782620119165645590/"&gt;带权值轮询算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.xuebuyuan.com/126515.html"&gt;IPVS的调度算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Weighted_round_robin"&gt;Weighted round robin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>更好地使用 WSL 终端环境</title><link href="/geng-hao-di-shi-yong-wsl-zhong-duan-huan-jing.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/geng-hao-di-shi-yong-wsl-zhong-duan-huan-jing.html</id><summary type="html">&lt;p&gt;Windows 10 中包含了一个 WSL （ Windows Subsystem for Linux ）子系统，我们可以在其中运行未经修改过的原生 Linux ELF 可执行文件。利用它我们可以做很多事情，对开发人员和普通用户都是如此。当然对开发人员的吸引力更大一些，因为这意味着在一些情况，不再需要使用 Linux 虚拟机、双系统、 Cygwin/MSYS2 了。&lt;/p&gt;
&lt;p&gt;当前版本（ 14901.1000 ） Windows 10 中的 WSL 功能已经比较完善了，和刚出来时不可同日而语，也不再是一个没有实用价值的玩具了（最初的版本连 zsh 和 tmux 等最基本的工具都无法运行，基本没有可用性。但如果现在依然说 WSL 不可用，就有失偏颇了）。但对不想折腾的普通用户来说，用户体验并不好。比如中文显示有问题，不支持中文输入，只支持 16 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Windows 10 中包含了一个 WSL （ Windows Subsystem for Linux ）子系统，我们可以在其中运行未经修改过的原生 Linux ELF 可执行文件。利用它我们可以做很多事情，对开发人员和普通用户都是如此。当然对开发人员的吸引力更大一些，因为这意味着在一些情况，不再需要使用 Linux 虚拟机、双系统、 Cygwin/MSYS2 了。&lt;/p&gt;
&lt;p&gt;当前版本（ 14901.1000 ） Windows 10 中的 WSL 功能已经比较完善了，和刚出来时不可同日而语，也不再是一个没有实用价值的玩具了（最初的版本连 zsh 和 tmux 等最基本的工具都无法运行，基本没有可用性。但如果现在依然说 WSL 不可用，就有失偏颇了）。但对不想折腾的普通用户来说，用户体验并不好。比如中文显示有问题，不支持中文输入，只支持 16 种颜色，不能隐藏滚动条，不兼容某些命令的输出，不能定制主题和一些其他按键相关配置等。&lt;/p&gt;
&lt;p&gt;用过 Cygwin/MSYS2 的朋友都清楚有个名叫 &lt;a href="http://mintty.github.io/"&gt;mintty&lt;/a&gt; 的终端模拟器，体积小巧配置简单，功能也够用，如果能直接用 mintty 作为 WSL 的终端模拟器，用户体验就好很多了。&lt;a href="https://github.com/goreliu/wsl-terminal"&gt;wsl-terminal&lt;/a&gt; 让这成为可能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="https://raw.githubusercontent.com/wiki/goreliu/wsl-terminal/images/wsl-terminal.png"&gt;&lt;/p&gt;
&lt;p&gt;wsl-terminal 支持如下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优秀的兼容性（中文显示/输入、 24 位颜色、命令输出等都正常了）。&lt;/li&gt;
&lt;li&gt;体积小巧，压缩包仅 1.7 M 多，解压后不到 10 M 。&lt;/li&gt;
&lt;li&gt;配置简单， mintty 可以直接在标题栏右键配置， wsl-terminal 的配置文件也很简单。&lt;/li&gt;
&lt;li&gt;可以直接在资源管理器右键打开终端模拟器并定位到当前目录。&lt;/li&gt;
&lt;li&gt;可以将 .sh/.py/.pl 脚本关联到用 wsl-terminal 运行。&lt;/li&gt;
&lt;li&gt;可以将文本文件关联到用 wsl-terminal 里的 vim 运行。&lt;/li&gt;
&lt;li&gt;支持 tmux ，可以在 tmux 里打开新目录，恢复已有的 tmux 会话等。&lt;/li&gt;
&lt;li&gt;支持在 WSL 里直接运行 Windows 程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 https://github.com/goreliu/wsl-terminal/releases 下载 7z 格式的发布包。&lt;/li&gt;
&lt;li&gt;解压后，直接运行 open-wsl.exe 即可在当前目录打开（可以关联到快捷键）。&lt;/li&gt;
&lt;li&gt;可以运行 &lt;code&gt;tools/add-open-wsl-here-menu.js&lt;/code&gt; 在资源管理器右键菜单里添加一个 &lt;code&gt;Open WSL Here&lt;/code&gt; 菜单（&lt;code&gt;tools/remove-open-wsl-here-menu.js&lt;/code&gt; 删除菜单）。&lt;/li&gt;
&lt;li&gt;可以修改 .sh/.py/.pl/.php 等各种脚本的打开方式为 run-wsl-file.exe ，双击就可以打开。如果需要看结果的话，记得脚本最后加个 sleep 或者 read 。&lt;/li&gt;
&lt;li&gt;可以修改文本文件的打开方式为 vim.exe ，双击就可以用 WSL 里的 vim 打开编辑。&lt;/li&gt;
&lt;li&gt;如果想做 WSL 里边运行 Windows 的软件，运行 outbash-daemon.js ，然后把 bin 里的 wrun 、wstart 、wcmd 复制到 /usr/local/bin （可以直接运行 install_cbwin.sh ），然后 wstart notepad 就可以打开记事本了。cbwin 使用文档： https://github.com/xilun/cbwin&lt;/li&gt;
&lt;li&gt;如果需要使用 tmux，在编辑文件里启用 use_tmux 即可。&lt;/li&gt;
&lt;/ol&gt;</content></entry><entry><title>关于好玩、有用和技术含量之我见</title><link href="/guan-yu-hao-wan-you-yong-he-ji-zhu-han-liang-zhi-wo-jian.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/guan-yu-hao-wan-you-yong-he-ji-zhu-han-liang-zhi-wo-jian.html</id><summary type="html">&lt;p&gt;前几天闲来无事买来个树莓派玩。并不是想用来做什么，甚至没想到要怎么玩，更多是因为一种“情怀”吧，关于 Linux 的。我大概从 08 年开始用桌面 Linux，一直到 15 年换成 Windows（开始时用虚拟机装 Linux，后来改用 Cygwin/MSYS2，就很少用了。再后来 Win 10 有了 WSL，我把虚拟机也删了）。但对我来说，Windows 是用的而不是玩的，甚至 WSL 基本已经能满足所有关于 Linux 的实用性功能后，我还是感觉 WSL 是用的而不是玩的。那我为什么不用虚拟机来玩 Linux呢？理论上，虚拟机可以满足所有我折腾 Linux 的功能性需求，只是有一点，感觉不一样。面对运行在虚拟机里的 Linux …&lt;/p&gt;</summary><content type="html">&lt;p&gt;前几天闲来无事买来个树莓派玩。并不是想用来做什么，甚至没想到要怎么玩，更多是因为一种“情怀”吧，关于 Linux 的。我大概从 08 年开始用桌面 Linux，一直到 15 年换成 Windows（开始时用虚拟机装 Linux，后来改用 Cygwin/MSYS2，就很少用了。再后来 Win 10 有了 WSL，我把虚拟机也删了）。但对我来说，Windows 是用的而不是玩的，甚至 WSL 基本已经能满足所有关于 Linux 的实用性功能后，我还是感觉 WSL 是用的而不是玩的。那我为什么不用虚拟机来玩 Linux呢？理论上，虚拟机可以满足所有我折腾 Linux 的功能性需求，只是有一点，感觉不一样。面对运行在虚拟机里的 Linux，我完全没有玩的欲望，就好像它是阶下囚一样。我想在一个单独设备安装 Linux 来玩，即使什么都不做，只是时不时 ssh 上去更新一下软件包，或者看看日志。&lt;/p&gt;
&lt;p&gt;我本来以为买回来玩两天就会感觉没什么意思，然后就放着吃灰了，但实际情况要好一些。我没有把树莓派接到显示器，也没有安装图形界面软件，全部操作都在电脑、手机或者 iPad ssh 进行。然后我就想给树莓派加一块屏幕或者连接显示器有什么意义呢？如果我需要显示一些东西，或者通过图形界面来输入一些东西，我可以写一个网页，然后用浏览器访问。说干就干，我用来了将近两天的时间，寻找最容易的实现方法（我对前端的了解还停留在多年前的简单 Html 和 JavaScript 常识），最后经过各种查找、试验、比较后，确定使用 Python（主体语言） + Flask（后端） + Vue.js（前端逻辑） + Flask-SocketIO（前后端间 WebSocket 通信） + Bootstrap-vue（前端界面），验证了我想要的功能是可以很容易实现的，并且感慨现在对于对前端几乎零基础的开发人员来说，写一个简单的看起来还像是个网站的东西还是非常容易的，就是选型比较麻烦，需要各种权衡用什么框架或者库。&lt;/p&gt;
&lt;p&gt;但写完了 Demo 后，我的热情就褪去了大半，不错，技术上是能实现的，但我想做什么呢？我本来想先做一个简单的网页，在手机可以实时查看树莓派的运行状态，并且可以发送命令获取执行结果。但这有什么意义呢？直接 ssh 上去就可以了。获取传感器的数据，以及发送控制指令？我想了想，我的房间里实在没有什么需要用传感器获取的数据，获取些温度、湿度、气压、光照、气流、声音、照片、视频等等，有什么意义呢？盯着手机屏幕看或者自动发送到微博来自嗨？想控制些什么呢？小车、飞行器、机械手臂或者其他各种华而不实的玩具做什么呢？实用的东西多半早有成型并且成本低廉的产品了。并且那些玩具中多数没有什么技术含量，硬件基本买来连上（最多动一下电烙铁）就好，虽然看起来可能很唬人，软件的逻辑基本都比较简单，而且有很多现成的库或者算法，需要自己写的代码往往不多。而且其中很多东西都有很多人玩过了，轮子已经遍地都是了。&lt;/p&gt;
&lt;p&gt;我这几天经常去网上查还有什么关于树莓派的创意玩法，没有找到吸引我的东西。在我即将让树莓派吃灰时，我突然想到一个问题，如果我只是想好玩，为什么要考虑有没有用呢？为什么要考虑有没有技术含量呢？为什么要考虑有没有前人玩过呢？&lt;/p&gt;
&lt;p&gt;我想到小孩子玩一个像弹珠之类简单的东西都可以玩一下午，甚至一个暑假，它有用吗，有技术含量吗，没有前人玩过吗？但这些都不妨碍他玩得开心。而很多成年人，能接触到的东西要比小孩子多很多，但为什么找一个真正好玩的东西反而更难了？一个很大的原因就是很多成年人往往不是纯粹地找一个好玩的东西，而是又要好玩，又要好用，又要有技术含量并且没有过时，甚至还要没有其他人玩过的，那这样能找到的可能性就大大降低了。&lt;/p&gt;
&lt;p&gt;然后我就想到很多人经常玩甚至沉溺于各种电子游戏的人，之前我总是不能真正理性地看待这些人，但现在想，他们中很多人纯粹地找到了好玩的东西，不过多考虑其他因素，沉浸进去，并且得到了快乐，如果没有因此失去更多东西，不是很好的事情吗？为什么要用是不是有用、是不是有技术含量、是不是别人都玩过的角度来看呢？&lt;/p&gt;
&lt;p&gt;同样地，如果我不考虑是不是有用、是不是有技术含量、是不是之前已经有人做过了，单纯地以玩的心态来玩树莓派，是不是就更容易找到我喜欢的玩法呢？至少思路会远比之前广阔。&lt;/p&gt;
&lt;p&gt;或许我只是把树莓派接上电源放在桌子上，时不时 ssh 上去随便敲些命令，只要自己开心，又有什么问题呢？也许慢慢我就会发现 pstree 里的进程越来越多了，或者接口上连的东西越来越多了，甚至我的生活越来越离不开它了。&lt;/p&gt;</content></entry><entry><title>关于《红楼梦》的一些局限性的思考</title><link href="/guan-yu-hong-lou-meng-de-yi-xie-ju-xian-xing-de-si-kao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/guan-yu-hong-lou-meng-de-yi-xie-ju-xian-xing-de-si-kao.html</id><summary type="html">&lt;p&gt;最近突然又对《红楼梦》的一些内容感兴趣了。感触比较深的是对少男少女之间的生活琐事以及感情的生动描绘。这也让我回忆自己的童年，偶尔几次我也想写些东西，但想来想去发现记不得什么了。也许因为我天生对孤独的偏爱吧，整个童年就像被完全抹去了一样，虽然长大后反而感觉不出什么了。&lt;/p&gt;
&lt;p&gt;《红楼梦》是一部非凡的作品，也许我现在才开始感兴趣是幸运的。但没有完美的作品，《红楼梦》的言语中也透露出它必不可少的局限性（这里用“局限性”，而不用“缺点”或者“问题”，是因为毕竟它是一部文学作品，它有它的侧重点，这些局限性并不能称之为缺点或者问题），有些时候也是让人痛心的。因为我对《红楼梦》了解并不多，仅就我目前所知记录一些观点。&lt;/p&gt;
&lt;p&gt;如果用一个词来形容《红楼梦》的局限性，大概就是“极端”了。作者很叛逆，很颠覆，但这就往往避免不了矫枉过正了。&lt;/p&gt;
&lt;p&gt;儒家自有儒家的问题，作者理解得极为深刻，但如此贬低儒家抬高佛家和道家是有更严重的问题的。&lt;/p&gt;
&lt;p&gt;《红楼梦》中佛家的局限性在于严重夸大了宿命的影响，人这一生是为了偿还和弥补，在某种程度说的确有些道理，但不是如此绝对的。《红楼梦》中多数人物都被命运束缚，几乎没有一个人可以靠自己的努力过上自己想要的生活 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近突然又对《红楼梦》的一些内容感兴趣了。感触比较深的是对少男少女之间的生活琐事以及感情的生动描绘。这也让我回忆自己的童年，偶尔几次我也想写些东西，但想来想去发现记不得什么了。也许因为我天生对孤独的偏爱吧，整个童年就像被完全抹去了一样，虽然长大后反而感觉不出什么了。&lt;/p&gt;
&lt;p&gt;《红楼梦》是一部非凡的作品，也许我现在才开始感兴趣是幸运的。但没有完美的作品，《红楼梦》的言语中也透露出它必不可少的局限性（这里用“局限性”，而不用“缺点”或者“问题”，是因为毕竟它是一部文学作品，它有它的侧重点，这些局限性并不能称之为缺点或者问题），有些时候也是让人痛心的。因为我对《红楼梦》了解并不多，仅就我目前所知记录一些观点。&lt;/p&gt;
&lt;p&gt;如果用一个词来形容《红楼梦》的局限性，大概就是“极端”了。作者很叛逆，很颠覆，但这就往往避免不了矫枉过正了。&lt;/p&gt;
&lt;p&gt;儒家自有儒家的问题，作者理解得极为深刻，但如此贬低儒家抬高佛家和道家是有更严重的问题的。&lt;/p&gt;
&lt;p&gt;《红楼梦》中佛家的局限性在于严重夸大了宿命的影响，人这一生是为了偿还和弥补，在某种程度说的确有些道理，但不是如此绝对的。《红楼梦》中多数人物都被命运束缚，几乎没有一个人可以靠自己的努力过上自己想要的生活，多半是在命运的机缘巧合下大起大落，个人的努力在这命运的操控下是很乏力的。这是一种极为消极的观点，实际上，对多数人来说，命运中的大部分是掌握在自己的手中的，人在命运面前并没有这么的乏力，除非他真的屈服于命运。&lt;/p&gt;
&lt;p&gt;《红楼梦》中道家的局限性在于道家是不可操作的。这个更为严重，在作者看来，一个人看透人生的唯一方法似乎就是经受人世间所有的沧桑和苦难，最后境界到了，就可以了。但这是没办法实际操作的，因为这是一种矛盾。儒家的理论固然后很多问题，但一个人可以读四书五经，考取功名，实现自己的理想，尽管这条路有很多问题。但道家的理论看起来很好，但没有一条可以走的路。如果一个人已经到终点，然后回头才发现道家的理论是对的，那么这有什么意义呢？&lt;/p&gt;
&lt;p&gt;儒家的思想强调的是入世的生活，道家的思想强调的是出世的生活，二者的侧重点是完全不同的，二者不是互相取代的关系。但如果一个人没有入世过，如何能出世。&lt;/p&gt;
&lt;p&gt;除了儒家佛家道家的偏好，作者在其他很多观点也体现出类似的极端。比如对男女的尊卑上。&lt;/p&gt;</content></entry><entry><title>关于机器是否可能比人类更聪明的若干胡思乱想</title><link href="/guan-yu-ji-qi-shi-fou-ke-neng-bi-ren-lei-geng-cong-ming-de-ruo-gan-hu-si-luan-xiang.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/guan-yu-ji-qi-shi-fou-ke-neng-bi-ren-lei-geng-cong-ming-de-ruo-gan-hu-si-luan-xiang.html</id><summary type="html">&lt;p&gt;因为之前对人工智能相关问题有些兴趣，写了两篇文章：
&lt;a href="http://www.jianshu.com/p/8b0fd3ca1caa"&gt;关于人工智能的一点想法&lt;/a&gt;
&lt;a href="http://www.jianshu.com/p/e8ee02a29674"&gt;最可怕的并不是强人工智能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在写第一篇文章时，我对人工智能总体上是比较乐观的，而写第二篇文章时，因为想到了一些之前没考虑到的问题，变得比较悲观。但当时我一直在想这样一个问题，机器是否可能比人类更聪明？因为没想清楚，我绕过这个问题，文章写得也比较混乱。&lt;/p&gt;
&lt;p&gt;这几天又想了下这个问题，有了一些新进展。&lt;/p&gt;
&lt;p&gt;当一个人和一台机器同时解决一个问题时，如果机器能在很短时间解决，而人在可接受的时间内都解决不了，那是否就解决这个问题而言，机器比人聪明呢？我们知道就现在的电脑而言，在解决很多数学问题上就是这样的，比如解偏微分方程，或者只是大整数的因式分解。但我们恐怕不会因此认为电脑比人聪明，更不会因此就害怕电脑。&lt;/p&gt;
&lt;p&gt;当有人说他担心将来的有一天机器比人聪明时，他想表达什么呢？有些人害怕和自己聪明的人共处，因为害怕被算计。那是不是也是害怕被机器算计，但这前提是机器想算计人。但就弱人工智能而言，机器的目的和行为是人决定的，所以这是不可能的。就弱人工智能而言，不存在机器和人谁更聪明的问题。就这个问题，我之前犯了想当然的错误。其实想到这里，弱人工智能问题就完全没有神秘面纱了。&lt;/p&gt;
&lt;p&gt;那么是否意味着发展弱人工智能就没有什么风险了呢？我想也不能这么说。&lt;/p&gt;
&lt;p&gt;我们知道和人类自身相比，现在的机器在某些事情上是非常擅长的，而在其他事情上并不擅长甚至完全无能为力。也许将来有一天，看起来机器在各个方面都完全超越了人类，但即使这似乎并没有强人工智能实现出来那样遥远无期 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;因为之前对人工智能相关问题有些兴趣，写了两篇文章：
&lt;a href="http://www.jianshu.com/p/8b0fd3ca1caa"&gt;关于人工智能的一点想法&lt;/a&gt;
&lt;a href="http://www.jianshu.com/p/e8ee02a29674"&gt;最可怕的并不是强人工智能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在写第一篇文章时，我对人工智能总体上是比较乐观的，而写第二篇文章时，因为想到了一些之前没考虑到的问题，变得比较悲观。但当时我一直在想这样一个问题，机器是否可能比人类更聪明？因为没想清楚，我绕过这个问题，文章写得也比较混乱。&lt;/p&gt;
&lt;p&gt;这几天又想了下这个问题，有了一些新进展。&lt;/p&gt;
&lt;p&gt;当一个人和一台机器同时解决一个问题时，如果机器能在很短时间解决，而人在可接受的时间内都解决不了，那是否就解决这个问题而言，机器比人聪明呢？我们知道就现在的电脑而言，在解决很多数学问题上就是这样的，比如解偏微分方程，或者只是大整数的因式分解。但我们恐怕不会因此认为电脑比人聪明，更不会因此就害怕电脑。&lt;/p&gt;
&lt;p&gt;当有人说他担心将来的有一天机器比人聪明时，他想表达什么呢？有些人害怕和自己聪明的人共处，因为害怕被算计。那是不是也是害怕被机器算计，但这前提是机器想算计人。但就弱人工智能而言，机器的目的和行为是人决定的，所以这是不可能的。就弱人工智能而言，不存在机器和人谁更聪明的问题。就这个问题，我之前犯了想当然的错误。其实想到这里，弱人工智能问题就完全没有神秘面纱了。&lt;/p&gt;
&lt;p&gt;那么是否意味着发展弱人工智能就没有什么风险了呢？我想也不能这么说。&lt;/p&gt;
&lt;p&gt;我们知道和人类自身相比，现在的机器在某些事情上是非常擅长的，而在其他事情上并不擅长甚至完全无能为力。也许将来有一天，看起来机器在各个方面都完全超越了人类，但即使这似乎并没有强人工智能实现出来那样遥远无期，但至少在可预期的未来是没有希望的。而在这期间的较长时间，机器一直是“偏科”的。&lt;/p&gt;
&lt;p&gt;或者我们可以换一个角度来看这个问题。每当机器在做一件事或者在解决某一个领域问题的能力超过人类自身时，人类（以机器作为工具）的这方面能力就得到了一个很大的提升。但这样的发展并不均衡，也许在某些方面飞速发展，而在其他方面原地踏步。而这是否会导致人类在处理一些重大的事情上更容易失误呢？&lt;/p&gt;
&lt;p&gt;这个问题我还没有想清楚。（待续）&lt;/p&gt;</content></entry><entry><title>关于人工智能的一点想法</title><link href="/guan-yu-ren-gong-zhi-neng-de-yi-dian-xiang-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/guan-yu-ren-gong-zhi-neng-de-yi-dian-xiang-fa.html</id><summary type="html">&lt;p&gt;关于人工智能，讨论最多的问题大概有如下几个：
1、机器会不会让多数人失业？
2、机器会不会取代人类（造成人类毁灭）？
3、机器会不会有自我意识？&lt;/p&gt;
&lt;p&gt;这些问题比较有意思，观点也众说纷纭。&lt;/p&gt;
&lt;p&gt;简单说下自己的想法。&lt;/p&gt;
&lt;h2&gt;机器会不会让多数人失业？&lt;/h2&gt;
&lt;p&gt;关于这个问题，有两个主流观点：&lt;/p&gt;
&lt;p&gt;1、机器会取代一部分人的工作，同时提供更多工作岗位。
2、机器最终会让多数人失业。&lt;/p&gt;
&lt;p&gt;我想仔细考虑过这个问题的人，会倾向于第一种观点。因为我们可以用现有的电脑做类比，现在的电脑做了一些以前需要人工完成的工作，但围绕着电脑，很多新的工作岗位产生了。&lt;/p&gt;
&lt;p&gt;但并不是所有的第二种观点持有者没有考虑过这个类比，因为二者不大一样。现在的电脑之所以还需要人类辅助来完成工作，是因为它们还不够智能，是否有一天它们足够智能后，就完全不需要人类干预就可以完成各种工作了呢？&lt;/p&gt;
&lt;p&gt;这个问题并不是那么简单，我们可能需要从更深的角度来考虑。比如“工作”是什么？我们为什么需要工作？&lt;/p&gt;
&lt;p&gt;简单说来，会有两方面原因。一方面是工作是为了生存，如果不工作，可能就没有了经济来源，衣食住行都成了问题，也就无法生存。另一方面，工作是自我实现的一种方式，做喜欢的工作是一种享受。&lt;/p&gt;
&lt;p&gt;那么我们假设这样一种场景，将来的某一天 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;关于人工智能，讨论最多的问题大概有如下几个：
1、机器会不会让多数人失业？
2、机器会不会取代人类（造成人类毁灭）？
3、机器会不会有自我意识？&lt;/p&gt;
&lt;p&gt;这些问题比较有意思，观点也众说纷纭。&lt;/p&gt;
&lt;p&gt;简单说下自己的想法。&lt;/p&gt;
&lt;h2&gt;机器会不会让多数人失业？&lt;/h2&gt;
&lt;p&gt;关于这个问题，有两个主流观点：&lt;/p&gt;
&lt;p&gt;1、机器会取代一部分人的工作，同时提供更多工作岗位。
2、机器最终会让多数人失业。&lt;/p&gt;
&lt;p&gt;我想仔细考虑过这个问题的人，会倾向于第一种观点。因为我们可以用现有的电脑做类比，现在的电脑做了一些以前需要人工完成的工作，但围绕着电脑，很多新的工作岗位产生了。&lt;/p&gt;
&lt;p&gt;但并不是所有的第二种观点持有者没有考虑过这个类比，因为二者不大一样。现在的电脑之所以还需要人类辅助来完成工作，是因为它们还不够智能，是否有一天它们足够智能后，就完全不需要人类干预就可以完成各种工作了呢？&lt;/p&gt;
&lt;p&gt;这个问题并不是那么简单，我们可能需要从更深的角度来考虑。比如“工作”是什么？我们为什么需要工作？&lt;/p&gt;
&lt;p&gt;简单说来，会有两方面原因。一方面是工作是为了生存，如果不工作，可能就没有了经济来源，衣食住行都成了问题，也就无法生存。另一方面，工作是自我实现的一种方式，做喜欢的工作是一种享受。&lt;/p&gt;
&lt;p&gt;那么我们假设这样一种场景，将来的某一天，机器可以完成现在所有（或者大多数）现在需要人工完成的工作，人（或者多数人）还需要工作吗？如果是出于工作是为了生存考虑，人就不需要工作了，我们只需要让机器正常运行下去就可以了。但如果出于工作为了自我实现考虑，人还是可以工作的，但如果完全不考虑经济因素，工作的含义也发生了变化。如果我画画不是为了卖钱，而是为了享受过程，或者喜欢大家赞赏的感觉，那么为什么说画画是一种工作，而旅游不是一种工作呢？所以理想情况下，当机器取代人类完成工作后，人类就可以做任何自己想做的事情，而这事情是否是工作都无关紧要了，更不会有失业的问题。&lt;/p&gt;
&lt;p&gt;当然以上场景还有另一种情况，恐怕也是很多人担心的情况。就是如果机器只为少数人服务怎么办？比如这世界的机器只属于少数人，那么它们的工作成果凭什么要分享给这世界所有人，如果这些机器的所有者不愿意这么做，会不会出现多数人找不到工作，又没有经济来源，冻饿而死的情况？&lt;/p&gt;
&lt;p&gt;其实这是有可能的。当少数极端的人掌控的所有机器后，的确可能出现这种结果。但要注意机器能完成人类的工作，不意味这人类就不能工作了。享受不到机器好处的多数人，还是可以无视机器的存在，继续按之前的方式生活（但这也并不是一种平衡的状态，终会发生冲突），除非他们失去了自由。也就是说，“多数人找不到工作，又没有经济来源，冻饿而死的情况”，和少数人掌握了一种秘密的武器，杀死了所有的其他人，是一样的含义。这问题就不在于“机器”或者“人工智能”了，而在于人类本身。人类将如何发展，会不会自取灭亡？&lt;/p&gt;
&lt;p&gt;到这里，这个问题的最终答案变成了如下两个：
1、机器最终会取代所有人（或者绝大多数人）的工作，但因此人们（或者绝大多数人）可以做任何自己想做的事情。
2、人类（或者人类中的大多数）毁灭。&lt;/p&gt;
&lt;p&gt;也就是说，担心机器会不会让多数人失业，和担心人类是否会使用机器将自己毁灭是一回事，当然这并非不可能发生。&lt;/p&gt;
&lt;h1&gt;机器会不会取代人类（造成人类毁灭）？&lt;/h1&gt;
&lt;p&gt;现在我们已经发现这个问题和“机器会不会让多数人失业？”是同一个问题了，结果取决于人类，而不是机器，不再赘述。&lt;/p&gt;
&lt;h1&gt;机器会不会有自我意识？&lt;/h1&gt;
&lt;p&gt;之前的论点都是建立在机器没有自我意识的前提下的。如果机器有了自我意识，之前的问题结果是否会有所不同？&lt;/p&gt;
&lt;p&gt;“机器会不会有自我意识？”这个问题比较复杂，因为它不是科学问题，而是一个哲学问题。而哲学本体论至今没有大一统的理论，没有理论根基，问题无从谈起。就我个人观点，以现有的方式制造的机器，是不会有自我意识的。但不排除人类以后会制造出有自我意识的机器，但这时制造出的东西已经不是通常意义的机器，而是一种生命。&lt;/p&gt;
&lt;p&gt;那么我们假设以后人类会制造出有自我意识的机器，或者说制造出类似机器的生命，看会发生什么。&lt;/p&gt;
&lt;p&gt;其实这是一个不同的生物如何相处的问题。我们可以想象一下，突然某天一种奇怪的生物从天而降，被人类捉到。人们研究之后发现这种生物有一些特点，可以完成任何人类让他做的事情，可以分裂繁殖，拥有智能。那么问题就在于人类和这种生物如何相处。这不仅取决于人类如何想和如何做，也和这种生物自身脱离不了关系。事实上，地球上从来不是只有人类一种生物，我们也一直做着和其他生物相处的事情，甚至不同的种族、国家的人似乎也并不总是将对方看成同一种生物，这个问题也并不新奇。&lt;/p&gt;
&lt;p&gt;关于人工智能的问题，终究还是人类自身的问题，要生存，还是毁灭，终究取决于自身。&lt;/p&gt;</content></entry><entry><title>关于人生的若干重大问题的简短解答或绕过方法</title><link href="/guan-yu-ren-sheng-de-ruo-gan-zhong-da-wen-ti-de-jian-duan-jie-da-huo-rao-guo-fang-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/guan-yu-ren-sheng-de-ruo-gan-zhong-da-wen-ti-de-jian-duan-jie-da-huo-rao-guo-fang-fa.html</id><summary type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;我犹豫了几天要不要写这篇文章。
我知道这篇文章有可能帮助不了任何人，相反很可能让其他人感觉我很傲慢或者很无知。
但我写这篇文章的主要目的并不是为了帮助别人，而是留给这个世界的一个礼物。
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;“我”是什么？&lt;/h2&gt;
&lt;p&gt;将这样的一个最难解决的终极问题放到最开始并不是一个明智的决定。但一个人如果对这个问题没有任何疑问了，其他问题自然也就不在话下了。所有对于一些人来说，这是唯一的问题，放在最开始是非常有必要的。热衷于内在世界的人，可能最先感兴趣的问题便是这个。&lt;/p&gt;
&lt;p&gt;这个问题的麻烦之处首先在于问题本身有些含糊不清。实际上这是两个问题：“我”指代着什么对象？这个被指代的对象是什么？&lt;/p&gt;
&lt;p&gt;原因是“我”只是一个代词，单纯地问这个代词是什么意思，是没有意义的，就像我问“它是什么”一样。实际上，“我”具体指什么，并没有一个统一的观点，每个人的知识背景不同，信仰不同，“我”指代的东西也不同。这会导致思考这个问题的人感觉很不舒服，就像被一团乱麻绕住无从下手。&lt;/p&gt;
&lt;p&gt;解决的办法是绕过这个问题。其实“我”是一个相当不恰当的词语，它能解决的问题远比它所带来的问题多，我们可以简单用代词“这”来取代“我”，用“这里的”来取代 …&lt;/p&gt;</summary><content type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;我犹豫了几天要不要写这篇文章。
我知道这篇文章有可能帮助不了任何人，相反很可能让其他人感觉我很傲慢或者很无知。
但我写这篇文章的主要目的并不是为了帮助别人，而是留给这个世界的一个礼物。
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;“我”是什么？&lt;/h2&gt;
&lt;p&gt;将这样的一个最难解决的终极问题放到最开始并不是一个明智的决定。但一个人如果对这个问题没有任何疑问了，其他问题自然也就不在话下了。所有对于一些人来说，这是唯一的问题，放在最开始是非常有必要的。热衷于内在世界的人，可能最先感兴趣的问题便是这个。&lt;/p&gt;
&lt;p&gt;这个问题的麻烦之处首先在于问题本身有些含糊不清。实际上这是两个问题：“我”指代着什么对象？这个被指代的对象是什么？&lt;/p&gt;
&lt;p&gt;原因是“我”只是一个代词，单纯地问这个代词是什么意思，是没有意义的，就像我问“它是什么”一样。实际上，“我”具体指什么，并没有一个统一的观点，每个人的知识背景不同，信仰不同，“我”指代的东西也不同。这会导致思考这个问题的人感觉很不舒服，就像被一团乱麻绕住无从下手。&lt;/p&gt;
&lt;p&gt;解决的办法是绕过这个问题。其实“我”是一个相当不恰当的词语，它能解决的问题远比它所带来的问题多，我们可以简单用代词“这”来取代“我”，用“这里的”来取代“我的”。可能有人认为这是简单的逃避问题，但实际上这里所“逃避”的问题后文会提到。&lt;/p&gt;
&lt;p&gt;我们要回到问这个问题的初衷。当一个人有了自我感后，就会产生疑问，这个疑问可能涉及到“自己”、“我”等似是而非的概念，但实际这这个问题的核心不在概念上，而在事情上，他真正疑惑的是发生了什么事情。现在我们就把一个含糊不清的问题转化成了一个非常具体的问题了：人的一生是什么回事？&lt;/p&gt;
&lt;p&gt;这是思考问题的一个技巧，很多哲学问题难于思考的原因，在于问题本身是含糊不清的，包含着一些似是而非的概念，而每个人对其中概念的理解都不甚相同。&lt;/p&gt;
&lt;p&gt;一个人从出生，到死去，究竟发生了怎样的事情，一个人为什么会感觉到自己在做事情，自己和其他人有什么区别和联系？&lt;/p&gt;
&lt;p&gt;这个问题的难点，在于视野。俗话说眼见为实，但每一个活着的人，都没有办法真正看到自己出生前或者死亡后的场景，这就导致这个问题的解答上，充斥着各种科学、宗教或者神秘主义的内容，让人难以分辨是非。这也意味着不同知识背景的人，对这个问题的解答可能是完全不同的。我可以很清楚地说明我对这个问题的理解，但是我无法提供能让人信服的证据，所有我不认为提供这样一个回答有很大的意义。那么这个难题要如何处理？&lt;/p&gt;
&lt;p&gt;其实很多时候，一个人想一个问题，并不是为了找到正确的答案，而是找到自己可以接受的答案。我们可以看到有些人对于很多重要问题的回答是非常不合理的，但他们并没有感觉不妥，因为他们仅仅是接受了这个答案，或者说他们对正确的答案是什么并没有什么兴趣，只是随便找一个看起来还不错的答案占位，然后就去做自己更感兴趣的事情了。但一部分人更喜欢质疑，他们发现很多现有答案存在缺陷，难于接受，于是去找自己能接受的答案。这道路上漫长而又艰辛的，他们不会轻易接受某一个答案，而是会反复思考，但这并不意味这他们不需要别人的帮助。&lt;/p&gt;
&lt;p&gt;我这里提供的建议是，远离经典的西方哲学著作。虽然这些著作中看起来似乎包含着十分有用的信息，实际情况也是这样。但要获取这些信息的代价非常高昂，打个不恰当的比方，垃圾堆里固然有值钱的东西，但为了值钱的东西去翻垃圾堆是非常不明智的选择。喜欢思考的人可以看经典哲学著作来锻炼思维，但对真正想寻找答案的人来说，远离才是更好的选择。如何识别这类著作呢？简单说，如果一段话，反复看了几遍都看不明白，就不要看了。因为只有两个原因：作者自己没明白，或者相关内容是无法用文字描述明白的。无论是前者还是后者，反复琢磨一段看不明白的文字都是效率极低的事情。&lt;/p&gt;
&lt;p&gt;那么可以看什么书？简单说，就是看能看明白的书。然后在看的过程中，靠自己的质疑能力来判断是否接受，而不是依靠权威。这个过程也是建立自己知识体系的过程，只能靠大量地收集和整理资料。不要指望仅仅看一本完全正确的真理之书就大功告成，即使真的有这样的书，看完了后也还会被其他的内容迷惑。&lt;/p&gt;
&lt;p&gt;最后我们再回到这个问题，人的一生是什么回事？&lt;/p&gt;
&lt;p&gt;即使收集了所有可能搜集到的资料，也不能找全这个问题的答案。原因在于这并不仅仅是一个理论上的问题，而是体验上的问题。我可以很轻松地回答，人这一生就是去一个地方做一些自己计划要做的事情，做完了便可以离开了。但这真的解决你的疑问了吗？&lt;/p&gt;
&lt;p&gt;人的一生是什么回事，这个问题需要用一生的时间来回答。直到有一天，明白了自己的一生是什么回事，也就回答了这个问题了。&lt;/p&gt;
&lt;h2&gt;这个世界是怎样的？&lt;/h2&gt;
&lt;p&gt;对外在世界感兴趣的人，可能对这个问题更感兴趣。但实际上，这个问题和第一个问题在很多地方是想通的，解决方法也很类似。&lt;/p&gt;
&lt;p&gt;如果一定需要一个答案，这个世界是许许多多生命按照他们的意愿所制造出来的。如果你想问这个世界是怎样起源的以及归宿是什么的话，要注意时间和空间也是这个世界的一部分。因为人的思维模式严重依赖时间的概念，要想真正理解这个问题的答案是不可能的。如果你对这个问题好奇，就需要付出对应的代价，但不要有太多挫败感。&lt;/p&gt;
&lt;h2&gt;人生的目的是什么？&lt;/h2&gt;
&lt;h2&gt;死后会发生什么样的事情？&lt;/h2&gt;
&lt;h2&gt;时间和空间是什么？&lt;/h2&gt;
&lt;h2&gt;生命是什么？&lt;/h2&gt;
&lt;h2&gt;这个世界公平吗？&lt;/h2&gt;
&lt;h2&gt;一直想不到自己该做什么怎么办？&lt;/h2&gt;</content></entry><entry><title>关于塞斯书，我想有必要写些什么</title><link href="/guan-yu-sai-si-shu-wo-xiang-you-bi-yao-xie-xie-shi-yao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/guan-yu-sai-si-shu-wo-xiang-you-bi-yao-xie-xie-shi-yao.html</id><summary type="html">&lt;p&gt;这几天我在用很多时间看一本，或者说一系列书，赛斯书。我没想到还有书能这样吸引我。&lt;/p&gt;
&lt;p&gt;我想也许因为我太晚看它了，以至于它对我来说显得不那么重要了。但我明明知道我去年就曾经看过，但因为受不了它的风格，仅看了几页就放弃了。同样的，我也还记得早在大二时我就看过《与神对话》，当时确认这是一本值得读的好书，却没有细读。直到将近五年后我才真正仔细读它，从而让它成为对我最重要的书。&lt;/p&gt;
&lt;p&gt;这几年我使用了难以估量的精力想一个又一个问题。“我”是什么？人到底有没有自由意志？人生的目的和意义是什么？时间和空间是什么？轮回转世是什么回事？已经由此衍生出来的数不尽的问题。我想过和其他人讨论，直到发现在很多人眼里，这些问题或无关紧要或答案显而易见，以至于还不如晚饭吃什么更值得思考。于是我靠一己之力，翻了数不尽的错综复杂并互相矛盾的资料。设想了一个个模型，又推翻了一个个。&lt;/p&gt;
&lt;p&gt;直到其中的大部分的答案已经确定，唯有两个特别棘手。一个是时间的本质是什么。在我确定我们可以像改变未来一样改变过去之后，我发现再难以深入思考时间自身以及和此相关的少数问题。另一个则与轮回转世有关，显然它也和时间有密切联系。它之所以重要，是因为我需要在更高的角度看人生的目的。而想轮回转世自身的问题，则需要站在更高的角度。虽然我看了很多有价值的资料，但都没有提供我想要的高度，从而我只得到了部分答案。&lt;/p&gt;
&lt;p&gt;在我想暂且搁置剩余的问题后，我发现了赛斯书提供了答案。或者说，它几乎提供了我所想的几乎所有答案 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;这几天我在用很多时间看一本，或者说一系列书，赛斯书。我没想到还有书能这样吸引我。&lt;/p&gt;
&lt;p&gt;我想也许因为我太晚看它了，以至于它对我来说显得不那么重要了。但我明明知道我去年就曾经看过，但因为受不了它的风格，仅看了几页就放弃了。同样的，我也还记得早在大二时我就看过《与神对话》，当时确认这是一本值得读的好书，却没有细读。直到将近五年后我才真正仔细读它，从而让它成为对我最重要的书。&lt;/p&gt;
&lt;p&gt;这几年我使用了难以估量的精力想一个又一个问题。“我”是什么？人到底有没有自由意志？人生的目的和意义是什么？时间和空间是什么？轮回转世是什么回事？已经由此衍生出来的数不尽的问题。我想过和其他人讨论，直到发现在很多人眼里，这些问题或无关紧要或答案显而易见，以至于还不如晚饭吃什么更值得思考。于是我靠一己之力，翻了数不尽的错综复杂并互相矛盾的资料。设想了一个个模型，又推翻了一个个。&lt;/p&gt;
&lt;p&gt;直到其中的大部分的答案已经确定，唯有两个特别棘手。一个是时间的本质是什么。在我确定我们可以像改变未来一样改变过去之后，我发现再难以深入思考时间自身以及和此相关的少数问题。另一个则与轮回转世有关，显然它也和时间有密切联系。它之所以重要，是因为我需要在更高的角度看人生的目的。而想轮回转世自身的问题，则需要站在更高的角度。虽然我看了很多有价值的资料，但都没有提供我想要的高度，从而我只得到了部分答案。&lt;/p&gt;
&lt;p&gt;在我想暂且搁置剩余的问题后，我发现了赛斯书提供了答案。或者说，它几乎提供了我所想的几乎所有答案。但同样的，因为某些固有局限性，我还是难以直观地理解时间的本质，问题并没有得到真正彻底的解决。而实际上，我也没有再仔细想，因为对这些问题我也不是那么感兴趣了。&lt;/p&gt;
&lt;p&gt;但我还是认为，对于喜欢思考的人，赛斯书是一份不可多得的资料。在此之前，我甚至没找到任何一个可以解释多数问题，并且不自相矛盾的理论，在不考虑对错的前提下。很多人并非真的想找到那些问题的正确答案，而仅仅是一个可以自圆其说的答案，来平复自己的疑惑，然而同样困难。&lt;/p&gt;
&lt;p&gt;我对赛斯书的感触最多的不是知识上的，而是那种纯粹的爱，作为真正负责任的教师对全人类的爱，在多数人已经忘记了爱是什么的时候。&lt;/p&gt;</content></entry><entry><title>和轮回转世相关问题的深入探讨</title><link href="/he-lun-hui-zhuan-shi-xiang-guan-wen-ti-de-shen-ru-tan-tao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/he-lun-hui-zhuan-shi-xiang-guan-wen-ti-de-shen-ru-tan-tao.html</id><summary type="html">&lt;p&gt;当一个人想清楚今生今世的人生目的了后，就难免不会以更大的格局看这个问题，比如这一生结束后会怎样。基本上就会涉及轮回转世相关问题。当然有些人会认为人死了就烟消云散了什么都没了，或者会上天堂，入地狱，进入涅槃状态，进入某个神佛的怀抱等等，而不会有任何轮回转世的事情发生，那就可以一笑了之了。&lt;/p&gt;
&lt;p&gt;想这个问题的初衷是想知道我所想的人生目的是否和自己当初来的时候所计划的一致，如果不一致，恐怕为了相同的目的又要来折腾一番。当然如果今生是幸福的，再来一次也无妨，所以这个问题倒也不是一定要思考的。另外也会想自己的来生会是怎样呢，在今生是否可以做些事情来为来生铺路，甚至在今生是否可以一鼓作气离开轮回等等。那么轮回转世的问题就不可避免了。&lt;/p&gt;
&lt;p&gt;轮回相关问题赛斯书中篇幅较多，情况也远比我从其他地方听来的要复杂和符合逻辑，值得探讨。虽然我现在还不认为自己理解对了或者全面了。&lt;/p&gt;
&lt;p&gt;首先先简单看下“我”所处的层级。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="/images/001.png"&gt;&lt;/p&gt;
&lt;p&gt;图中的自我是我们现在认为的我，多个自我属于一个全我，但一个全我比它里边的每个自我总和还大。全我的上边是存有，全我和存有的关系和自我和全我的关系相似，存有上边还有存有。这个层级的高度可以认为是有限的，但当自我成长长了全我，最上层的存有也会又长高的一层，所有对于每个人来说，可以认为高度是无限的。&lt;/p&gt;
&lt;p&gt;每个全我里的各个自我，就是轮回中的各个身份。轮回是以自我为单位进行的，也就是说虽然我在不停地轮回，但期间我并不能清晰看到其他在轮回的身份（虽然我可以通过和全我的其他部分交互获取到部分资料）。当轮回结束时，我已经从自我变成了全我，这样就可以很透彻地看到每个轮回中自我了。但这一点有些复杂稍后再回来看。这里有个片段体的问题我还没有还好地理解 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;当一个人想清楚今生今世的人生目的了后，就难免不会以更大的格局看这个问题，比如这一生结束后会怎样。基本上就会涉及轮回转世相关问题。当然有些人会认为人死了就烟消云散了什么都没了，或者会上天堂，入地狱，进入涅槃状态，进入某个神佛的怀抱等等，而不会有任何轮回转世的事情发生，那就可以一笑了之了。&lt;/p&gt;
&lt;p&gt;想这个问题的初衷是想知道我所想的人生目的是否和自己当初来的时候所计划的一致，如果不一致，恐怕为了相同的目的又要来折腾一番。当然如果今生是幸福的，再来一次也无妨，所以这个问题倒也不是一定要思考的。另外也会想自己的来生会是怎样呢，在今生是否可以做些事情来为来生铺路，甚至在今生是否可以一鼓作气离开轮回等等。那么轮回转世的问题就不可避免了。&lt;/p&gt;
&lt;p&gt;轮回相关问题赛斯书中篇幅较多，情况也远比我从其他地方听来的要复杂和符合逻辑，值得探讨。虽然我现在还不认为自己理解对了或者全面了。&lt;/p&gt;
&lt;p&gt;首先先简单看下“我”所处的层级。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图片" src="/images/001.png"&gt;&lt;/p&gt;
&lt;p&gt;图中的自我是我们现在认为的我，多个自我属于一个全我，但一个全我比它里边的每个自我总和还大。全我的上边是存有，全我和存有的关系和自我和全我的关系相似，存有上边还有存有。这个层级的高度可以认为是有限的，但当自我成长长了全我，最上层的存有也会又长高的一层，所有对于每个人来说，可以认为高度是无限的。&lt;/p&gt;
&lt;p&gt;每个全我里的各个自我，就是轮回中的各个身份。轮回是以自我为单位进行的，也就是说虽然我在不停地轮回，但期间我并不能清晰看到其他在轮回的身份（虽然我可以通过和全我的其他部分交互获取到部分资料）。当轮回结束时，我已经从自我变成了全我，这样就可以很透彻地看到每个轮回中自我了。但这一点有些复杂稍后再回来看。这里有个片段体的问题我还没有还好地理解，先搁置。&lt;/p&gt;
&lt;p&gt;我们先用线性的模型看轮回：&lt;/p&gt;
&lt;p&gt;人生1 - 决定 - 人生2 - 决定 - 人生3 - 决定&lt;/p&gt;
&lt;p&gt;比如我这一生是在人生2，我有一个人生1的前生，将有一个人生3的来生。当此生结束后，我会用更大的视野来回顾这一生，然后做自己该何去何从的决定。&lt;/p&gt;
&lt;p&gt;一般来说有三种选择：
1. 继续轮回
2. 使用另一种方式来组织刚刚结束这一生
3. 脱离轮回转世系统&lt;/p&gt;
&lt;p&gt;第一种选择是通常的情况。第二种选择一般是我在回顾这一生时发现自己犯了重大“错误”，很后悔，甚至不能接受。于是想办法做些补救之类，在人生的关键节点上重新做选择等，来重演这一生。第三种是发现自己在轮回已经得到了足够的东西，自我演进成全我，忆起所有的轮回，从而不再轮回。但面临更多的选择，比选择来生复杂很多。&lt;/p&gt;
&lt;p&gt;但实际上这些轮回并不是顺序进行的，就像过去现在未来同时发生一样，这些轮回也是同时发生的。为了方便理解，我们可以认为“人生1 - 决定 - 人生2 - 决定 - 人生3 - 决定”就是一个人一生中的过去-现在-未来，所有是同时发生的。也是是虽然现在看来我的人生3还没有开始，但我已经可以像创造未来一样创造这一生了。人生1、人生2、人生3都在不停地变化中，像过去、现在、未来都在不停变化一样。就像有些书中提到的，一个人在催眠过程中可以“忆起”自己的来生，比如在几百年之后，而且还可以通过选择来改变自己的来生。&lt;/p&gt;
&lt;p&gt;这里有个比较麻烦的问题，是一个全我里的各个自我是怎样的关系。这个可以粗略地认为各个自我中每一个都认为自己是一个独立的部分，但自我之间可以通过全我来进行交互。自我就像全我的一个焦点，全我将每个焦点都集中在一次人生上，这样也比单纯的线性发展快很多。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中标签和函数的用法</title><link href="/ji-chu-ahk-zhong-biao-qian-he-han-shu-de-yong-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-biao-qian-he-han-shu-de-yong-fa.html</id><summary type="html">&lt;p&gt;AHK 中有两种比较像的东西，标签和函数。&lt;/p&gt;
&lt;h2&gt;标签&lt;/h2&gt;
&lt;p&gt;标签比较简单，用来标记一段代码的位置，以 return 结束。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Gosub, Test
Goto, Test
; 不再执行
MsgBox, End

Test:
    MsgBox, Test
return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Test 就是一个标签。标签可以用 Gosub 调用，Gosub 执行完后会继续执行下一行。也可以用 Goto 调用，但 Goto 调用完就不会回来了。&lt;/p&gt;
&lt;p&gt;除了使用 Gosub 或者 Goto 调用，标签还可以作为其他命令的参数，比如 Hotkey、SetTimer 等等。&lt;/p&gt;
&lt;p&gt;标签里的代码默认是执行的。比如这样一个 AHK 文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MsgBox, Begin

Test …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;AHK 中有两种比较像的东西，标签和函数。&lt;/p&gt;
&lt;h2&gt;标签&lt;/h2&gt;
&lt;p&gt;标签比较简单，用来标记一段代码的位置，以 return 结束。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Gosub, Test
Goto, Test
; 不再执行
MsgBox, End

Test:
    MsgBox, Test
return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Test 就是一个标签。标签可以用 Gosub 调用，Gosub 执行完后会继续执行下一行。也可以用 Goto 调用，但 Goto 调用完就不会回来了。&lt;/p&gt;
&lt;p&gt;除了使用 Gosub 或者 Goto 调用，标签还可以作为其他命令的参数，比如 Hotkey、SetTimer 等等。&lt;/p&gt;
&lt;p&gt;标签里的代码默认是执行的。比如这样一个 AHK 文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MsgBox, Begin

Test:
    MsgBox, Test
return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;即使没有主动调用 Test 标签，Test 标签里的内容还是会被执行。&lt;/p&gt;
&lt;p&gt;可以使用动态的标签名来调用标签。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;labelName := &amp;quot;Test&amp;quot;

; IsLabel 函数用来判断标签是否存在
if (IsLabel(labelName))
{
    Gosub, %labelName%
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;函数&lt;/h2&gt;
&lt;p&gt;函数也可以实现标签的功能，但更强大和灵活。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test1()
Test2(&amp;quot;test&amp;quot;)

Test1()
{
    MsgBox, Test1
}

; 函数支持参数和返回值
Test2(text)
{
    MsgBox, % text
    return true
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数的调用方式是函数名加小括号，如果需要传递参数，在括号里添加参数。和标签不一样，函数里的代码默认是不执行的。&lt;/p&gt;
&lt;p&gt;可以使用动态的标签名来调用函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;functionName&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Test&amp;quot;&lt;/span&gt;

&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;IsFunc&lt;/span&gt; &lt;span class="err"&gt;函数用来判断函数是否存在&lt;/span&gt;
&lt;span class="nf"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsFunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;functionName&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;%function&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数里可以调用标签，标签里也可以调用函数。标签和函数可以重名。&lt;/p&gt;
&lt;h2&gt;函数里的标签&lt;/h2&gt;
&lt;p&gt;在函数里可以再定义标签。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test()
{
    Gosub, Test2
    return

    Test2:
        MsgBox, Test2
    return
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代码中 Test2 是一个内部标签，只能在 Test 函数中访问。但不同函数中的内部标签也不能够重名，即所有的标签名必须是唯一的。&lt;/p&gt;
&lt;h2&gt;标签和函数的区别&lt;/h2&gt;
&lt;p&gt;总结下标签和函数的区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义和调用的方式不同。&lt;/li&gt;
&lt;li&gt;函数支持参数和返回值，标签不支持。&lt;/li&gt;
&lt;li&gt;标签默认是执行的，函数默认不执行。&lt;/li&gt;
&lt;li&gt;调用标签的开销比调用函数小，调用空函数的耗时比调用空标签多百分之几十。&lt;/li&gt;
&lt;li&gt;函数中可以使用局部变量和静态变量，但标签中只能使用全局变量。&lt;/li&gt;
&lt;li&gt;某些场景可能只允许用标签，但最新的 AHK 版本基本所有场景都可以用函数了（如果以后想起来有不可取代的场景再补充）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么是使用标签还是函数呢？&lt;/p&gt;
&lt;p&gt;通常情况，使用函数就可以了。如果考虑到性能，在无需参数和返回值的情况可以用标签取代函数。除非一个函数被高频率地调用，否则优化的效果不大。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中的字符串处理函数</title><link href="/ji-chu-ahk-zhong-de-zi-fu-chuan-chu-li-han-shu.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-de-zi-fu-chuan-chu-li-han-shu.html</id><summary type="html">&lt;p&gt;上一篇文章我介绍了AHK 中的字符串拼接和遍历操作，但除此之外还有很多其他类型的字符串操作。本文会罗列 AHK 中多数用于字符串操作的函数，但也正因为此，我不会对每一个函数都详细讲解和举例，大家可以直接去帮助文档查询感兴趣的函数，里边有详细的讲解和举例。另外有一些高级内容，我只在文中提及，后续会专门写文章来展开。&lt;/p&gt;
&lt;p&gt;很多字符串处理函数还有对应的命令，比如 StrLen 函数对应 StringLen 命令。因为通常情况，函数比命令好用，有时功能还更强大，所以只介绍函数。但在性能上，命令通常要比函数好一些，如果遇到性能问题，可以自行查找帮助文档，将函数替换成对应命令。&lt;/p&gt;
&lt;h2&gt;计算长度&lt;/h2&gt;
&lt;p&gt;StrLen 函数用于计算字符串的长度，这个我们在之前的判断空字符串的文章提及过，所以并不陌生。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;OutputVar := StrLen(InputVar)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要注意的是，StrLen 的结果并非字符串所占用的字节数。如果字符串里包含中文、全角字符以及日文、韩文等非 ASCII 字符，长度也是只算 1 的，虽然实际储存时并非只消耗 1 个字节 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;上一篇文章我介绍了AHK 中的字符串拼接和遍历操作，但除此之外还有很多其他类型的字符串操作。本文会罗列 AHK 中多数用于字符串操作的函数，但也正因为此，我不会对每一个函数都详细讲解和举例，大家可以直接去帮助文档查询感兴趣的函数，里边有详细的讲解和举例。另外有一些高级内容，我只在文中提及，后续会专门写文章来展开。&lt;/p&gt;
&lt;p&gt;很多字符串处理函数还有对应的命令，比如 StrLen 函数对应 StringLen 命令。因为通常情况，函数比命令好用，有时功能还更强大，所以只介绍函数。但在性能上，命令通常要比函数好一些，如果遇到性能问题，可以自行查找帮助文档，将函数替换成对应命令。&lt;/p&gt;
&lt;h2&gt;计算长度&lt;/h2&gt;
&lt;p&gt;StrLen 函数用于计算字符串的长度，这个我们在之前的判断空字符串的文章提及过，所以并不陌生。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;OutputVar := StrLen(InputVar)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要注意的是，StrLen 的结果并非字符串所占用的字节数。如果字符串里包含中文、全角字符以及日文、韩文等非 ASCII 字符，长度也是只算 1 的，虽然实际储存时并非只消耗 1 个字节。同时，StrLen 的结果也不能作为字符串的显示长度，因为通常中文、全角字符等要比英文、半角字符的显示宽度要大（如果是等宽字体，前者的宽度是后者的两倍）。&lt;/p&gt;
&lt;p&gt;StrLen 函数对应的命令是 StringLen。&lt;/p&gt;
&lt;h2&gt;查找&lt;/h2&gt;
&lt;p&gt;查找操作是指判断一个字符串是否包含另一个字符串，如果包含，还需要找到具体的位置，这便是 InStr 函数的工作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FoundPos := InStr(Haystack, Needle [, CaseSensitive = false, StartingPos = 1, Occurrence = 1])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;InStr 函数的参数比较多。Haystack 是被查找的字符串，Needle 是待查找的字符串（即从 Haystack 里查找 Needle），CaseSensitive 用于设置是否区分大小写，StartingPos 是开始查找的位置（从头开始为 1，如果是 0 或者负数，将逆序查找），Occurrence 指查找几次（比如 Occurrence 是  2，那么即使 Haystack 里有一个 Needle，也会因为没有第 2 个 Needle 而返回 0）。&lt;/p&gt;
&lt;p&gt;InStr 函数的返回值是 Needle 在 Haystack 的位置，从 1 开始。如果返回 0，说明没找到。&lt;/p&gt;
&lt;p&gt;和 InStr 函数有关的命令有 IfInString、IfNotInString、StringGetPos，如果遇到性能问题，可以使用。&lt;/p&gt;
&lt;p&gt;另外 if 也可以用来判断一个字符串中是否包含另一个字符串。可以在帮助文档搜索 if var [not] in/contains 找到，里边有详细讲解。我也会在以后专门介绍 if 判断的文章里展开。&lt;/p&gt;
&lt;h2&gt;截取&lt;/h2&gt;
&lt;p&gt;截取操作是指取一个字符串的子字符串，这正是 SubStr 函数的工作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;NewStr := SubStr(String, StartPos [, Length])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;SubStr 函数很好理解，String 即原始字符串。StartPos 为截取的起点，从 1 开始，如果为 0，表示截取最后一个字符；如果为 -1，表示截取最后两个字符，以此类推。Length 为截取的长度，如果省略指截到原始字符串的末尾。&lt;/p&gt;
&lt;p&gt;和 SubStr 函数有关的命令有 StringLeft、StringRight、StringMid、StringTrimLeft、StringTrimRight，这些命令用起来都不大方便，如果遇到性能问题，可以使用。&lt;/p&gt;
&lt;h2&gt;分隔&lt;/h2&gt;
&lt;p&gt;分隔字符串，和我们上一篇文章了解到的遍历字符串很像，但 StrSplit 使用起来更灵活。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Array := StrSplit(String [, Delimiters, OmitChars])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;String 是原始字符串，Delimiters 是分割符（和 Loop, Parse 不同，这里支持字符串，而且可以是一个字符串数组，非常强大），OmitChars 是移除和分隔符相邻的特定字符。&lt;/p&gt;
&lt;p&gt;返回的结果 Array 是一个数组，可以用 Array[1] 访问第一个元素，用 Array.Length() 获取数组中的元素个数等。以后我们会专门了解数组的用法。&lt;/p&gt;
&lt;p&gt;StrSplit 函数对应的命令是 StringSplit，但二者在细节上有很多不同，如果因为性能等原因一定要用 StringSplit，要仔细测试。&lt;/p&gt;
&lt;h2&gt;替换&lt;/h2&gt;
&lt;p&gt;有时我们需要将字符串的特定内容替换成其他内容，StrReplace 函数就派上用场了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;OutputVar := StrReplace(Haystack, SearchText [, ReplaceText, OutputVarCount, Limit := -1])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;StrReplace 函数参数比较多，但也很好理解。Haystack 是原始字符串，SearchText 是被替换的内容，ReplaceText 是替换成的内容（如果省略，代表直接删除），OutputVarCount 用来存放替换的次数（如果省略代表不保存），Limit 指最多替换几次（-1 指全部替换，如果为 1，代表只替换找到的第一个）。&lt;/p&gt;
&lt;p&gt;StrReplace 函数对应的命令是 StringReplace。&lt;/p&gt;
&lt;h2&gt;判断类型&lt;/h2&gt;
&lt;p&gt;判断类型是指判断一个字符串是否是整数、浮点数、字母、大写字母、小写字母、空白、时间等。&lt;/p&gt;
&lt;p&gt;帮助文档里讲得很详细，这里就不展开了，搜 if var is [not] type 即可。&lt;/p&gt;
&lt;p&gt;这里举个和下一节有关的判断大小写字母的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;abc&amp;quot;
b := &amp;quot;ABC&amp;quot;
c := &amp;quot;abc1&amp;quot;

if a is lower
{
    ; 条件成立，只有字符串里全部是小写字母（a-z）才成立
}

if b is upper
{
    ; 条件成立，同理
}

if c is lower
{
    ; 条件不成立，因为包含了一个数字
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;大小写转换&lt;/h2&gt;
&lt;p&gt;有时我们需要转换字符串中字母的大小写，StringLower 命令用于将大写字母转换成小写，StringUpper 命令用于将小写字母转换成大写。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StringLower, OutputVar, InputVar [, T]
StringUpper, OutputVar, InputVar [, T]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数中的 OutputVar 和 InputVar 都是变量名，即不用加 %。T 参数表示将字符串转换为标题格式，即每个单词的首字母大写，其余部分小写。&lt;/p&gt;
&lt;h2&gt;移除首尾指定字符&lt;/h2&gt;
&lt;p&gt;有时我们需要移除一个字符串首尾的某些字符，典型情况就是移除首尾的空格。这就需要使用 Trim 系列函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Result := Trim(String, OmitChars = &amp;quot; `t&amp;quot;)
Result := LTrim(String, OmitChars = &amp;quot; `t&amp;quot;)
Result := RTrim(String, OmitChars = &amp;quot; `t&amp;quot;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这三个函数用法一致，Trim 用于移除字符串首尾（两侧）的指定字符，LTrim 用于移除字符串首部（左侧）的指定字符，RTrim 用于移除字符串尾部（右侧）的指定字符。&lt;/p&gt;
&lt;p&gt;另外还有一个和此相关的命令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;AutoTrim, On|Off
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;AutoTrim 的含义是在用 = 赋值时是否自动移除首尾空白（空格和 Tab），默认是移除。&lt;/p&gt;
&lt;h2&gt;格式化&lt;/h2&gt;
&lt;p&gt;格式化操作主要是将整数、浮点数等格式化成特定格式的字符串，用来展示。这主要是 Format 函数的工作，SetFormat 命令也与此有关。Format 函数的参数很复杂，但帮助文档里有详细讲解，暂时就不展开了，以后可能单独讲解。&lt;/p&gt;
&lt;h2&gt;排序&lt;/h2&gt;
&lt;p&gt;对字符串排序可以使用 Sort 命令，因为排序比较复杂，我以后再单独讲。&lt;/p&gt;
&lt;h2&gt;字符编码操作&lt;/h2&gt;
&lt;p&gt;通常情况，我们不需要了解字符串对应的二进制数据是怎样的。但有些时候我们需要知道字符对应编码（比如 ASCII 编码，或者 UTF-8 编码），在字符与编码间相互转换等，Asc、Chr、Ord 函数用于此类操作。这其中涉及到一些复杂问题，先不展开，我以后会单独讲。&lt;/p&gt;
&lt;h2&gt;内存操作&lt;/h2&gt;
&lt;p&gt;通常情况，我们不需要关注字符串在内存是怎么储存的，但某些场景我们需要这么做，比如转编码（此处编码指代码页，比如将字符串从 UTF-8 转成 CP936）。这就需要用到 StrPut 和 StrGet 函数。这属于高级内容，也比较复杂，我以后会单独讲。&lt;/p&gt;
&lt;h2&gt;正则表达式&lt;/h2&gt;
&lt;p&gt;正则表达式也是用来查找和替换字符串用的，但自成体系，功能强大，也特别复杂。RegExMatch 函数、RegExReplace 函数和 ~= 运算符和正则表达式有关。因为 AHK 中的正则表达式和其他语言中的大同小异，而且关于正则表达式的内容特别多，暂时就不展开了，以后也会单独讲到。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中的字符串拼接和遍历操作</title><link href="/ji-chu-ahk-zhong-de-zi-fu-chuan-pin-jie-he-bian-li-cao-zuo.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-de-zi-fu-chuan-pin-jie-he-bian-li-cao-zuo.html</id><summary type="html">&lt;p&gt;字符串处理在多数编程语言中都是重头戏，AHK 自然也不例外。AHK 在字符串处理方面还是很灵活的，如果掌握好了，写起代码来会事半功倍。本文先介绍最常用的操作：拼接和遍历。&lt;/p&gt;
&lt;h2&gt;字符串拼接&lt;/h2&gt;
&lt;p&gt;拼接恐怕是最常用的操作了，在 AHK 中也非常简单，直接将两个字符串用空格隔开就可以了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;abc&amp;quot;
b := 100
c := &amp;quot;def&amp;quot;
d := 123.456
e := 200

; f 的值是字符串 abc100anddef123.456
f := a b &amp;quot;and&amp;quot; c d
; g 的值是字符串 100200
g := b e
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不管是字符串、整数还是浮点数，都可以用空格拼接成一个字符串。更神奇的是，空格可以和其他算术运算符一起使用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 100
b …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;字符串处理在多数编程语言中都是重头戏，AHK 自然也不例外。AHK 在字符串处理方面还是很灵活的，如果掌握好了，写起代码来会事半功倍。本文先介绍最常用的操作：拼接和遍历。&lt;/p&gt;
&lt;h2&gt;字符串拼接&lt;/h2&gt;
&lt;p&gt;拼接恐怕是最常用的操作了，在 AHK 中也非常简单，直接将两个字符串用空格隔开就可以了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;abc&amp;quot;
b := 100
c := &amp;quot;def&amp;quot;
d := 123.456
e := 200

; f 的值是字符串 abc100anddef123.456
f := a b &amp;quot;and&amp;quot; c d
; g 的值是字符串 100200
g := b e
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不管是字符串、整数还是浮点数，都可以用空格拼接成一个字符串。更神奇的是，空格可以和其他算术运算符一起使用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 100
b := 200

; c 的值是 100150
c := a b - 50
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其实 AHK 中整数 100200 和 字符串 "100200" 是没有区别的，当整数用的时候就是 100200，当字符串用的时候就是 "100200"，当然内部实现上会有一些优化。如果感觉无法接受的话，也可以认为整数和字符串是有区别的，在实际使用中会自动相互转换。&lt;/p&gt;
&lt;p&gt;实际上，AHK 中 .（点运算符）是专门用来拼接字符串的，在某些情况还是不能省略的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 300
b := 200

; c 的值是 100
c := a - b

; d 的值是 300-200
d := a . - b
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正因为空格可以和其他算术运算符一起使用，使用起来可以很灵活，为了避免歧义，空格只有在必要的情况（即这个表达式没有其他的解释办法时）才起拼接作用。&lt;/p&gt;
&lt;h2&gt;子字符串遍历&lt;/h2&gt;
&lt;p&gt;还有一个非常常见的操作，是遍历一个字符串的子字符串。Loop, Parse 是专门用来做这个的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop, Parse, InputVar [, Delimiters, OmitChars]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中 InputVar 是变量名，不需要加 %。Delimiters 是分隔符，OmitChars 是要忽略的字符。&lt;/p&gt;
&lt;p&gt;最简单的场景就是遍历字符串中的每一个字符。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;text := &amp;quot;abcd&amp;quot;

Loop, Parse, text
{
    ; 依次弹出
    ; a
    ; b
    ; c
    ; d
    MsgBox, %A_LoopField%
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Delimiters 和 OmitChars 都省略的情况，就是遍历字符串中的每一个字符。&lt;/p&gt;
&lt;p&gt;另外一个典型场景是依次处理一段文字的每一行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;text =
(
line1
line2
line3
)

Loop, Parse, text, `n, `r
{
    ; 依次弹出
    ; line1
    ; line2
    ; line3
    MsgBox, %A_LoopField%
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里 Delimiters 是 `n。`r 又是什么呢？在类 UNIX 操作系统中，文本中的换行符就是 `n，但在 Windows 中，换行符是 `r`n。如果处理一段换行符是 `r`n 的文本，直接用 `n 分隔，会保留多余的 `r，所以设置 OmitChars 为 `r 可以将其去掉。可能有不仔细的朋友认为 &lt;code&gt;Loop, Parse, text, \&lt;/code&gt;n, `r&lt;code&gt;是将字符串同时按 \&lt;/code&gt;n 和 `r 来分隔，这是错误的，`n 和 `r 的顺序也不能颠倒。&lt;/p&gt;
&lt;p&gt;除了按换行符，我们也经常需要按其他符号分隔字符串，比如按空格，按逗号等，就大同小异了。但需要注意空格和逗号有点特殊，因为它们是特殊符号，写法有一些特别。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;text := &amp;quot;a b,c d:xxx&amp;quot;

Loop, Parse, text, %A_Space%
{
    ; 依次弹出
    ; a
    ; b,c
    ; d:xxx
    MsgBox, %A_LoopField%
}

Loop, Parse, text, `,
{
    ; 依次弹出
    ; a b
    ; c d:xxx
    MsgBox, %A_LoopField%
}

Loop, Parse, text, :
{
    ; 依次弹出
    ; a b,c d
    ; xxx
    MsgBox, %A_LoopField%
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里空格用的是 %A_Space%，A_Space 是一个 AHK 的内部变量，这样需要用 % 取该变量的值。`, 是用转义的方法取到的逗号字符，因为直接写逗号会被认为是参数的分隔符。类似的还有 `t 或者 %A_Tab% 是 Tab 等等，如果一个字符直接写会报语法错误，那么通常在前边加个 ` 就可以了。以后我也会专门写文章介绍转义字符。至于冒号，就没有什么特别，直接写就可以了。&lt;/p&gt;
&lt;p&gt;有些情况我们需要按字符串分隔，而不是按字符分隔，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;text := &amp;quot;abc()bcd(cde&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要按 () 分隔 text。需要注意，这种情况这样的写法就是错误的了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;text := &amp;quot;abc()bcd(cde&amp;quot;

Loop, Parse, text, (, )
{
    ; 依次弹出
    ; abc
    ; bcd
    ; cde
    MsgBox, %A_LoopField%
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个可行的办法，是先将字符串中的 () 替换成一个字符串里没有的特殊字符，比如 @，然后再用这个特殊字符作为分隔符：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;text&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;abc()bcd(cde&amp;quot;&lt;/span&gt;

&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;StrReplace&lt;/span&gt; &lt;span class="err"&gt;函数是用来替换字符串的，我们以后再详细了解&lt;/span&gt;
&lt;span class="nl"&gt;text&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;StrReplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;()&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;@&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;Loop&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;依次弹出&lt;/span&gt;
    &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
    &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;bcd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cde&lt;/span&gt;
    &lt;span class="n"&gt;MsgBox&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;A_LoopField&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;更多内容&lt;/h2&gt;
&lt;p&gt;除了拼接和遍历字符串，我们还需要进行查找、替换、匹配、分隔、计算长度等操作，这涉及数量较多的字符串处理函数，以后我们再详细了解。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中读写文件的方法</title><link href="/ji-chu-ahk-zhong-du-xie-wen-jian-de-fang-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-du-xie-wen-jian-de-fang-fa.html</id><summary type="html">&lt;p&gt;读写文件是很常用的操作，本文简单介绍 AHK 中读写文件的方法。可以使用命令和函数两种方式读写文件，二者各有所长，所以分别介绍一下。&lt;/p&gt;
&lt;h2&gt;命令方式&lt;/h2&gt;
&lt;p&gt;使用命令写入和读取文件比较方便，但如果频繁调用，性能较差。&lt;/p&gt;
&lt;h3&gt;写入文件&lt;/h3&gt;
&lt;p&gt;FileAppend 命令用于写入文件，当文件不存在时会先创建文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileAppend [, Text, Filename, Encoding]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个命令用起来很方便，Text 即要写入的内容，如果 Text 为空，那么如果文件不存在，会创建空文件，如果文件已经存在，则只更新文件的修改时间。Filename 为文件名，如果 Filename 不包含绝对路径，那么就是在 A_WorkingDir 目录下。Encoding 是文件的编码，默认是 FileEncoding 命令指定的编码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileEncoding [, Encoding]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;常用的有以下几个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UTF-8。带 BOM 的 UTF-8 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;读写文件是很常用的操作，本文简单介绍 AHK 中读写文件的方法。可以使用命令和函数两种方式读写文件，二者各有所长，所以分别介绍一下。&lt;/p&gt;
&lt;h2&gt;命令方式&lt;/h2&gt;
&lt;p&gt;使用命令写入和读取文件比较方便，但如果频繁调用，性能较差。&lt;/p&gt;
&lt;h3&gt;写入文件&lt;/h3&gt;
&lt;p&gt;FileAppend 命令用于写入文件，当文件不存在时会先创建文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileAppend [, Text, Filename, Encoding]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个命令用起来很方便，Text 即要写入的内容，如果 Text 为空，那么如果文件不存在，会创建空文件，如果文件已经存在，则只更新文件的修改时间。Filename 为文件名，如果 Filename 不包含绝对路径，那么就是在 A_WorkingDir 目录下。Encoding 是文件的编码，默认是 FileEncoding 命令指定的编码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileEncoding [, Encoding]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;常用的有以下几个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UTF-8。带 BOM 的 UTF-8。&lt;/li&gt;
&lt;li&gt;UTF-8-RAW。不带 BOM 的 UTF-8。&lt;/li&gt;
&lt;li&gt;CP936。GBK 编码对应的代码页。&lt;/li&gt;
&lt;li&gt;ANSI。系统默认的代码页，对于中文的 Windows 系统，即 CP936。&lt;/li&gt;
&lt;li&gt;UTF-16。带 BOM 的小端 UTF-16。&lt;/li&gt;
&lt;li&gt;UTF-16-RAW。不带 BOM 的小端 UTF-16。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果也没用 FileEncoding 指定编码，那么默认是 ANSI 编码（也可以在用 AutoHotkey.exe 运行脚本时加参数指定，不推荐使用）。&lt;/p&gt;
&lt;p&gt;如果对这些编码没概念，建议使用 UTF-8，比较通用，在 Windows 下用记事本打开也显示正常。如果不需要记事本打开后显示正常，推荐使用 UTF-8-RAW，兼容性好，方便处理。如果需要尽量减少文件体积，可以使用 CP936。尽量不要使用 ANSI，以免在其他语言的系统出问题。非特殊情况，不建议使用 UTF-16 系列编码，以免衍生各种问题。&lt;/p&gt;
&lt;p&gt;如果文件中有内容，并且文件是带 BOM 的 UTF-8 或 UTF-16 编码，那么即使不指定编码，也会使用对应编码写入文件。&lt;/p&gt;
&lt;p&gt;如果文件不存在，并且指定了带 BOM 的 UTF-8 或 UTF-16 编码，那么将创建的文件并不是空文件，而是带了对应的 BOM。所以如果要创建一个空文件，可以使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileAppend, , Filename, UTF-8-RAW
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果往标准输出（stdout）写内容，Filename 填写 * 即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileAppend, Text, *
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;FileAppend 命令还有一些其他细节，比如换行符的问题，可以直接参考帮助文档。&lt;/p&gt;
&lt;h3&gt;读取文件&lt;/h3&gt;
&lt;p&gt;读取文件比写入文件复杂。&lt;/p&gt;
&lt;p&gt;FileRead 命令用于读取文件的全部内容（也可用参数指定大小）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileRead, OutputVar, Filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Filename 中可以指定一些参数，用于指定读取内容的大小、指定编码、是否转换换行符等。&lt;/p&gt;
&lt;p&gt;FileReadLine 命令用于读取文件的某一行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileReadLine, OutputVar, Filename, LineNum
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除了使用 FileRead 和 FileReadLine 命令，还可以用 Loop, Read 从头一行一行读取文件，效率要比 FileReadLine 高。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop, Read, InputFile [, OutputFile]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;循环中使用 A_LoopReadLine 变量访问读取到的一行内容。如果指定了 OutputFile，那么在循环中用 FileAppend 不指定文件名则会直接写入该文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop, Read, C:\Docs\Address List.txt, C:\Docs\Family Addresses.txt
{
    IfInString, A_LoopReadLine, family, FileAppend, %A_LoopReadLine%`n
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;函数方式&lt;/h2&gt;
&lt;p&gt;这里只简单列出相关函数，细节请参考帮助文档（搜 File object）。&lt;/p&gt;
&lt;h3&gt;打开文件&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;File := FileOpen(Filename, Flags [, Encoding])
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;写入内容&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 写入内容
File.Write(String)
; 按行写入内容
File.WriteLine([String])
; 写入特定类型数据
File.WriteNumType(Num)
; 写入原始格式数据
File.RawWrite(VarOrAddress, Bytes)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;读取内容&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 读取内容
String := File.Read([Characters])
; 读取一行内容
Line := File.ReadLine()
; 读取特定类型数据
Num := File.ReadNumType()
; 读取原始格式数据
File.RawRead(VarOrAddress, Bytes)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;其他操作&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 移动文件指针
File.Seek(Distance [, Origin = 0])
File.Position := Distance
File.Pos := Distance

; 获取文件指针的当前位置
Pos := File.Tell()
Pos := File.Position
Pos := File.Pos

; 获取和设置文件的大小
FileSize := File.Length
File.Length := NewSize

; 判断文件指针是否到达文件末尾
IsAtEOF := File.AtEOF

; 关闭文件
File.Close()

; 获取或设置文件编码
Encoding := File.Encoding
File.Encoding := Encoding

; 获取文件句柄
File.__Handle
&lt;/pre&gt;&lt;/div&gt;</content></entry><entry><title>[基础] AHK 中 % 符号的用法</title><link href="/ji-chu-ahk-zhong-fu-hao-de-yong-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-fu-hao-de-yong-fa.html</id><summary type="html">&lt;p&gt;AHK 中有一个很特别的符号 %。几乎随便从网上下一段 AHK 代码，就可以看到里边有 % 符号，而且 % 在 AHK 里的用法和所有其他编程语言都不一样，基本靠猜的话是猜不出来的。&lt;/p&gt;
&lt;h2&gt;用法一：%var%&lt;/h2&gt;
&lt;p&gt;第一种用法我们在介绍赋值表达式的时候接触过：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = 123
b = %a%
c = %a%456
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当用 = 对变量赋值时，如果一个字符串被两个 % 包围，并且中间没有空格，那么含义是取这个变量的值。&lt;/p&gt;
&lt;p&gt;在调用一个命令时，也是这样。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = 123
MsgBox, %a%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们这样用，&lt;code&gt;Name, xx, yy&lt;/code&gt;，Name 就是命令；如果我们这样用，&lt;code&gt;Name("xx", "yy")&lt;/code&gt;，Name 就是函数。命令和函数的区别我们也会在之后的文章了解到，现在只需要关注命令即可。&lt;/p&gt;
&lt;p&gt;注意两个%之间只能有一个单独的变量名 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;AHK 中有一个很特别的符号 %。几乎随便从网上下一段 AHK 代码，就可以看到里边有 % 符号，而且 % 在 AHK 里的用法和所有其他编程语言都不一样，基本靠猜的话是猜不出来的。&lt;/p&gt;
&lt;h2&gt;用法一：%var%&lt;/h2&gt;
&lt;p&gt;第一种用法我们在介绍赋值表达式的时候接触过：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = 123
b = %a%
c = %a%456
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当用 = 对变量赋值时，如果一个字符串被两个 % 包围，并且中间没有空格，那么含义是取这个变量的值。&lt;/p&gt;
&lt;p&gt;在调用一个命令时，也是这样。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = 123
MsgBox, %a%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们这样用，&lt;code&gt;Name, xx, yy&lt;/code&gt;，Name 就是命令；如果我们这样用，&lt;code&gt;Name("xx", "yy")&lt;/code&gt;，Name 就是函数。命令和函数的区别我们也会在之后的文章了解到，现在只需要关注命令即可。&lt;/p&gt;
&lt;p&gt;注意两个%之间只能有一个单独的变量名，像 x[1]、x.y、x[y]、fun() 等一概不支持。&lt;/p&gt;
&lt;h2&gt;用法二：% var&lt;/h2&gt;
&lt;p&gt;% 还有另一种用法，这回它只出现一个，并且 % 的后边有至少一个空格。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = 123
b = % a
MsgBox, % a
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样用表示 % 后边的内容按表达式来解析。我们可以认为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;b = %a%
MsgBox, %a%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;b = % a
MsgBox, % a
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;是一样的，实际上后者更强大一些。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 1
b := 2
c := 3

; 计算 a + b + c，结果为 6
MsgBox, % a + b + c

; 语法错误
; MsgBox, %a + b + c%

; 语法正确，但 + 失去计算功能，变成了字符串的一部分
; MsgBox, %a% + %b% + %c%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果 % 后边不只是一个变量名，而是一个表达式，那么“用法二”有效，“用法一”无效。&lt;/p&gt;
&lt;h2&gt;使用“用法一”还是“用法二”&lt;/h2&gt;
&lt;p&gt;我们发现“用法一”和“用法二”的功能上是有重叠的，那么实际情况应该怎么用呢？这个还是因人而异，尽量前后一致即可。但在某些场景“用法一”更方便，某些情况“用法二”更方便，甚至只能用“用法二”。&lt;/p&gt;
&lt;p&gt;“用法一”更方便的场景：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;变量本身包含双引号等特殊字符&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;%a% %b%&amp;quot;&lt;/span&gt;

&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;多行字符串中包含变量&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="n"&gt;xxx&lt;/span&gt;
&lt;span class="nf"&gt;%a&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;
&lt;span class="nf"&gt;%b&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;“用法二”更方便的场景：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 字符串中的变量居多
MsgBox, % a &amp;quot; &amp;quot; b &amp;quot; &amp;quot; c &amp;quot; &amp;quot; d
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只能用“用法二”的场景：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 需要使用表达式
MsgBox, % a + b - c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外如果考虑性能的话，“方法一”是要比“方法二”快二分之一到一倍的，但一般情况瓶颈不应该出现在这里，所以也不用过多在乎性能问题，如果真的是因为在很大的循环里使用而产生性能问题，修改一下也是很轻松的事情。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中关联数组、列表、栈和队列的用法</title><link href="/ji-chu-ahk-zhong-guan-lian-shu-zu-lie-biao-zhan-he-dui-lie-de-yong-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-guan-lian-shu-zu-lie-biao-zhan-he-dui-lie-de-yong-fa.html</id><summary type="html">&lt;p&gt;关联数组就像字典一样，我们可以通过一个键访问它对应的值。比如我可以往一本空字典里添加两个单词，a：一个，good：好，然后我就可以通过 a 访问它对应的解释“一个”，通过 good 访问它对应的解释“好”。普通数组是关联数组的一个子集，它的键是从 1 开始的连续数字。&lt;/p&gt;
&lt;h2&gt;创建&lt;/h2&gt;
&lt;p&gt;创建一个关联数组比较简单，AHK 中的数组实际上使用对象（Object()，也可以用 Array()，二者是一样的）实现的，所以创建数组就是创建一个空对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;array := Object()

Loop, 10
{
    ; 这里键和值都是 A_Index
    array[A_Index] := A_Index
    ; 如果是创建普通数组，也可以直接用 Push 函数
    ; array.Push(A_Index)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果事先已经知道数组的所有元素，也可以直接这样创建：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 不指定键的时候，即创建普通数组，键是 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;关联数组就像字典一样，我们可以通过一个键访问它对应的值。比如我可以往一本空字典里添加两个单词，a：一个，good：好，然后我就可以通过 a 访问它对应的解释“一个”，通过 good 访问它对应的解释“好”。普通数组是关联数组的一个子集，它的键是从 1 开始的连续数字。&lt;/p&gt;
&lt;h2&gt;创建&lt;/h2&gt;
&lt;p&gt;创建一个关联数组比较简单，AHK 中的数组实际上使用对象（Object()，也可以用 Array()，二者是一样的）实现的，所以创建数组就是创建一个空对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;array := Object()

Loop, 10
{
    ; 这里键和值都是 A_Index
    array[A_Index] := A_Index
    ; 如果是创建普通数组，也可以直接用 Push 函数
    ; array.Push(A_Index)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果事先已经知道数组的所有元素，也可以直接这样创建：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 不指定键的时候，即创建普通数组，键是 1 2 3
array1 := [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]
array2 := { &amp;quot;a&amp;quot; : &amp;quot;x&amp;quot;, &amp;quot;b&amp;quot; : &amp;quot;y&amp;quot;}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;访问&lt;/h2&gt;
&lt;p&gt;创建完数组，就可以访问了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 访问数组中键是 5 的值
MsgBox, % array[5]

; 访问数组中键是 &amp;quot;abc&amp;quot; 的值
MsgBox, % array[&amp;quot;abc&amp;quot;]

; 修改 &amp;quot;abc&amp;quot; 键对应的值
array[&amp;quot;abc&amp;quot;] := &amp;quot;def&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以遍历。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for index, element in array
{
    MsgBox, % index &amp;quot; &amp;quot; element
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;更多操作&lt;/h2&gt;
&lt;p&gt;下边列出数组操作相关函数，更多细节请参考帮助文档。&lt;/p&gt;
&lt;p&gt;Push 函数用于在数组的末尾添加元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Object.Push([ Value, Value2, ..., ValueN ])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pop 函数用于取出数组末尾的元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Value := Object.Pop()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;InsertAt 函数用于在数组的指定位置添加元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Object.InsertAt(Pos, Value1 [, Value2, ... ValueN])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;RemoveAt 函数用于删除数组指定位置的元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Object.RemoveAt(Pos [, Length])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Delete 函数用于删除指定键对应的元素。和 RemoveAt 函数的区别是，Delete 函数只是将键对应的值清空，而不会将键也删除。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Object.Delete(Key)
Object.Delete(FirstKey, LastKey)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Length 函数用来获取普通数组的长度。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Length := Object.Length()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;HasKey 函数用来判断数组中是否有对应键。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Object.HasKey(Key)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;MinIndex 函数和 MaxIndex 函数用来返回最小的和最大的键。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MinIndex := Object.MinIndex()
MaxIndex := Object.MaxIndex()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Clone 函数用来返回数组的一个浅拷贝。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Clone := Object.Clone()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;GetCapacity 函数和 SetCapacity 函数用来获取或者调整数组或其中元素占用的内存空间。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MaxItems := Object.GetCapacity()
ByteSize := Object.GetCapacity(Key)

Object.SetCapacity(MaxItems)
Object.SetCapacity(Key, ByteSize)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;GetAddress 函数用来获取键对应元素的地址。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Ptr := Object.GetAddress(Key)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ObjRawSet 函数用来存储或覆盖对象中的一组键值对。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ObjRawSet(Object, Key, Value)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;_NewEnum 函数会返回一个新的计数器，用来枚举数组中的键值对。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Enum := Object._NewEnum()
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;列表、栈、队列&lt;/h2&gt;
&lt;p&gt;通过以上的函数我们发现使用对象可以实现列表、栈和队列。&lt;/p&gt;
&lt;h3&gt;列表&lt;/h3&gt;
&lt;p&gt;列表可以使用Push、Pop、InsertAt、RemoveAt、Length、_NewEnum 等函数实现。&lt;/p&gt;
&lt;p&gt;list.InsertAt 函数和 list.Push 函数用于往列表添加元素，list.RemoveAt 函数和 list.Pop 函数用于从列表取出元素，list.Length() 用于获取列表大小，可以自行维护一个整数作为数组访问的当前位置，或者用 list._NewEnum 函数获取计数器来访问。&lt;/p&gt;
&lt;h3&gt;栈&lt;/h3&gt;
&lt;p&gt;栈可以用 Push、Pop、Length 函数实现。&lt;/p&gt;
&lt;p&gt;stack.Push(element) 用于往栈里添加元素，stack.Pop() 用于从栈里取出元素，stack.Length() 用于获取栈的大小。&lt;/p&gt;
&lt;h3&gt;队列&lt;/h3&gt;
&lt;p&gt;队列可以用 Push、RemoveAt、Length 函数实现。&lt;/p&gt;
&lt;p&gt;queue.Push(element) 用于往队列尾部添加元素，queue.RemoveAt(1) 用于从队列头部取出元素，queue.Length() 用于获取队列大小。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中 = 和 == 等比较运算符的用法</title><link href="/ji-chu-ahk-zhong-he-deng-bi-jiao-yun-suan-fu-de-yong-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-he-deng-bi-jiao-yun-suan-fu-de-yong-fa.html</id><summary type="html">&lt;p&gt;上一篇文章我们了解到了 = 和 := 的区别，也了解了怎样对变量赋值。除了赋值，我们还经常需要比较两个变量的值是否相等，这就需要比较运算符了。&lt;/p&gt;
&lt;p&gt;一翻手册，头疼的事情又来了。其他语言要么用 = 比较，要么用 == 比较，只是习惯的问题。而 AHK 用 = 和 == 都可以比较，而且二者居然还有区别。不过还好区别不是那么大，也并不难理解。&lt;/p&gt;
&lt;h2&gt;大小写问题&lt;/h2&gt;
&lt;p&gt;这里先提下大小写问题，这与 = 和 == 的区别密切相关。AHK 的代码是不区分大小写的，也就是说，在通常情况，将一份不涉及外部交互（如创建目录、写文件、和其他程序交互等）的 AHK 代码中的小写字母全部转换成大写字母，是不影响功能的。所有的关键字、变量名，都是不区分大小写的。但有一些特例，用 == 比较字符串是区分大小写的，以及后边会提到的 StringCaseSense 命令。&lt;/p&gt;
&lt;h2&gt;= 和 == 的区别 …&lt;/h2&gt;</summary><content type="html">&lt;p&gt;上一篇文章我们了解到了 = 和 := 的区别，也了解了怎样对变量赋值。除了赋值，我们还经常需要比较两个变量的值是否相等，这就需要比较运算符了。&lt;/p&gt;
&lt;p&gt;一翻手册，头疼的事情又来了。其他语言要么用 = 比较，要么用 == 比较，只是习惯的问题。而 AHK 用 = 和 == 都可以比较，而且二者居然还有区别。不过还好区别不是那么大，也并不难理解。&lt;/p&gt;
&lt;h2&gt;大小写问题&lt;/h2&gt;
&lt;p&gt;这里先提下大小写问题，这与 = 和 == 的区别密切相关。AHK 的代码是不区分大小写的，也就是说，在通常情况，将一份不涉及外部交互（如创建目录、写文件、和其他程序交互等）的 AHK 代码中的小写字母全部转换成大写字母，是不影响功能的。所有的关键字、变量名，都是不区分大小写的。但有一些特例，用 == 比较字符串是区分大小写的，以及后边会提到的 StringCaseSense 命令。&lt;/p&gt;
&lt;h2&gt;= 和 == 的区别&lt;/h2&gt;
&lt;p&gt;用 = 比较字符串是不区分大小写的，而用 == 比较字符串是区分大小写的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;abc&amp;quot;
b := &amp;quot;ABC&amp;quot;

if (a = b)
{
    ; 条件成立
}

if (a == b)
{
    ; 条件不成立
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;!= 和 &amp;lt;&amp;gt; 的用法&lt;/h2&gt;
&lt;p&gt;如果只考虑 = 和 == 的用法，并没有什么需要注意的，一个不区分大小写，一个区分大小写，根据实际情况选择即可。但有等号，自然就有不等号，考虑到不等号，问题就复杂化了。&lt;/p&gt;
&lt;p&gt;AHK 中的不等号也有两种，!= 和 &amp;lt;&amp;gt;，好在二者是完全相同的，可以根据自己的习惯来使用。但在处理大小写问题上，不等号和等号有着很大的区别。&lt;/p&gt;
&lt;p&gt;我们需要先了解一个命令，StringCaseSense：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StringCaseSense, On|Off|Locale
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;StringCaseSense 用于设置在字符串处理时是否区分大小写。如果设置了 On，就是区分；如果设置了 Off，就是不区分。先不用关注 Locale 参数。默认是 Off。&lt;/p&gt;
&lt;p&gt;注意这个命令不影响 = 和 == 的功能。也就是说即使设置了 StringCaseSense, On，用 = 比较字符串还是不区分大小写的。但影响 != 和 &amp;lt;&amp;gt; 的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;abc&amp;quot;
b := &amp;quot;ABC&amp;quot;

StringCaseSense, On
if (a != b)
{
    ; 条件成立
}

StringCaseSense, Off
if (a != b)
{
    ; 条件不成立
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个也并不难理解，因为通常情况我们无需设置 StringCaseSense，比较的结果都是不区分大小写的。&lt;/p&gt;
&lt;h2&gt;=、==、!=、&amp;lt;&amp;gt; 一起使用&lt;/h2&gt;
&lt;p&gt;既然我们已经分别了解了 =、==、!= 和 &amp;lt;&amp;gt; 的区别，就可以一起使用了。但这里就又一些新的事情需要注意了。&lt;/p&gt;
&lt;p&gt;默认情况，也就是 StringCaseSense, Off 的情况。= 和 != 是对应的，也就是说：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (a = b)
{
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; ! 是逻辑非操作，和很多其他语言一样。
if (!(a != b))
{
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;是一样的。但 StringCaseSense, On 的情况，== 和 != 是对应的。&lt;/p&gt;
&lt;p&gt;也就是说，如果我们在 StringCaseSense, Off 的情况，将 == 和 != 在一起使用，可能会出问题。同理，在 StringCaseSense, On 的情况，将 = 和 != 在一起使用，也可能会出问题。会出什么样的问题呢，举一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StringCaseSense, Off

a := &amp;quot;abc&amp;quot;
b := &amp;quot;ABC&amp;quot;

; 片段一
if (a == b)
{
    ; 做 a
    ; 条件不成立
}
else
{
    ; 做 b
    ; 走此分支
}

; 片段二
if (a != b)
{
    ; 做 b
    ; 条件不成立
}
else
{
    ; 做 a
    ; 走此分支
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们看下里边的片段一和片段二。逻辑看起来好像一样，有人喜欢用等号比较，有人喜欢用不等号比较，这和习惯有关，无可厚非。但我们发现问题来了，这两段看起来一样的代码执行结果完全相反，片段一做了 b，片段二做了 a。如果这个判断很重要，会留下非常大的隐患。&lt;/p&gt;
&lt;p&gt;更要命的是，以上的代码如果设置了 StringCaseSense, On，片段一和片段二是一样的，不存在问题，但后续代码维护者可能因为某些原因，将其改成了 StringCaseSense, Off。改的人可能认为只是把原来的区分大小写改成了不区分大小写，其他地方都不用动，而不会专门把所有的 == 改成 =。而这一改可能就留下了非常严重的 bug，而且通常情况不会触发，只有在比较仅大小写不同的两个字符串时才会触发。&lt;/p&gt;
&lt;h2&gt;注意事项&lt;/h2&gt;
&lt;p&gt;所以，在比较字符串时还是需要留神的。因为通常情况我们无需设置 StringCaseSense，不等号在比较字符串的时候是不区分大小写的。对应地，我们也应该用 = 来比较字符串，以免发生之前描述的问题。如果因为某些情况，我们需要修改之前代码的 StringCaseSense，一定要仔细审视每一处用 = 或者 == 比较字符串的代码，看是否存在问题。必要的话，需要将 = 与 == 互换。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中 = 和 ：= 赋值运算符的用法</title><link href="/ji-chu-ahk-zhong-he-fu-zhi-yun-suan-fu-de-yong-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-he-fu-zhi-yun-suan-fu-de-yong-fa.html</id><summary type="html">&lt;p&gt;在接触一门新的编程语言后，了解如何对变量赋值几乎是第一步。有了变量，才可以对变量进行数学运算或者逻辑判断，将调用函数得到的结果存入变量也需要赋值操作。可见赋值运算符的重要性。&lt;/p&gt;
&lt;p&gt;但很多 AHK 初学者（包括其他编程语言的老手）惊奇地发现 AHK 有两种赋值运算符，= 和 :=，而且它们的用法居然不一样。一时摸不到头脑，甚至对 AHK 顿生反感。当然这不能怪用户，赋值操作如此混乱的语言，恐怕无出其右了。但如果掌握了，也会发现在赋值操作上，AHK 要比其他语言更为灵活和方便。&lt;/p&gt;
&lt;h2&gt;:= 的用法&lt;/h2&gt;
&lt;p&gt;先介绍其中相对好理解的 := 运算符。&lt;/p&gt;
&lt;p&gt;:= 和其他语言的 = 用法基本一致，来看几个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 123
b := 456.789
c := &amp;quot;text&amp;quot;
d := a
e := a . c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到如果将变量赋值成整数、浮点数、字符串，直接写就好了。我们也可以把一个已经存在的变量赋值给一个新变量。这和其他语言中 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;在接触一门新的编程语言后，了解如何对变量赋值几乎是第一步。有了变量，才可以对变量进行数学运算或者逻辑判断，将调用函数得到的结果存入变量也需要赋值操作。可见赋值运算符的重要性。&lt;/p&gt;
&lt;p&gt;但很多 AHK 初学者（包括其他编程语言的老手）惊奇地发现 AHK 有两种赋值运算符，= 和 :=，而且它们的用法居然不一样。一时摸不到头脑，甚至对 AHK 顿生反感。当然这不能怪用户，赋值操作如此混乱的语言，恐怕无出其右了。但如果掌握了，也会发现在赋值操作上，AHK 要比其他语言更为灵活和方便。&lt;/p&gt;
&lt;h2&gt;:= 的用法&lt;/h2&gt;
&lt;p&gt;先介绍其中相对好理解的 := 运算符。&lt;/p&gt;
&lt;p&gt;:= 和其他语言的 = 用法基本一致，来看几个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 123
b := 456.789
c := &amp;quot;text&amp;quot;
d := a
e := a . c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到如果将变量赋值成整数、浮点数、字符串，直接写就好了。我们也可以把一个已经存在的变量赋值给一个新变量。这和其他语言中 = 的用法并无二致。.（点运算符）用来拼接字符串，这个在后续文章中也会单独介绍。&lt;/p&gt;
&lt;p&gt;如果我们将一个不存在的变量赋值给一个新变量，像这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;f := abc
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么 f 将是一个空字符串，也就是和这样效果一样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;f := &amp;quot;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;= 的用法&lt;/h2&gt;
&lt;p&gt;然后我们再来看 =。&lt;/p&gt;
&lt;p&gt;= 后边的内容全部被认为是字符串，看几个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = 123
b = 456.789
c = text
d = a
e = %a%
f = %a%456
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意这里边的 a 和 b 已经不是整数和浮点数了，而全是字符串。d 的值也不是 123，而是字符串 a。那么是不是 = 只能用来将一个字符串常量赋值给一个变量呢？如果这样的话，= 基本也没有存在的必要了。我们可以看下 e = %a%，里边有一个奇怪的 % 符号（% 也是 AHK 中的大坑，以后我会专门写文章介绍），%a% 的意思是取 a 变量的值，所以 e 的值是字符串 123，同理 f 的值是字符串 123456。是不是 = 比 := 稍微难理解一些？&lt;/p&gt;
&lt;p&gt;另外 = 还有一些高级用法，比如将多行文本赋值给一个变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a =
(
123
456
789
)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在括号中的多行文本会被赋值给 a，这在某些需要赋值大段文字的场景是非常方便的。&lt;/p&gt;
&lt;p&gt;用 = 赋值空字符串也更加简洁：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a =
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（其实 a := 这样用也是可以的，虽然看起来怪怪的。）&lt;/p&gt;
&lt;p&gt;此外在某些场景只能用 = 赋值，比如上一篇文章中处理命令行参数的场景：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;argc = %0%
argv1 = %1%
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;使用场景&lt;/h2&gt;
&lt;p&gt;既然 = 和 := 在多数情况都可以实现相同的功能，什么场景应该使用 =，什么场景应该使用 := 呢？&lt;/p&gt;
&lt;p&gt;这个并没有明确的规定，可以因人而异，根据自己的习惯来。但尽量前后统一，以免给自己和别人带来麻烦。&lt;/p&gt;
&lt;p&gt;一般来说，使用 := 是更加严谨的，这也是和其他编程语言的用法对齐，更易于被接受。但也并不是弃 = 而不用，在某些场景，比如赋值大段文字，= 还是非常方便的。&lt;/p&gt;
&lt;p&gt;关于 = 的用法，此文只是简单介绍几个例子，还有更多的用法期待大家发掘。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中全局变量、局部变量和静态变量的用法和区别</title><link href="/ji-chu-ahk-zhong-quan-ju-bian-liang-ju-bu-bian-liang-he-jing-tai-bian-liang-de-yong-fa-he-qu-bie.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-quan-ju-bian-liang-ju-bu-bian-liang-he-jing-tai-bian-liang-de-yong-fa-he-qu-bie.html</id><summary type="html">&lt;p&gt;谈到全局变量、局部变量和静态变量，就涉及到两个概念：作用域和生存期。&lt;/p&gt;
&lt;p&gt;这是两个完全不同的概念，虽然很多时候相互关联。作用域是作用在空间上的，比如一个变量在代码的哪些行能访问，哪些行不能访问。而生存期是作用在时间上的，比如一个变量的值在函数返回后是否失效。&lt;/p&gt;
&lt;h2&gt;全局变量&lt;/h2&gt;
&lt;p&gt;全局变量比较好理解，如果一个变量是全局变量，那么程序中的所有代码都可以访问到这个变量（除非存在同名的局部变量或者静态变量）。全局变量用 global 定义。&lt;/p&gt;
&lt;p&gt;看一个例子。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 1
global b := 2
c := 3

fun()

fun()
{
    ; a 不是全局变量，访问不了，弹出空字符串
    MsgBox, % a

    ; b 是全局变量，弹出 2
    MsgBox, % b

    ; 在函数里也可以将 c 变成全局变量
    global c
    ; 弹出 3
    MsgBox, % c …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;谈到全局变量、局部变量和静态变量，就涉及到两个概念：作用域和生存期。&lt;/p&gt;
&lt;p&gt;这是两个完全不同的概念，虽然很多时候相互关联。作用域是作用在空间上的，比如一个变量在代码的哪些行能访问，哪些行不能访问。而生存期是作用在时间上的，比如一个变量的值在函数返回后是否失效。&lt;/p&gt;
&lt;h2&gt;全局变量&lt;/h2&gt;
&lt;p&gt;全局变量比较好理解，如果一个变量是全局变量，那么程序中的所有代码都可以访问到这个变量（除非存在同名的局部变量或者静态变量）。全局变量用 global 定义。&lt;/p&gt;
&lt;p&gt;看一个例子。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 1
global b := 2
c := 3

fun()

fun()
{
    ; a 不是全局变量，访问不了，弹出空字符串
    MsgBox, % a

    ; b 是全局变量，弹出 2
    MsgBox, % b

    ; 在函数里也可以将 c 变成全局变量
    global c
    ; 弹出 3
    MsgBox, % c
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意代码里的 a 并不是全局变量，虽然它的作用域要比函数里的局部变量要大，在所有文件的函数外都可以访问，但在函数内它是不能被访问到的，这算是一个特例。&lt;/p&gt;
&lt;h2&gt;局部变量&lt;/h2&gt;
&lt;p&gt;在函数里使用的变量通常是局部变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fun()
; a 并不是全局变量，弹出空字符串
MsgBox, % a
; b 是全局变量，弹出 2
MsgBox, % b

fun()
{
    a := 1
    global b := 2
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意这里 b 是在函数里定义的全局变量，但不管是在什么地方定义的，在其他地方都可以访问到。&lt;/p&gt;
&lt;h2&gt;静态变量&lt;/h2&gt;
&lt;p&gt;全局变量和局部变量的作用域和生存期都不一样。全局变量的作用域和生存期都是全局的，局部变量的作用域是在函数内部，生存期是从函数开始执行到函数返回。&lt;/p&gt;
&lt;p&gt;但还有一种比较特别的变量是静态变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 弹出 1 1
fun()
; 弹出 1 2
fun()

fun()
{
    a := 1
    static b := 1
    MsgBox, % a &amp;quot; &amp;quot; b
    a++
    b++
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;a 就是普通的局部变量，因为每次执行 a 都会被初始化为 1，所以两次运行 fun 函数时 a 的值都是 1。但 b 是一个静态变量（使用 static 定义）。静态变量的作用域和局部变量一样，只能在函数内访问。但生存期和全局变量一样，也就是说一个静态变量定义后，它的值会一直有效，即使函数已经返回了。所有第二次运行 fun 函数后，b 的值已经是 2 了。&lt;/p&gt;
&lt;h2&gt;使用场景&lt;/h2&gt;
&lt;p&gt;那么什么分别在什么情况下使用三者呢？&lt;/p&gt;
&lt;p&gt;没有特殊需求的场景，都应该使用局部变量，这也是默认的情况。&lt;/p&gt;
&lt;p&gt;如果一个变量是需要全局有效的，那么使用全局变量。但全局变量会导致代码的耦合度比较高，不方便维护，所以尽量少用。有些看似需要使用全局变量的场景，其实使用函数的参数传递更合理。&lt;/p&gt;
&lt;p&gt;如果某个局部变量需要只初始化一次（一般情况是因为初始化有开销，这是主要的场景），或者需要保留上次运行的结果（这会导致代码容易滋生 bug，并且难于测试，尽量少用），那么需要将这个局部变量修改成静态变量。&lt;/p&gt;
&lt;p&gt;除了全局变量、局部变量、静态变量，还有在类中的变量，这个我会在类中单独讲。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中循环的基本用法</title><link href="/ji-chu-ahk-zhong-xun-huan-de-ji-ben-yong-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-xun-huan-de-ji-ben-yong-fa.html</id><summary type="html">&lt;p&gt;在我们重复做一些事情的时候，就需要使用循环了。而 AHK 正是能将复杂的手动工作自动化的工具，循环自然必不可少。但 AHK 中的循环也是多种多样的，我们慢慢道来。&lt;/p&gt;
&lt;h2&gt;最简单的循环&lt;/h2&gt;
&lt;p&gt;最简单的情况，我们知道要循环多少次，比如想连续按下 10 次回车键：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop, 10
{
    Send, {Enter}
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就可以了。在 Loop 后加上要循环的次数，然后大括号里边就是要循环执行的语句。当然我们可以先把循环的次数放进一个变量，这样更灵活些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;count := 10

Loop, %count%
{
    Send, {Enter}
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以在循环体中使用 A_Index 来获取当前循环的次数。&lt;/p&gt;
&lt;p&gt;或者有可能我们想一直循环执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop
{
    Send, {Enter}
    Sleep, 1000
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个就是死循环了，如果脚本不退出就会一直执行，某些情况我们确实需要这样。但更多情况，我们需要在满足某个条件时结束循环：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 这个 stop 变量会在代码的其他地方修改 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;在我们重复做一些事情的时候，就需要使用循环了。而 AHK 正是能将复杂的手动工作自动化的工具，循环自然必不可少。但 AHK 中的循环也是多种多样的，我们慢慢道来。&lt;/p&gt;
&lt;h2&gt;最简单的循环&lt;/h2&gt;
&lt;p&gt;最简单的情况，我们知道要循环多少次，比如想连续按下 10 次回车键：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop, 10
{
    Send, {Enter}
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就可以了。在 Loop 后加上要循环的次数，然后大括号里边就是要循环执行的语句。当然我们可以先把循环的次数放进一个变量，这样更灵活些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;count := 10

Loop, %count%
{
    Send, {Enter}
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以在循环体中使用 A_Index 来获取当前循环的次数。&lt;/p&gt;
&lt;p&gt;或者有可能我们想一直循环执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop
{
    Send, {Enter}
    Sleep, 1000
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个就是死循环了，如果脚本不退出就会一直执行，某些情况我们确实需要这样。但更多情况，我们需要在满足某个条件时结束循环：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 这个 stop 变量会在代码的其他地方修改，比如在某个定时器里
stop := false

Loop
{
    Send, {Enter}
    Sleep, 1000

    if (stop)
    {
        break
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;break 是用来退出循环的，continue 是用来结束当前循环，进入下一次循环的。这和其他语言都一致。&lt;/p&gt;
&lt;h2&gt;Loop Until 循环&lt;/h2&gt;
&lt;p&gt;上边的最后一种用法，即满足某个条件时结束循环，也可以用 Until 来实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;stop := false

Loop
{
    Send, {Enter}
    Sleep, 1000
}
Until stop
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起来比刚才的要简洁一些。&lt;/p&gt;
&lt;h2&gt;While 循环&lt;/h2&gt;
&lt;p&gt;有些时候我们需要先判断条件，然后再决定是否要循环，这样虽然用 Loop 也能实现，但有些别扭，这时就可以用 While 循环了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;count := 0

while (count &amp;lt; 10)
{
    Send, {Enter}
    Sleep, 1000
    count++
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;count := 0

Loop
{
    if (count &amp;gt;= 10)
    {
        break
    }

    Send, {Enter}
    Sleep, 1000
    count++
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;是等同的，使用哪个就看自己的习惯了。&lt;/p&gt;
&lt;h2&gt;更多内容&lt;/h2&gt;
&lt;p&gt;有些时候我们需要循环读取数组、读取字符串中的子字符串、读取文件内容、遍历目录下的文件甚至遍历注册表等，AHK 中都有很方便的用法，而无需让我们在 Loop 里写复杂的逻辑，我们会在之后的文章中了解到。&lt;/p&gt;</content></entry><entry><title>[基础] 如何用 AHK 处理命令行参数</title><link href="/ji-chu-ru-he-yong-ahk-chu-li-ming-ling-xing-can-shu.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ru-he-yong-ahk-chu-li-ming-ling-xing-can-shu.html</id><summary type="html">&lt;p&gt;写过 C 语言的朋友都清楚 main() 函数可以有两个参数，argc 和 argv，argc 是命令行参数个数，argv 则用于访问具体参数，使用起来非常容易。那么用 AHK 如何访问命令行参数呢？&lt;/p&gt;
&lt;p&gt;官方文档有介绍，但并不是很详细，容易让人看后感觉一头雾水，这里简单整理一下。&lt;/p&gt;
&lt;h2&gt;获取参数的个数&lt;/h2&gt;
&lt;p&gt;要处理参数，得先清楚有没有参数，也就是获取参数的个数。&lt;/p&gt;
&lt;p&gt;%0% 内部变量是用来存放参数个数的，这样可以用 MsgBox 弹出参数个数，是不是很简单？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MsgBox, %0%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但需要注意的时，如果一个变量名是 a，我们可以用 MsgBox, %a% 和 MsgBox, % a 两种方式在 MsgBox 中访问 a。但此时我们不能用 MsgBox, % 0 来访问参数个数，因为这样会直接弹出数字 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;写过 C 语言的朋友都清楚 main() 函数可以有两个参数，argc 和 argv，argc 是命令行参数个数，argv 则用于访问具体参数，使用起来非常容易。那么用 AHK 如何访问命令行参数呢？&lt;/p&gt;
&lt;p&gt;官方文档有介绍，但并不是很详细，容易让人看后感觉一头雾水，这里简单整理一下。&lt;/p&gt;
&lt;h2&gt;获取参数的个数&lt;/h2&gt;
&lt;p&gt;要处理参数，得先清楚有没有参数，也就是获取参数的个数。&lt;/p&gt;
&lt;p&gt;%0% 内部变量是用来存放参数个数的，这样可以用 MsgBox 弹出参数个数，是不是很简单？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MsgBox, %0%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但需要注意的时，如果一个变量名是 a，我们可以用 MsgBox, %a% 和 MsgBox, % a 两种方式在 MsgBox 中访问 a。但此时我们不能用 MsgBox, % 0 来访问参数个数，因为这样会直接弹出数字 0。那么如果我一定要在 MsgBox 的参数前加 % 呢？可以先将 %0% 转存到其他变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 注意这里不能用 :=
argc = %0%
MsgBox, % argc
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样 argc 就和其他变量无异了。&lt;/p&gt;
&lt;p&gt;如果我们想判断命令行参数有多少个，也有两种方式：&lt;/p&gt;
&lt;p&gt;第一种方式，也是官方文档中的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if 0 = 2
{
    MsgBox, 有两个参数
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有些朋友看到这就一头雾水了，0 怎么会等于 2？其实这句 if 判断里，2 确实是数字 2，而 0 并非数字 0，而是 %0% 的值，也就是命令行参数的个数。从这里也可以看出 AHK 语言不严谨的地方。如果实在认为这样判断太违背直觉，无法接受，也可以使用迂回的办法。&lt;/p&gt;
&lt;p&gt;第二种方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;argc = %0%

if (argc == 2)
{
    MsgBox, 有两个参数
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就正常多了。但需要注意，如下用法是错误的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (%0% == 2)
{
    MsgBox, 有两个参数
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这也是让很多人困惑的地方。毕竟 %0% 是特例，不能像用其他正常变量一样使用，需要特殊记忆一下。&lt;/p&gt;
&lt;h2&gt;获取具体参数&lt;/h2&gt;
&lt;p&gt;当我们知道了参数个数，就可以去读参数的值了，有了刚才的铺垫，这一步也容易很多了。&lt;/p&gt;
&lt;p&gt;%1% 是第一个参数，%2% 是第二个参数，依次类推。而访问 %1% %2% 的方式，和访问 %0% 是一样的。为了不违反直觉，还是建议先将参数转存到一个有意义的变量名，再作处理，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;flag = %1%

if (flag == &amp;quot;-c&amp;quot;)
{
    MsgBox, -c 参数已传入
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;遍历所有参数&lt;/h2&gt;
&lt;p&gt;遍历所有参数是一种常见的处理方法，在 AHK 里也是比较容易的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop, %0%
{
    param := %A_Index%
    MsgBox, %param%
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里又有事情需要注意了。这个 Loop 看起来没什么，%0% 就是参数的个数，有几个参数就循环几次，但&lt;code&gt;param := %A_Index%&lt;/code&gt;，这里用的是&lt;code&gt;:=&lt;/code&gt;，而不是&lt;code&gt;=&lt;/code&gt;。这个之前的&lt;code&gt;param = %1%&lt;/code&gt;是不同的。为什么有这样的区别呢？&lt;/p&gt;
&lt;p&gt;A_Index 存放的是一个数字，如果直接用&lt;code&gt;param := A_Index&lt;/code&gt;，那么 param 的值自然也就是数字了，而不是对应的参数。所以需要用&lt;code&gt;%&lt;/code&gt;将这个数字解析成参数。这个用法又和通常的变量有所不同。&lt;/p&gt;
&lt;p&gt;这种用法并非处理命令行参数时的特例，我们可以看下这个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;b&amp;quot;
b := &amp;quot;c&amp;quot;
d := %a%
MsgBox, %d%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;a 的值是 b，b 的值是 c，&lt;code&gt;d := %a%&lt;/code&gt;中，%a% 的值是 b，所以这里的&lt;code&gt;d := %a%&lt;/code&gt;等同于&lt;code&gt;d := b&lt;/code&gt;，于是 d 的值是 c。也就是可以将变量的值解析成变量名，再去取变量的值，这样的技巧在很多语言里都可以用。&lt;/p&gt;</content></entry><entry><title>[基础] 如何在 AHK 下载网络内容到文件或变量</title><link href="/ji-chu-ru-he-zai-ahk-xia-zai-wang-luo-nei-rong-dao-wen-jian-huo-bian-liang.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ru-he-zai-ahk-xia-zai-wang-luo-nei-rong-dao-wen-jian-huo-bian-liang.html</id><summary type="html">&lt;p&gt;现在早已是网络时代了，完全单机而不需要联网的软件很少了。某些时候，用 AHK 写个脚本也是需要去网络获取数据的。&lt;/p&gt;
&lt;h2&gt;下载网络内容到本地文件&lt;/h2&gt;
&lt;p&gt;有些时候我们需要把一个网页、图片、音频等文件下载到本地，再做后续处理。在其他编程语言可能就比较麻烦了，比如先下载网络内容到一个字符串变量，然后创建一个文件，将字符串写入，再保存文件。而 AHK 内置的 UrlDownloadToFile 命令就是为这个场景量身定做的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UrlDownloadToFile, URL, Filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，这个命令的用法非常简单，第一个参数是文件的网络地址，第二个参数是文件的本地地址。如果第二个参数不是完整路径，文件会被下载到当前脚本的工作目录，一般情况就是脚本自身的目录。&lt;/p&gt;
&lt;p&gt;比如我想下载 AHK 官网的 Logo 图片到 C:\test.png，就可以这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UrlDownloadToFile, http://ahkscript.org/logos/ahk_logo.png, C:\test.png …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;现在早已是网络时代了，完全单机而不需要联网的软件很少了。某些时候，用 AHK 写个脚本也是需要去网络获取数据的。&lt;/p&gt;
&lt;h2&gt;下载网络内容到本地文件&lt;/h2&gt;
&lt;p&gt;有些时候我们需要把一个网页、图片、音频等文件下载到本地，再做后续处理。在其他编程语言可能就比较麻烦了，比如先下载网络内容到一个字符串变量，然后创建一个文件，将字符串写入，再保存文件。而 AHK 内置的 UrlDownloadToFile 命令就是为这个场景量身定做的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UrlDownloadToFile, URL, Filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，这个命令的用法非常简单，第一个参数是文件的网络地址，第二个参数是文件的本地地址。如果第二个参数不是完整路径，文件会被下载到当前脚本的工作目录，一般情况就是脚本自身的目录。&lt;/p&gt;
&lt;p&gt;比如我想下载 AHK 官网的 Logo 图片到 C:\test.png，就可以这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UrlDownloadToFile, http://ahkscript.org/logos/ahk_logo.png, C:\test.png
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;是不是非常简单。除了 HTTP，UrlDownloadToFile 还支持 HTTPS 和 FTP 协议。&lt;/p&gt;
&lt;h2&gt;下载网络内容到字符串变量&lt;/h2&gt;
&lt;p&gt;但有些情况，我们并不需要将网络内容保存到文件里，而是直接使用，比如直接显示在控件里。虽然也可以先写到文件再读出来，但这样做不仅多此一举，有额外的开销，还需要考虑共用临时文件、临时文件没被删除等问题。&lt;/p&gt;
&lt;p&gt;AHK 并没有命令可以直接将网络内容下载到字符串变量，但可以使用 COM 对象 WinHttp.WinHttpRequest.5.1，官方文档中有一个例子，用起来倒也不是很麻烦。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;whr := ComObjCreate(&amp;quot;WinHttp.WinHttpRequest.5.1&amp;quot;)
; Open() 的第三个参数代表同步或者异步，现在不用过多关注，true 就可以了
; 以后我们会仔细了解同步和异步
whr.Open(&amp;quot;GET&amp;quot;, &amp;quot;https://autohotkey.com/download/1.1/version.txt&amp;quot;, true)
whr.Send()
whr.WaitForResponse()
version := whr.ResponseText
MsgBox, % version
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就可以用 MsgBox 将从网络获取到的一个字符串弹出来了。但比起 UrlDownloadToFile 还是麻烦了不少，如果需要经常使用，还是很不方便的，这就需要封装成一个函数来使用，比如这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UrlDownloadToVar(url)
{
    static whr := ComObjCreate(&amp;quot;WinHttp.WinHttpRequest.5.1&amp;quot;)
    whr.Open(&amp;quot;GET&amp;quot;, url, true)
    whr.Send()
    whr.WaitForResponse()
    return whr.ResponseText
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和刚才的代码差不多，但我这里 whr 是 static 类型的，因为只需要初始化一次就可以了，调用 ComObjCreate() 是有开销的。&lt;/p&gt;
&lt;p&gt;但有些时候我们并不只需要传入一个 URL，可以还包含一些 HTTP Headers，而且使用 POST 方式访问，这就需要再改造下这个函数，比如这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UrlDownloadToVar(url, headers = &amp;quot;&amp;quot;)
{
    static whr := ComObjCreate(&amp;quot;WinHttp.WinHttpRequest.5.1&amp;quot;)
    whr.Open(&amp;quot;POST&amp;quot;, url, true)

    if (headers != &amp;quot;&amp;quot;)
    {
        for key, value in headers
        {
            whr.SetRequestHeader(key, value)
        }
    }

    whr.Send()
    whr.WaitForResponse()
    return whr.ResponseText
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用起来也很方便，比如我要使用 POST 方式访问 test.org，携带两个 HTTP Headers，key1:value1 和 key2:value2：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;result := UrlDownloadToVar(&amp;quot;http://test.org&amp;quot;
    , { &amp;quot;key1&amp;quot; : &amp;quot;value1&amp;quot;, &amp;quot;key2&amp;quot; : &amp;quot;value2&amp;quot; })
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果需要设置更多参数，比如超时时间，就需要查下 WinHttp.WinHttpRequest.5.1 的文档了，基本上都可以找到自己想要的功能。&lt;/p&gt;</content></entry><entry><title>[基础] 如何在 AHK 中判断空字符串</title><link href="/ji-chu-ru-he-zai-ahk-zhong-pan-duan-kong-zi-fu-chuan.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ru-he-zai-ahk-zhong-pan-duan-kong-zi-fu-chuan.html</id><summary type="html">&lt;p&gt;上一篇文章我们了解到了如何在 AHK 中比较字符串，但有一个细节我故意忽略了，也就是如何判断一个字符串是否为空（或者说一个变量是否为空，AHK 中空变量、空字符串和未定义变量是一回事）。按理说这应该是一个很简单的问题，一笔带过即可，无需单独写一篇文章来介绍。对其他语言也许是这样，但 AHK 在这个问题上存在一些麻烦，值得一提。&lt;/p&gt;
&lt;h2&gt;常规的字符串判空&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;&amp;quot;

; 方法一：
; = 也可替换成 ==，因为空字符串无大小写问题，不赘述
if (a = &amp;quot;&amp;quot;)
{
    ; 条件成立
}

; 方法二：
if (a)
{
    ; 做正常的事情
}
else
{
    ; 条件成立
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法一就是其他编程语言中的方法，无需过多解释。方法二是一种简化的写法，在多数情况看起来也是正常的，但存在一些特殊情况。&lt;/p&gt;
&lt;h2&gt;特殊情况一：数字 0&lt;/h2&gt;
&lt;p&gt;在一些特殊情况，方法二存在问题。&lt;/p&gt;
&lt;p&gt;如果变量为字符串 "0"，或者整数 0，或者浮点数 0.0：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;上一篇文章我们了解到了如何在 AHK 中比较字符串，但有一个细节我故意忽略了，也就是如何判断一个字符串是否为空（或者说一个变量是否为空，AHK 中空变量、空字符串和未定义变量是一回事）。按理说这应该是一个很简单的问题，一笔带过即可，无需单独写一篇文章来介绍。对其他语言也许是这样，但 AHK 在这个问题上存在一些麻烦，值得一提。&lt;/p&gt;
&lt;h2&gt;常规的字符串判空&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;&amp;quot;

; 方法一：
; = 也可替换成 ==，因为空字符串无大小写问题，不赘述
if (a = &amp;quot;&amp;quot;)
{
    ; 条件成立
}

; 方法二：
if (a)
{
    ; 做正常的事情
}
else
{
    ; 条件成立
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法一就是其他编程语言中的方法，无需过多解释。方法二是一种简化的写法，在多数情况看起来也是正常的，但存在一些特殊情况。&lt;/p&gt;
&lt;h2&gt;特殊情况一：数字 0&lt;/h2&gt;
&lt;p&gt;在一些特殊情况，方法二存在问题。&lt;/p&gt;
&lt;p&gt;如果变量为字符串 "0"，或者整数 0，或者浮点数 0.0：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;0&amp;quot;
; 或者
; a := 0
; 或者
; a := 0.0

; 方法一：
; = 也可替换成 ==，因为空字符串无大小写问题，不赘述
if (a = &amp;quot;&amp;quot;)
{
    ; 条件不成立
}

; 方法二：
if (a)
{
    ; 做正常的事情
}
else
{
    ; 条件成立，判断错误
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;恐怕没有人认为一个长度为一的字符串 "0" 是空字符串。但第二种方法给出了错误的结果。原因是 0 被认为是布尔值 false，而且 AHK 中的字符串和数字并没有那么确切的区别，很多情况可以自动相互转换，直接用 if 判断自然不通过，看来这个简化还是要不得。&lt;/p&gt;
&lt;h2&gt;特殊情况二：Object()&lt;/h2&gt;
&lt;p&gt;还有一种特殊情况是空对象 Object()。通常来说，我们不应该认为 Object() 是空变量，但某些库的作者可能不严谨，在本应返回空变量的地方返回了 Object()（我印象中遇到过这样的问题，但今天没有复现出来，如果以后发现了再举例）。如果用方法一判断，就可能出问题。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := Object()

; 方法一
; = 也可替换成 ==，因为空字符串无大小写问题，不赘述
if (a = &amp;quot;&amp;quot;)
{
    ; 条件不成立
}

; 方法三
if (StrLen(a) = 0)
{
    ; 条件成立
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法一认为 Object() 不是空变量，那么继续将 a 传递下去处理，就可能出问题。方法三是调用 StrLen() 函数来检查字符串的长度，它成功发现了这不是一个有效的字符串。&lt;/p&gt;
&lt;p&gt;但用 StrLen() 函数判断也存在问题，一个很严重的问题是方法三的耗时要比方法一长一倍以上。因为调用函数需要一些额外开销，在几乎所有语言都是如此。如果这个判断在一个很大的循环里边，额外的开销是很大的。&lt;/p&gt;
&lt;p&gt;另外 Object() 是否算空变量或者空字符串，这其实是有争议的。我个人是认为不应该算，但在某些语言中，所有变量类型都是从 Object 类型继承来的，那么就应该算。在用一些库时，还是需要验证一下是否存在 Object() 的问题，以免以后出了问题没有头绪。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;通常情况，用方法一判断空字符串或者空变量就足够了，简单易懂。在某些特殊情况，可能需要用方法三来判断，但要付出额外的开销。另外本文可能还有一些细节没有提到，我想起来后再补充。&lt;/p&gt;</content></entry><entry><title>[基础] 如何在 AHK 中运行其他软件</title><link href="/ji-chu-ru-he-zai-ahk-zhong-yun-xing-qi-ta-ruan-jian.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ru-he-zai-ahk-zhong-yun-xing-qi-ta-ruan-jian.html</id><summary type="html">&lt;p&gt;前几篇文章讲的都是 AHK 的语法，比较枯燥，这篇文章的内容更实用一些。很多情况我们使用 AHK，并不是为了写一个功能完备软件，而是写一个简单的脚本来和其他软件交互，这就涉及到如何在 AHK 中运行其他软件。本文重点讲 Run 命令的基本用法，其他高级内容之后的文章会依次提及。&lt;/p&gt;
&lt;h2&gt;启动软件&lt;/h2&gt;
&lt;p&gt;使用 AHK 的经典场景，就是用一个热键启动一个软件，比如用 Win + n 启动记事本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#n::
    Run, notepad
return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里就不详细讲绑定热键的语法了，因为相关资料特别多，而且我以后会单独介绍热键相关的内容。重点看 Run, notepad，这条语句就是启动记事本，因为记事本软件的文件名是 notepad.exe，是不是非常简单。但 Run 命令也并非简单到只支持一个参数，它的用法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, Target [, WorkingDir, Max|Min|Hide …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;前几篇文章讲的都是 AHK 的语法，比较枯燥，这篇文章的内容更实用一些。很多情况我们使用 AHK，并不是为了写一个功能完备软件，而是写一个简单的脚本来和其他软件交互，这就涉及到如何在 AHK 中运行其他软件。本文重点讲 Run 命令的基本用法，其他高级内容之后的文章会依次提及。&lt;/p&gt;
&lt;h2&gt;启动软件&lt;/h2&gt;
&lt;p&gt;使用 AHK 的经典场景，就是用一个热键启动一个软件，比如用 Win + n 启动记事本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#n::
    Run, notepad
return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里就不详细讲绑定热键的语法了，因为相关资料特别多，而且我以后会单独介绍热键相关的内容。重点看 Run, notepad，这条语句就是启动记事本，因为记事本软件的文件名是 notepad.exe，是不是非常简单。但 Run 命令也并非简单到只支持一个参数，它的用法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, Target [, WorkingDir, Max|Min|Hide|UseErrorLevel, OutputVarPID]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Target 可以是可执行文件的文件名，如上边的 notepad，可以加参数，也可以是一些其他东西，后文会具体讲到。WorkingDir 用来指定工作目录，比如我想在 C 盘根目录运行记事本并打开 test.txt，就可以这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, notepad test.txt, C:\
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第三个参数 Max|Min|Hide|UseErrorLevel 是选项，可以让运行的软件最大化（Max），最小化（Min），隐藏（Hide），UseErrorLevel 用于获取进程退出的返回码，暂时用不到，以后再讲。&lt;/p&gt;
&lt;p&gt;第四个参数 OutputVarPID 用来获取进程的 PID，暂时也用不到。&lt;/p&gt;
&lt;p&gt;需要注意的一点，用 Run 启动其他软件后，AHK 代码会继续执行，而不会等软件退出。如果需要等软件退出再继续运行，需要用 RunWait 命令，这个后续我也会提到。&lt;/p&gt;
&lt;h2&gt;打开网址&lt;/h2&gt;
&lt;p&gt;Run 后边除了加可执行文件，还可以直接加网址，这样就不要到处找浏览器的安装位置了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 网址前边需要加 http:// 或 https://，以便让 AHK 知道这是一个网址
Run, https://autohotkey.com
; 如果网址是以 www. 开头的，也可以省略 http:// 或 https://
Run, www.autohotkey.com
; 错误用法，AHK 会尝试在本地找 autohotkey.com 文件，如果找不到就会报错
Run, autohotkey.com
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;其他用法&lt;/h2&gt;
&lt;p&gt;除了启动进程和打开网址，Run 还有一些其他用法。&lt;/p&gt;
&lt;p&gt;打开文件。当 Run 后边直接接非可执行文件时，效果也是打开文件。打开文件所使用的软件，是在资源管理器关联的默认软件，可以在资源管理器中选定文件，右键菜单-&amp;gt;属性 里更改打开方式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, open C:\test.txt
; open 可以省略
Run, C:\test.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编辑文件。效果同在资源管理器选定文件，右键菜单-&amp;gt;编辑，通常是用记事本打开。如果右键菜单里没有“编辑”菜单项，会报错。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, edit C:\test.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用资源管理器打开文件夹，需要加文件夹的路径。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, explore C:\
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看文件属性，效果同在资源管理器选定文件，右键菜单-&amp;gt;属性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, properties C:\test.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用资源管理器打开文件夹，并进入搜索模式，以便查找文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, find C:\
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印文件，效果同在资源管理器选定文件，右键菜单-&amp;gt;打印，如果无“打印”菜单项，会报错。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, print C:\test.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用资源管理器打开 CLSID 文件夹，CLSID 文件夹是由系统定义的一批特殊文件夹，名字是一串“神秘数字”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 打开我的文档文件夹
Run, ::{450d8fba-ad25-11d0-98a8-0800361b1103}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;常用 CLSID 文件夹列表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;CLSID&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td 20d04fe0-3aea-1069-a2d8-08002b30309d&gt;::&lt;/td&gt;
&lt;td&gt;我的电脑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td 450d8fba-ad25-11d0-98a8-0800361b1103&gt;::&lt;/td&gt;
&lt;td&gt;我的文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td 645ff040-5081-101b-9f08-00aa002f954e&gt;::&lt;/td&gt;
&lt;td&gt;回收站&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td 208d2c60-3aea-1069-a2d7-08002b30309d&gt;::&lt;/td&gt;
&lt;td&gt;网上邻居&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td 7007acc7-3202-11d1-aad2-00805fc1270e&gt;::&lt;/td&gt;
&lt;td&gt;网络连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td 2227a280-3aea-1069-a2de-08002b30309d&gt;::&lt;/td&gt;
&lt;td&gt;打印机和传真&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;关于空格和引号&lt;/h2&gt;
&lt;p&gt;如果文件名、路径名或者参数中包含空格，是需要特别注意的。&lt;/p&gt;
&lt;p&gt;Run 后边加的文件路径是可以包含空格的，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, c:\Program Files\Oracle\VirtualBox\VirtualBox.exe
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Program Files 里包含一个空格，但 Run 不会将 c:\Program 视为文件名，将 Files\Oracle\VirtualBox\VirtualBox.exe 视为参数。但如果之后再加参数就要小心了，谨慎起见，需要对每一个参数单独加上双引号。&lt;/p&gt;
&lt;p&gt;虽然在某些情况不加也可以工作，比如这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, notepad aa bb.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会用记事本打开一个名为 aa bb.txt 的文件。&lt;/p&gt;
&lt;p&gt;但也可能出问题，比如这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, c:\mine\app\AutoHotkey\AutoHotkey.exe aa bb.ahk
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;AutoHotkey.exe 提示 aa 文件不存在，而实际我想运行的文件为 aa bb.ahk。同样的语法，效果却不同，区别在于要运行的软件是如何解析参数的。&lt;/p&gt;
&lt;p&gt;如果在参数两边加上引号，就没有这样的问题了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, notepad &amp;quot;aa bb.txt&amp;quot;

Run, c:\mine\app\AutoHotkey\AutoHotkey.exe &amp;quot;aa bb.ahk&amp;quot;

; 后边可以再加参数，但包含空格的参数都要有引号。
Run, c:\mine\app\AutoHotkey\AutoHotkey.exe &amp;quot;aa bb.ahk&amp;quot; &amp;quot;arg 1&amp;quot; &amp;quot;arg 2&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;等待软件退出再继续运行&lt;/h2&gt;
&lt;p&gt;用 Run 命令启动软件的话，AHK 并不会等软件退出后才继续运行，在运行图形界面软件时，这也是我们通常的做法。如果我们需要让 AHK 暂停，直到运行起来的软件退出才继续，可以用 RunWait 命令取代 Run，除了这个区别，用法上和 Run 是一致的。&lt;/p&gt;
&lt;h2&gt;其他内容&lt;/h2&gt;
&lt;p&gt;除了将软件运行起来，很多时候我们也有一些其他需求。比如获取软件的输出（通常是命令行软件的输出，如 ipconfig），获取软件的退出码，获取软件进程的 PID 等等，我会在后续文章中详细讲到。&lt;/p&gt;</content></entry><entry><title>进入 WSL 环境的多种方法比较</title><link href="/jin-ru-wsl-huan-jing-de-duo-chong-fang-fa-bi-jiao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/jin-ru-wsl-huan-jing-de-duo-chong-fang-fa-bi-jiao.html</id><summary type="html">&lt;p&gt;Windows 10 中包含了一个 WSL（Windows Subsystem for Linux）子系统，我们可以在其中运行未经修改过的原生 Linux ELF 可执行文件。利用它我们可以做很多事情，对开发人员和普通用户都是如此。当然对开发人员的吸引力更大一些，因为这意味着在一些情况，不再需要使用 Linux 虚拟机、双系统、Cygwin/MSYS2 了。&lt;/p&gt;
&lt;p&gt;当前版本（14901.1000）Windows 10 中的 WSL 功能已经比较完善了，和刚出来时不可同日而语，也不再是一个没有实用价值的玩具了（最初的版本连 zsh 和 tmux 等最基本的工具都无法运行，基本没有可用性。但如果现在依然说 WSL 不可用，就有失偏颇了）。但对不想折腾的普通用户来说，用户体验并不好。其实我们可以做一些优化，最终效果是在仅损失少量可接受的代价的前提下，达到接近完美的体验。本文主要将进入 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Windows 10 中包含了一个 WSL（Windows Subsystem for Linux）子系统，我们可以在其中运行未经修改过的原生 Linux ELF 可执行文件。利用它我们可以做很多事情，对开发人员和普通用户都是如此。当然对开发人员的吸引力更大一些，因为这意味着在一些情况，不再需要使用 Linux 虚拟机、双系统、Cygwin/MSYS2 了。&lt;/p&gt;
&lt;p&gt;当前版本（14901.1000）Windows 10 中的 WSL 功能已经比较完善了，和刚出来时不可同日而语，也不再是一个没有实用价值的玩具了（最初的版本连 zsh 和 tmux 等最基本的工具都无法运行，基本没有可用性。但如果现在依然说 WSL 不可用，就有失偏颇了）。但对不想折腾的普通用户来说，用户体验并不好。其实我们可以做一些优化，最终效果是在仅损失少量可接受的代价的前提下，达到接近完美的体验。本文主要将进入 WSL 环境的多种方式，以及简单比较不同方式之间的优缺点。&lt;/p&gt;
&lt;h2&gt;直接运行 bash&lt;/h2&gt;
&lt;p&gt;最简单直接的方法是 &lt;code&gt;Win + R&lt;/code&gt; 输入 bash 直接进入。但这样右键（很可能）不可用，复制粘贴很麻烦（需要在标题栏右键菜单中选择编辑）。而先进入 cmd 或者 powershell 后，再运行 bash，这样复制和粘贴进方便了很多。尤其是先进入 powershell 再运行 bash，可以鼠标选择复制，右键直接粘贴。我们可以直接 &lt;code&gt;Win + R&lt;/code&gt; 输入 &lt;code&gt;powershell -c bash ~&lt;/code&gt; 进入。但从 powershell 进入会有额外的问题，一些程序的显示可能会出现异常。&lt;/p&gt;
&lt;p&gt;直接运行 bash 的好处是性能最好，资源占用最低，交互（比如在资源管理器打开 bash 并定位到当前目录，或者直接双击 .sh 脚本用 bash 运行等）也更容易实现。但有一个严重的问题，就是无法输入中文，显示中文也会出现重叠或者截断的情况。此外还有复制粘贴麻烦，而且只支持 16 种颜色等问题。可定制性也很弱，这样的终端用户体验上很差的。如果只给我这样一个环境使用，即使所有的 Linux 软件都能正常运行，我也是没办法接受的。这恐怕也是 WSL 最让人诟病的地方，第一印象就不是很好。&lt;/p&gt;
&lt;h2&gt;使用 wsl-terminal&lt;/h2&gt;
&lt;p&gt;wsl-terminal 是专门为 WSL 准备的终端模拟器，主体是 mintty，另外整合了一些工具，使用起来非常方便，也是目前用户体验最好的，大小也只有 1M 多，推荐使用。使用方法见官方主页，地址：https://github.com/goreliu/wsl-terminal。 &lt;/p&gt;
&lt;p&gt;实现方面，这个方法是由在 WSL 里启动 sshd，然后使用 ssh 客户端登录的方法改进的。它的运行机制和 ssh 有很大的的区别。mintty 会运行 wslbridge，wslbridge 包含两个程序，wslbridge.exe 和 wslbridge-backend。从文件名可以看出来，前者是 Windows 程序，后者是 Linux 程序。wslbridge.exe 会在一个隐藏窗口运行 bash.exe 进入 WSL 环境，在其中运行相同目录下的 wslbridge-backend。wslbridge.exe 和 wslbridge-backend 之间会建立三个 tcp 连接，也就是将 stdin、stdout、stderr 分别通过三个 tcp 连接联系起来，连接建立后就不再监听任何端口了。而 mintty 就是一个终端模拟器，对它来说 wslbridge 和 ssh 没有什么区别。&lt;/p&gt;
&lt;p&gt;性能上，在我这里用 wslbridge 和 ssh 执行命令的速度是差不多的，前者稍微快一点，不明显。资源占用上，前者占优。&lt;/p&gt;
&lt;p&gt;使用的方便程度上，明显 wslbridge 占优。不再需要启动 sshd，配置信任关系等。另外 wslbridge 会自动将当前路径传递进去，不需要自己转换路径然后拼接 cd 命令，这样方便了许多。而且可以直接通过参数传递环境变量。我之前写的几个脚本减少了数十行。&lt;/p&gt;
&lt;h2&gt;使用 ConEmu 等终端模拟器&lt;/h2&gt;
&lt;p&gt;ConEmu（包括基于 ConEmu 修改的 cmder） 等终端模拟器也已经开始适配 WSL 环境，使用它复制粘贴更加方便（可以鼠标选择时直接复制，右键直接粘贴），也能输入中文了。但中文显示还是有问题（但比直接运行 bash.exe 要好一些），比如一个中文字符要比两个英文字符宽（在 vim 等地方），输入中文然后退格删除会删除到前边的字符（在 bash、zsh 等地方）。另外 ConEmu 更漂亮，界面上的功能更多（比如支持标签页，可以配置很多东西等）。除此之外和直接运行 bash 是一样的，比如颜色支持上。另外这个环境对 Linux 命令输出显示的兼容性不如直接运行 bash，某些命令的输出是有问题的（比如 top 命令中的反色显示会丢失）。&lt;/p&gt;
&lt;p&gt;另外和 ConEmu 类似的是使用 Cygwin/MSYS2 的 mintty -e winpty bash。这个和 ConEmu 的问题类似，中文显示输入、颜色等地方同样存在问题。并且我实际测试时发现 mintty -e winpty bash 比 mintty -e ssh 127.0.0.1 还要慢，基本上没有什么优势。winpty 和 wslbridge 是同一个人写的，不需要考虑使用 winpty 了。&lt;/p&gt;
&lt;h2&gt;在 WSL 中开启 sshd，ssh 上去使用&lt;/h2&gt;
&lt;p&gt;（和 mintty + wslbridge 相比，在本机访问的话，ssh 基本上已经没有什么优势了。把 Cygwin/MSYS2 裁剪成 ssh 客户端，也不需要折腾了，相关内容我就不删了。） &lt;/p&gt;
&lt;p&gt;还有一种办法是在 WSL 中开启 sshd，使用 ssh 客户端登录上去使用，就像使用本地 Linux 虚拟机或者 VPS 那样。&lt;/p&gt;
&lt;p&gt;目前 ssh 上去的环境是没有任何问题的，包括中文显示输入、颜色、命令输出等。但这样也有一些问题，比如需要一个常驻的 sshd（可以使用更轻量级的 dropbear），并且使用起来不是很方便，尤其是在涉及交互的场景（比如在资源管理器创建一个 .sh 脚本，然后用 WSL 执行），需要写若干辅助的脚本。启动速度也比直接运行 bash 要慢，但如果选择轻量级的 ssh 客户端的话，使用起来还是比较容易接受的。&lt;/p&gt;
&lt;p&gt;在 ssh 客户端的选择上，首先如果不是一直开着，secureCRT、XShell 之类比较重量级的 ssh 客户端是不大合适了，启动比较慢，体积比较大，资源占用也多，有点大材小用了。PuTTY 是一个选择，在启动速度、资源占用、文件体积上都比较出色，但功能上就存在一些问题。比如我想在资源管理器任意一个目录运行 PuTTY，并且在 WSL 中定位到当前目录，或者执行一个临时拼凑出的命令，就比较难实现（也不是完全实现不了，比如可以每次都修改一次注册表，或者通过临时文件传递路径和命令）。另外 PuTTY 的官方版本不支持 24-bit 颜色，虽然有其他版本支持，但 PuTTY 的修改版很混乱，很难找一个各方面都很出色的版本。PuTTY 的易用性也存在问题，比如会话的载入和保存功能，很多人都会在这上面吃亏，丢失了已经填好的配置，配置信任关系比较麻烦，，基本上不上网搜索是很难仅从设置界面看明白是怎么用的，加密方法的支持也不完善。&lt;/p&gt;
&lt;p&gt;其实还有一个容易被大家忽略的选择，是在 Cygwin/MSYS2 中的 mintty 使用 ssh。不过也难怪，安装 Cygwin 或者 MSYS2 都是比较麻烦的，而且至少会占用几百兆空间。但其实如果只裁剪一个最小的环境当成 ssh 客户端使用，仅需要不到 10M 的空间（压缩后只有 3M 左右，其中还包括了维护用的 dash、ls、cat、rm 等命令），比起 PuTTY 的 500K 自然大了不少，但比起 secureCRT、XShell 等还是要轻量级一些的。mintty 界面简洁，配置方便，中文显示输入、颜色支持上没有任何问题。更重要的是直接用 ssh 命令非常灵活，可以临时拼凑命令然后执行， 使用和 Linux 下相同的方式建立信任关系等。并且 mintty 启动快，资源占用少，虽然每次都要运行 ssh 登陆，但速度也是可以接受了。不支持标签页的问题，可以用在 WSL 里运行 tmux 来解决，这样启动 mintty 还会更快一些，而且 mintty 退出后环境还在保持。&lt;/p&gt;
&lt;p&gt;裁剪 Cygwin/MSYS2 的办法：&lt;/p&gt;
&lt;p&gt;这里以 MSYS2 为例，简单讲下如何把几百兆的 MSYS2 裁剪成不到 10M 的 ssh 客户端。&lt;/p&gt;
&lt;p&gt;安装 MSYS2 后，用 &lt;code&gt;pacman -S openssh&lt;/code&gt; 安装 openssh，其他的基本不需要额外安装了。&lt;/p&gt;
&lt;p&gt;然后再另一个目录（这里以 &lt;code&gt;c:\sshclient&lt;/code&gt; 为例，这个目录在哪不重要，使用的时候是可以随意移动的）下创建 5 个目录：dev、etc、tmp、usr、home。&lt;/p&gt;
&lt;p&gt;将 MSYS2 中 &lt;code&gt;/etc/passwd&lt;/code&gt; 文件放置到 &lt;code&gt;c:\sshclient\etc&lt;/code&gt; 下，可以修改下这个文件，只保留直接当前使用的用户名，shell 也改成自己用的 shell（比如最轻量的 dash），home 目录也设置好。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;c:\sshclient\usr&lt;/code&gt; 目录下创建 &lt;code&gt;bin&lt;/code&gt;，然后把 MSYS2 中 &lt;code&gt;/usr/bin&lt;/code&gt; 里的这些文件复制过去：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cat.exe
cygwin-console-helper.exe
dash.exe
ls.exe
mintty.exe
msys-2.0.dll
msys-asn1-8.dll
msys-com_err-1.dll
msys-crypt-0.dll
msys-crypto-1.0.0.dll
msys-gcc_s-seh-1.dll
msys-gssapi-3.dll
msys-heimbase-1.dll
msys-heimntlm-0.dll
msys-hx509-5.dll
msys-iconv-2.dll
msys-intl-8.dll
msys-krb5-26.dll
msys-roken-18.dll
msys-sqlite3-0.dll
msys-ssp-0.dll
msys-wind-0.dll
msys-z.dll
rm.exe
ssh.exe
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要记的只有 mintty.exe、ssh.exe、dash.exe、cygwin-console-helper.exe，这些 dll 文件可以根据错误提示来拷贝，其他命令根据自己的喜好。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;c:\sshclient\home\username\.ssh&lt;/code&gt; 里写好 ssh 的配置文件，就大功告成了。运行 mintty，输入 /usr/bin/ssh 127.0.0.1 即可。但要想好用还需要写一些额外的工具，比如用右键菜单在指定的目录打开 、将 .sh 脚本的打开方式改成 mintty、用 WSL 里的 vim 编辑资源管理器中选定的文件等。&lt;/p&gt;
&lt;p&gt;最后截图纪念一下。显示的是 Arch Linux 系统，因为我把默认的 Ubunt 14.04 的文件全部换成 Arch Linux 的了，而且运行良好（安装方式：https://github.com/Microsoft/BashOnWindows/issues/8#issuecomment-240026910）。另外可以注意到左下角的窗口，wcmd 可以直接运行 Windows 的 ipconfig 命令，这得益于 &lt;a href="https://github.com/xilun/cbwin"&gt;cbwin&lt;/a&gt; 项目，虽然是使用的是在 Windows 运行一个守护进程，监听 127.0.0.1 的某一个端口，然后 WSL 中的 wcmd、wrun、wstart 命令通过 TCP 发送命令和采集结果，速度上还是可以接受的，运行命令或者图形界面软件都没有问题。在微软官方没有支持在 WSL 里直接运行 Windows 软件的情况下，是一个不错的替代方式。它要明显比在 Windows 下开 SSH Server 要快，而且使用起来更方便。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/028.png"&gt;&lt;/p&gt;</content></entry><entry><title>《开启潜意识：看透你未知的心》读书笔记</title><link href="/kai-qi-qian-yi-shi-kan-tou-ni-wei-zhi-de-xin-du-shu-bi-ji.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/kai-qi-qian-yi-shi-kan-tou-ni-wei-zhi-de-xin-du-shu-bi-ji.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这本书的书名不是很能体现内容，而且过于大众化，容易被人忽略。书中讲了60个类似禅宗的小故事，当故事书来看自然是不错，但如果要想从中获得真正有用的东西，恐怕也不是那么容易。故事虽然简短，每个人的解读却不同，如果正好符合自己的处境，也未必不能解决大问题。&lt;/p&gt;
&lt;p&gt;本文选取了其中少量有趣的故事与大家分享。&lt;/p&gt;
&lt;h3&gt;墓碑上的闪光时刻：你确定自己在活吗？&lt;/h3&gt;
&lt;p&gt;这个故事的背景是一位年近30岁的公司职员，学的专业是计算机，现在在一家IT公司工作。他不喜欢自己的工作，觉得每一天都充满压力，包括工作上的，还有理想与显示的差距。他很喜欢外出旅游，而且会带上自己最喜欢的相机。不用说，这样的人非常多。&lt;/p&gt;
&lt;p&gt;这个故事是比较荒诞的，一个年轻人去某个地方旅游，发现很多墓碑。奇怪的是墓碑上的寿命非常小，2岁、3岁、1岁3个月，甚至还有不到一年的。他非常困惑，终于在附近村庄里一个老者口中得到真相。原来这里的人记载寿命的方式与众不同，不是看他真正活了多久，而是看他一生中闪光时刻加在一起有多长。闪光时刻是什么呢？比如肆无忌惮地放生大笑，体会到生命是那样的幸福美好，突然有了智慧知道自己在做什么，等等。而这里的人把闪光时刻当成真正的寿命。&lt;/p&gt;
&lt;p&gt;这个故事的用意非常明显，就是针对那些日复一日做着相似的事情，毫无激情混日子，或者是余生不多的重症患者。强调生命的宽度 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这本书的书名不是很能体现内容，而且过于大众化，容易被人忽略。书中讲了60个类似禅宗的小故事，当故事书来看自然是不错，但如果要想从中获得真正有用的东西，恐怕也不是那么容易。故事虽然简短，每个人的解读却不同，如果正好符合自己的处境，也未必不能解决大问题。&lt;/p&gt;
&lt;p&gt;本文选取了其中少量有趣的故事与大家分享。&lt;/p&gt;
&lt;h3&gt;墓碑上的闪光时刻：你确定自己在活吗？&lt;/h3&gt;
&lt;p&gt;这个故事的背景是一位年近30岁的公司职员，学的专业是计算机，现在在一家IT公司工作。他不喜欢自己的工作，觉得每一天都充满压力，包括工作上的，还有理想与显示的差距。他很喜欢外出旅游，而且会带上自己最喜欢的相机。不用说，这样的人非常多。&lt;/p&gt;
&lt;p&gt;这个故事是比较荒诞的，一个年轻人去某个地方旅游，发现很多墓碑。奇怪的是墓碑上的寿命非常小，2岁、3岁、1岁3个月，甚至还有不到一年的。他非常困惑，终于在附近村庄里一个老者口中得到真相。原来这里的人记载寿命的方式与众不同，不是看他真正活了多久，而是看他一生中闪光时刻加在一起有多长。闪光时刻是什么呢？比如肆无忌惮地放生大笑，体会到生命是那样的幸福美好，突然有了智慧知道自己在做什么，等等。而这里的人把闪光时刻当成真正的寿命。&lt;/p&gt;
&lt;p&gt;这个故事的用意非常明显，就是针对那些日复一日做着相似的事情，毫无激情混日子，或者是余生不多的重症患者。强调生命的宽度，而不是生命的长度。那些想着等自己有了什么什么就可以怎样了（比如等自己有钱了就可以怎样了，等自己退休了就可以怎样了）之类的想法的人，可以仔细考虑下了。&lt;/p&gt;
&lt;p&gt;但这个故事也是有致命的问题的。人活着的一生真的就为了那些闪光时刻吗？故事中也提到这些闪光时刻必定是少数，5年已经是长到不可想象了。那难道其余的大多数时间都是用来做陪衬的吗？这个显然需要读者自己思考了。&lt;/p&gt;
&lt;h3&gt;断指决策&lt;/h3&gt;
&lt;p&gt;这个故事比较震撼。内容是如果你有三个选择（每个选择都是放弃一个非常舍不得的东西，其他选择也可以类比），长时间犹豫不决不知道如何取舍，可以这样假想。伸出三个手指，每个手指代表一个选择（会被砍掉）。然后需要迅速决定需要怎么选择，如果不能马上决定，后果就是三个手指会被同时砍掉。你会如何选择？&lt;/p&gt;
&lt;p&gt;这个故事的用意是把本来比较抽象的选择和肉体直接关联起来，这样会触及内心最深处的价值观。我们难以做决定往往是因为我们只用头脑，让情绪、评判、患得患失阻止内心深处真正的选择，而和自己的肢体建立联系后，会让自己内心直觉迅速、高效地做出决定。&lt;/p&gt;
&lt;p&gt;但是这个方法真的管用吗？我想对于某些人是的，另一些人则未必。而且得到的结果真的是最优的吗，也未必。但遇到如此纠结的选择而走投无路的情况倒也不妨试试，至少长痛不如短痛。&lt;/p&gt;
&lt;h3&gt;失恋的年轻人：接受的本质是允许&lt;/h3&gt;
&lt;p&gt;这个故事比较大众化。说的是一个二十多岁的小伙子恋爱8年的女朋友和一个所谓成功而且是有家室的男人走了，他很沮丧。但他说不是不能接受，只是不知道她为什么要找一个年纪比她大那么多并且有家室的男人。而实际上看似已经接受的他并没有真正接受，只是把痛苦压到内心的更深处，这样反而更加糟糕。他不肯接受事实，不惜自己欺骗自己。而真正接受之前肯定是要首先正视事实的，把压在内心深处的痛苦释放出来。不接受吗？不接受就对了，换成其他任何人也不会那么轻易接受。但一旦接受了“自己不接受”，实际离真正接受就很近了。允许自己痛苦，才有远离痛苦。&lt;/p&gt;
&lt;p&gt;这个故事没有前两个那么好理解，因为这涉及到一个悖论。而类似的悖论在人生中是处处可见的，而且不经历痛苦是很难体会到的。所以说这个故事的字面意思并不大，唯有一个人真正经历类似的事情，才会领悟。&lt;/p&gt;
&lt;h3&gt;核桃、大米和水：生命是一只空碗&lt;/h3&gt;
&lt;p&gt;这个故事是一个老掉牙故事的改进版，倒是有些许新意。&lt;/p&gt;
&lt;p&gt;原始的故事是老禅师把核桃放满到一个碗里，问小徒弟碗是否满了，得到肯定答案后有以此放了大米、水和盐进去。而改进的是后半部分，如果一个碗已经被水和盐填满了，还可以放进去更大（更重要）的核桃吗？&lt;/p&gt;
&lt;p&gt;这个故事用意很明显，如果内心深处已经被诸如水和盐的小事填满了，就没有地方容纳更大的核桃了。&lt;/p&gt;
&lt;h3&gt;四个小天鹅：一念四转&lt;/h3&gt;
&lt;p&gt;这个故事实质也是做选择的一个方法，即做一个犹豫不决的决策时，分别考虑这四种情况：
1. 假设你不作改变，会发生什么？
2. 假设你作了改变，会发生什么？
3. 假设你不作改变，不会发生什么？
4. 假设你作了改变，不会发生什么？&lt;/p&gt;
&lt;p&gt;其实就是所有可能的情况，这样分别考虑会比全放在一起纠缠不清好些。&lt;/p&gt;
&lt;h3&gt;墙上的黑点：别让你的念头骗了&lt;/h3&gt;
&lt;p&gt;这个故事是某种古老故事的改版。一个人找作者说最近经常冒出一些自杀的念头，感觉非常害怕，不知道如何解决。作者开了个玩笑，说对面的木纹墙壁上有一个非常大的黑点，而实际上黑点非常小，而且非常多，只有靠得很近才可以看清楚。而自杀的念头就像这无数黑点中的一个一样，完全不需要过多在意。&lt;/p&gt;
&lt;p&gt;这个故事比较平淡，是否有用，也看读者的处境了。&lt;/p&gt;
&lt;h3&gt;穿越时空的提问：拓展10年的视角&lt;/h3&gt;
&lt;p&gt;又是一个作选择的方法，其实是10-10-10方法的简化版。简而言之，面对自己一时犹豫不决的选择，想象已经过去10年了，然后回想自己10年前做了一个怎样的决定，直到今天还没有后悔。&lt;/p&gt;
&lt;p&gt;该方法的目的是把看问题的视角从现在直接转移到10年后，以摆脱现在种种影响选择的细枝末节。&lt;/p&gt;
&lt;h3&gt;相信一头牛：你是否完全信任过？&lt;/h3&gt;
&lt;p&gt;这个故事比较有意思。一个家庭富裕的农夫，去向智者请教，因为平时非常焦虑，心里憋着很多话找不到人沟通，如何获得幸福。智者的方法是让他找一个完全信任的东西，结果是一头牛。农夫回去照做了，全心全意对待那头牛，每天和它沟通半个时辰，果然收获了幸福。然后作者又续了个结尾，有一天智者遇到了农夫，了解了情况后把牛杀了，说我让你无处信仰，你的信仰就不能独立存在了吗？&lt;/p&gt;
&lt;p&gt;故事前半段说的是信仰的力量，后半段说的是信仰可以不依托于他物，说实话衔接得不是那么好。而且这个故事是很可疑的，也就是说如果真的让一个人这么做，很可能不是按照故事的流程进行下去的。信仰的力量虽大，但建立一个强大的信仰并不是容易的事情，远远不是一头牛就可以轻易解决的。而且这样的信仰一旦建立起来，去毁灭信仰之物可是致命的，哪能如此儿戏？&lt;/p&gt;
&lt;p&gt;信仰在解决一些问题上固然有强大的优势，但并非没有代价，往往只建议其他方式已经解决不了问题的人使用信仰这个终极方法，并且必然承受其苦果。&lt;/p&gt;
&lt;h3&gt;小公主要月亮：答案在提问者那里&lt;/h3&gt;
&lt;p&gt;这个故事很新颖。一个国王有一个可爱小公主，有一天突然病倒了说想要月亮。国王愁坏了，问了很多人如何解决，直到有个小丑说公主要的月亮也许和我们想象的不同，需要问她月亮是什么样子的。果然公主说我伸出一个手指就可以把月亮挡住，所以比她的手指还小，而且看颜色是金子做的。&lt;/p&gt;
&lt;p&gt;就像题目说的，答案在提问者那里，如果去外部寻找，找到的只是别人的答案，而无法真正解决自己的问题。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;故事虽好，但还是需要注意一些问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个故事只在特定的上下文有效，比如只有一个人刚好处于那样的处境，这个故事才可以对症下药，解决问题，而其他情况也只是一个毫无价值的故事而已。&lt;/li&gt;
&lt;li&gt;故事不是万能的，它的作用非常有限。如果真的相信一个小故事就可以改变自己的一生，那真是大错特错了。宁可相信故事没用，也不要相信故事有用，不然会过得很惨。举个简单的例子，某人某天在路边捡到一个硬币（听到一个故事），发现非常不错，于是以后每天都低头走路以发现更多硬币（关注更多故事），当然这本身也是个故事，不必在意。&lt;/li&gt;
&lt;/ol&gt;</content></entry><entry><title>《灵态：使用指导手册》读书笔记</title><link href="/ling-tai-shi-yong-zhi-dao-shou-ce-du-shu-bi-ji.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ling-tai-shi-yong-zhi-dao-shou-ce-du-shu-bi-ji.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这是一本讲实践方法的书，没有任何理论的部分。但它比一些具有强烈洗脑性质的理论书籍还要危险，因为它将人带入了一个确定存在而大部分人却从不知道的另一个世界，仅需要几天时间。&lt;/p&gt;
&lt;h2&gt;目标读者&lt;/h2&gt;
&lt;p&gt;该书不建议任何读者阅读，因为它太危险了，它可以轻松毁掉一个人的生活。但介绍这本书的原因是它非常重要，如果用药来比喻，它更想像一味毒药，平时服用很可能有危险，而关键时候却可以救命。&lt;/p&gt;
&lt;p&gt;对现实世界非常失望，或者认为现实世界太没意义，有轻生倾向的人可以看这本书。而其他人基本上知道有这本书存在就可以了，以备不时之需。&lt;/p&gt;
&lt;h2&gt;另一个世界&lt;/h2&gt;
&lt;p&gt;最保守的说法，这另一个世界其实是梦，但和普通的梦不一样，在这个梦中，人是知道自己是在梦中的，更重要的是，这个梦可以比所谓的现实世界更加真实，在这个梦中，一个人可以做任何自己想做的事情。&lt;/p&gt;
&lt;p&gt;这对不同的人意义显然是不同的，对现实世界非常满意、感觉非常幸福的人，也许不会对这个世界有任何兴趣。但对于大部分其他的人，这个梦更像是一个非常有趣的游戏，如同电子游戏一般，可以用来消遣，排解在现实世界的压力等，但也很容易沉迷。还有一部分人，可能会认为比起现实世界，这个世界更加真实，而所谓的现实世界只是一个幻像，而处理不好的话这些人就会轻松毁掉自己的现实世界。&lt;/p&gt;
&lt;p&gt;很多的书提到过这样的世界，但从来没有一本书告诉你，想去这个世界体验一次不需要很麻烦，不需要少数人才有的天份，不需要复杂的技巧 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这是一本讲实践方法的书，没有任何理论的部分。但它比一些具有强烈洗脑性质的理论书籍还要危险，因为它将人带入了一个确定存在而大部分人却从不知道的另一个世界，仅需要几天时间。&lt;/p&gt;
&lt;h2&gt;目标读者&lt;/h2&gt;
&lt;p&gt;该书不建议任何读者阅读，因为它太危险了，它可以轻松毁掉一个人的生活。但介绍这本书的原因是它非常重要，如果用药来比喻，它更想像一味毒药，平时服用很可能有危险，而关键时候却可以救命。&lt;/p&gt;
&lt;p&gt;对现实世界非常失望，或者认为现实世界太没意义，有轻生倾向的人可以看这本书。而其他人基本上知道有这本书存在就可以了，以备不时之需。&lt;/p&gt;
&lt;h2&gt;另一个世界&lt;/h2&gt;
&lt;p&gt;最保守的说法，这另一个世界其实是梦，但和普通的梦不一样，在这个梦中，人是知道自己是在梦中的，更重要的是，这个梦可以比所谓的现实世界更加真实，在这个梦中，一个人可以做任何自己想做的事情。&lt;/p&gt;
&lt;p&gt;这对不同的人意义显然是不同的，对现实世界非常满意、感觉非常幸福的人，也许不会对这个世界有任何兴趣。但对于大部分其他的人，这个梦更像是一个非常有趣的游戏，如同电子游戏一般，可以用来消遣，排解在现实世界的压力等，但也很容易沉迷。还有一部分人，可能会认为比起现实世界，这个世界更加真实，而所谓的现实世界只是一个幻像，而处理不好的话这些人就会轻松毁掉自己的现实世界。&lt;/p&gt;
&lt;p&gt;很多的书提到过这样的世界，但从来没有一本书告诉你，想去这个世界体验一次不需要很麻烦，不需要少数人才有的天份，不需要复杂的技巧，只需要短短几天的事情，就可以做到，比做一盘好吃的菜还有容易很多。如果不是对现实世界特别满意，或者异常坚定的唯物主义者，谁会拒绝简单地这样尝试一下呢？&lt;/p&gt;
&lt;p&gt;而一旦尝试了一次，一些人形成了多年的世界观就很可能瞬间崩塌，另一些人找了一个新的探索世界的方法，只有少数人会无动于衷。&lt;/p&gt;
&lt;p&gt;这本书的危险在于，如果一个人还没有准备好接受这个世界，而贸然闯入了，效果通常不是积极的。他非常容易沉迷于这个世界，使得本就艰难的现实世界变得一塌糊涂。&lt;/p&gt;
&lt;p&gt;其实还有最后一点，这个现实世界和另一个世界并不是分开的，这本就是同一个世界，这一点的意味非常深长。&lt;/p&gt;
&lt;h2&gt;其他&lt;/h2&gt;
&lt;p&gt;其实也不必过于害怕这本书，真正可以接触到这本书的人，往往也是准备好的。而对这本书不排斥的话，就已经走到寻找世界真相的道路上了，当然类似的第一步有很多。需要注意的是这条道路并不平坦，充满了各种凶险而不确定的东西，而且一旦走上去就很难再回头了。&lt;/p&gt;
&lt;p&gt;另一个问题就是为什么要寻找世界的真相？&lt;/p&gt;
&lt;p&gt;多数人对世界的看法还停留在初中教科书上或者至少几百年前绝大多数人所处的阶段。他们中的很少数人或许对自己的生活很满意，感觉很幸福，对于他们，没有更多的东西是需要了解的（事实上他们已经在潜移默化中了解了足够多的东西了）。而更多的人几乎每天都逼迫自己做违背自己心愿的事情，很少真正思考也无法思考清楚自己为什么要做这些。他们自以为是为别人负责，实际上连什么是责任都搞不清楚，从来不真正为自己负责，而所谓的为别人负责只是将一个个其他人推向火坑里而不自知，生活的全部动力来自于想象中生活中的各种束缚产生的压力、账户里的余额、别人虚无缥缈的赞誉、遥遥无期的未来、永远得不到满足的欲望以及其他各种似是而非的东西。&lt;/p&gt;
&lt;p&gt;可怕的是如果自己意识不到这一点，那情况就会毫无意外地持续下去，除非某天经历了一次可以足够让自己清醒的苦难，而在其中的他没有被摧毁，但没有人希望这样的苦难会和他邂逅。&lt;/p&gt;
&lt;p&gt;在这条路上，任何其他人的帮助都是杯水车薪，前期最重要的是强大的独立思考能力，而中后期最重要的则是无坚不摧的内心。&lt;/p&gt;
&lt;h2&gt;下载&lt;/h2&gt;
&lt;p&gt;&lt;a href="灵态：使用指导手册.pdf"&gt;灵态：使用指导手册.pdf&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>没有任何事情是必须要做的</title><link href="/mei-you-ren-he-shi-qing-shi-bi-xu-yao-zuo-de.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/mei-you-ren-he-shi-qing-shi-bi-xu-yao-zuo-de.html</id><summary type="html">&lt;p&gt;很多道理很简单，但很多时候仅仅知道道理还是解决不了问题，所以我越来越少写东西了。但有些东西还是想写，比如当我们做一件事时，动机是什么。&lt;/p&gt;
&lt;p&gt;经常有人说他做本来不想做一件事，但因为某些原因而不得不做，或者说他除了做某件事外别无选择。当一个人这样想时，他就会感觉失去了自由，因为失去了选择的权利。那么真的有那么一件事时必须要做的吗？&lt;/p&gt;
&lt;p&gt;其实这里有一个思维的陷阱，将最优选择当成唯一选择。通常在最优选择明显优于其他选择时，人很容易犯这种错误。比如拿最简单的例子“吃饭”来说，因为如果不吃饭会感觉到饥饿，连续不吃饭就会饿死，很多人认为吃饭是一件不得不做的事情。其实稍微分析一下我们就会清楚，不吃饭也是一种选择，一个人可以选择不吃饭直到饿死，这是完全有可能的。但通常情况下，吃饭这个选择时明显优于不吃饭的选择的，所有人们容易直接无视掉还有一个选择时不吃饭，从而认为吃饭是必须要做的事情。&lt;/p&gt;
&lt;p&gt;可能有人认为这不过是一个语言的把戏，不吃饭是不是一个选择又有什么关系呢，对于大多数人来说，吃饭依然是一件不得不做的事情，毕竟几乎没有人想做明明有东西吃的情况选择饿死。从表面看好像确实没有什么关系，但这心态上，有很大的区别。同样是每天吃三顿饭，如果我认为吃饭是我不得不做的事情，那么我会认为在吃饭这件事情上我是没有自由的，如果我认为不吃饭也是一种选择，那么我会认为在吃饭这件事情上我是自由的。这二者是有很大的区别的。&lt;/p&gt;
&lt;p&gt;区别在于，如果一个人认为吃饭是一件必须要做的事情，那么只要一件事符合“做这件事明显优于不做这件事或者做其他事”的条件 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;很多道理很简单，但很多时候仅仅知道道理还是解决不了问题，所以我越来越少写东西了。但有些东西还是想写，比如当我们做一件事时，动机是什么。&lt;/p&gt;
&lt;p&gt;经常有人说他做本来不想做一件事，但因为某些原因而不得不做，或者说他除了做某件事外别无选择。当一个人这样想时，他就会感觉失去了自由，因为失去了选择的权利。那么真的有那么一件事时必须要做的吗？&lt;/p&gt;
&lt;p&gt;其实这里有一个思维的陷阱，将最优选择当成唯一选择。通常在最优选择明显优于其他选择时，人很容易犯这种错误。比如拿最简单的例子“吃饭”来说，因为如果不吃饭会感觉到饥饿，连续不吃饭就会饿死，很多人认为吃饭是一件不得不做的事情。其实稍微分析一下我们就会清楚，不吃饭也是一种选择，一个人可以选择不吃饭直到饿死，这是完全有可能的。但通常情况下，吃饭这个选择时明显优于不吃饭的选择的，所有人们容易直接无视掉还有一个选择时不吃饭，从而认为吃饭是必须要做的事情。&lt;/p&gt;
&lt;p&gt;可能有人认为这不过是一个语言的把戏，不吃饭是不是一个选择又有什么关系呢，对于大多数人来说，吃饭依然是一件不得不做的事情，毕竟几乎没有人想做明明有东西吃的情况选择饿死。从表面看好像确实没有什么关系，但这心态上，有很大的区别。同样是每天吃三顿饭，如果我认为吃饭是我不得不做的事情，那么我会认为在吃饭这件事情上我是没有自由的，如果我认为不吃饭也是一种选择，那么我会认为在吃饭这件事情上我是自由的。这二者是有很大的区别的。&lt;/p&gt;
&lt;p&gt;区别在于，如果一个人认为吃饭是一件必须要做的事情，那么只要一件事符合“做这件事明显优于不做这件事或者做其他事”的条件，那么他就会认为这件事也是一件必须要做的事情。这样的事情非常多，覆盖到生活的方方面面。比如他早晨被闹钟吵醒（这显然是必须做的，不然万一起晚了迟到了呢），然后梳洗打扮（这显然是必须做的，不然让别人看到自己蓬头垢面的可不好），吃早餐（这显然是必须做的，不然时间久了得了胃病可不舒服），然后去上班（这显然是必须做的，不上班没有收入怎么生活），然后完成某项工作任务（这显然是必须做的，不然会有种种后果），然后工作一天后回家歇歇玩玩（这显然是必须做的，不然身体累坏了可不好），然后到了晚上去睡觉（这显然是必须做的，不然明天身体就会受不了）。如果一个人这样想，那么对他而言还有自由吗？&lt;/p&gt;
&lt;p&gt;拿最简单的一件事“吃饭”来举例。如果我连续一些天不吃饭，那么就会饿死，那么吃饭对于我来说是不是一件必须做的事情？这里涉及到一个问题，什么是正常状态？如果说身体不饿是正常状态，那么距离上次吃饭一定时间后，身体从正常状态变成了异常状态，那么为了维持身体处于正常状态，就必须要吃饭。这样看起来好像可以说得通。但这个说法的前提是有问题的。为什么说不饿是正常状态呢？一段时间没有进食，身体就会有饥饿的感觉，这是再正常不过的事情。&lt;/p&gt;
&lt;p&gt;前些日子，很多事情被突然放进了我的待办事项里，让我一时有些乱了手脚，其中有些并不是很顺利，更让我有些烦。我一直期待那些事情快点做完，但偏偏其中某些事情一时半会做不完。连续忙了几天，就到了十一了，所有的事情都搁置了，我也开始想说什么地方出了问题。&lt;/p&gt;
&lt;p&gt;那些事情中，有一些看起来很重要，重要到几乎不得不做，如果不是这样，我完全可以不理会。还有一些看起来也比较重要，如果不去做，或者没做成，会有很大的损失。我又重新梳理下那些事情，发现可以按照另一种方法分两类，一类是肯定可以做成的，另一类是有可能做不成的。前者虽然可能有些麻烦，或者我不大喜欢做，但并不是让我心烦的主要原因。&lt;/p&gt;</content></entry><entry><title>没有真正的无欲无求</title><link href="/mei-you-zhen-zheng-de-wu-yu-wu-qiu.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/mei-you-zhen-zheng-de-wu-yu-wu-qiu.html</id><summary type="html">&lt;p&gt;前几天去看了电影《卧虎藏龙：青冥宝剑》，总体感觉还不错。但我知道我的喜好和很多其他人不一样，就去网上搜了了影评。果然，几乎一边倒地借《卧虎藏龙》贬低《卧虎藏龙：青冥宝剑》。虽然很反感借一种事物贬低另一种事物的行为，但也见怪不怪了。&lt;/p&gt;
&lt;p&gt;于是我从网上下了《卧虎藏龙》看了起来，确实很好。不想过多评价这两部电影，只是《卧虎藏龙》里开篇李慕白和俞秀莲说的一番话，让我想写点什么。&lt;/p&gt;
&lt;p&gt;“这次闭关静坐的时候，我一度进入了一种很深的寂静。我的周围只有光，时间、空间都不存在了。我似乎触到了，师父从未指点过的境地。我并没有得道的喜悦，相反的，却被一种寂灭的悲哀环绕，这悲哀超过了我能承受的极限。我出了定，没办法再继续。有些事……我需要想想。”&lt;/p&gt;
&lt;p&gt;我感觉这番话会引发很多讨论，于是去网上搜了下。结果比较失望，少有人仔细讲对这番话的理解，多为一笔带过。当然这也是难免的，这里并不是影片的亮点所在。&lt;/p&gt;
&lt;p&gt;当我看完一遍后，回过来再仔细想这番话，有了一些不同的感触。关于得道，开悟 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;前几天去看了电影《卧虎藏龙：青冥宝剑》，总体感觉还不错。但我知道我的喜好和很多其他人不一样，就去网上搜了了影评。果然，几乎一边倒地借《卧虎藏龙》贬低《卧虎藏龙：青冥宝剑》。虽然很反感借一种事物贬低另一种事物的行为，但也见怪不怪了。&lt;/p&gt;
&lt;p&gt;于是我从网上下了《卧虎藏龙》看了起来，确实很好。不想过多评价这两部电影，只是《卧虎藏龙》里开篇李慕白和俞秀莲说的一番话，让我想写点什么。&lt;/p&gt;
&lt;p&gt;“这次闭关静坐的时候，我一度进入了一种很深的寂静。我的周围只有光，时间、空间都不存在了。我似乎触到了，师父从未指点过的境地。我并没有得道的喜悦，相反的，却被一种寂灭的悲哀环绕，这悲哀超过了我能承受的极限。我出了定，没办法再继续。有些事……我需要想想。”&lt;/p&gt;
&lt;p&gt;我感觉这番话会引发很多讨论，于是去网上搜了下。结果比较失望，少有人仔细讲对这番话的理解，多为一笔带过。当然这也是难免的，这里并不是影片的亮点所在。&lt;/p&gt;
&lt;p&gt;当我看完一遍后，回过来再仔细想这番话，有了一些不同的感触。关于得道，开悟，无欲无求，以及其他类似的词语。先放下这些，讲一下我自己经历的事情。&lt;/p&gt;
&lt;p&gt;我想起还在北京那会，有时周末会去王府井书店，看看最近流行什么书。去过那里的都清楚，一楼右手边是畅销书区，人也比较多。让我意外的是，畅销书区有很多灵修相关的书籍，比如张德芬的几本书直接摆在那里，甚至克里希那穆提晦涩难懂的书也占满了一层书架。从某种角度说，这些书确实是好书。但它们引起了更多人的注意，却不是好事情。就像如果一个人没有疾病，是不会关注治病的处方的。&lt;/p&gt;
&lt;p&gt;对于灵修书籍，我有一种很复杂的感情。一方面很感谢从一部分书中的收获的东西，另一方面也对一部分书中充斥着的误导比较反感，这两部分书是有重合的。所以我几乎从不向别人推荐和灵修有关的书籍。&lt;/p&gt;
&lt;p&gt;很多灵修书籍有一个比较相似的结构。大概是首先夸大你生活中的问题，比如是不是感觉活着没意思，很累，或者不快乐，钱怎么也不够用，婚姻也不幸福等等，来引发读者的共鸣。然后话锋一转，开始说你想要的东西是不能在外部世界找到的，而要从自己的内心找。剩余的部分便是流行的“活在当下”，“吸引力法则”，静坐，冥想，禅修等等。如果按照那些方法“修炼”，会慢慢进入一种“开悟”的状态，从此生活再无烦恼（或者即使有烦恼也会不在乎）。&lt;/p&gt;
&lt;p&gt;我曾经也比较认同这些内容，也一度（大概一年前）感觉自己离“开悟”状态似乎很近了。就像在黑夜中隐约看到远处的灯光，看不清楚有多远，也看不清有没有路通往那里，但似乎自己正在往那个方向靠近。但有时又感觉自己一直在兜圈子，甚至不确定那灯光是否只是一个幻象。&lt;/p&gt;
&lt;p&gt;我忘记是什么时候开始，不再对“开悟”执着了。我知道我从未达到过“开悟”状态，而是慢慢开始对所谓的“开悟”产生怀疑。最后我认识到，说一个人“开悟”了，就像说一个人死后进入了永恒的天堂一样，听起来很美好，却不是真的。二者本就是一回事，区别在于一个是在活着的状态，一个是在死后的状态。&lt;/p&gt;
&lt;p&gt;“开悟”、“得道”毕竟是虚无缥缈的词汇，每个人的理解都有所不同。换一个更通俗的词语是“无欲无求”。一般的说法是，如果一个人做到了无欲无求，至少就离“开悟”很近了，如果不能等同于“开悟”的话。所以这就提供了通往“开悟”的两条路。一条是禁欲，一条是泄欲。禁欲是指通过强行让自己的欲望消失，来达到无欲无求的状态。泄欲是指将自己的所有欲望都满足了，自然也就无欲无求了。&lt;/p&gt;
&lt;p&gt;但这两条路都是行不通的。&lt;/p&gt;
&lt;p&gt;首先是禁欲，比较好理解。欲望只能疏，不能堵，它是不会无缘无故消失的，只会隐藏得更深，同时慢慢长大。当一个人控制不了自己的欲望，就会被欲望左右。自古以来，几乎没有这样的故事，一个人从小被关起来修道（或者其他类似词汇），最后“开悟”了。更多的是一个人年轻时经历了很多事情，最后对尘世不感兴趣了，达到某种境界。&lt;/p&gt;
&lt;p&gt;其次是泄欲。也许“泄欲”这个词汇不大合适，大概意思是当一个人经历的事情多了，想要的东西都拥有了，曾经看重的东西都不那么重要了，也就没有更多欲望了。&lt;/p&gt;</content></entry><entry><title>《你的第一本哲学书》读书笔记</title><link href="/ni-de-di-yi-ben-zhe-xue-shu-du-shu-bi-ji.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ni-de-di-yi-ben-zhe-xue-shu-du-shu-bi-ji.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这是一本哲学入门书籍，涉及了许多哲学基本问题。其中很多问题从来没有确定的答案，或许这就是哲学的魅力吧。如果想深入思考人生，一定的哲学基础是必须的，而且很多进阶书籍，没有哲学功底是无法理解的。这是一本还算可以的入门书，不会像很多其他书那么乏味，重点是涉及面很广。&lt;/p&gt;
&lt;h2&gt;目标读者&lt;/h2&gt;
&lt;p&gt;正如书名，“你的第一本哲学书”，是给没有哲学基础的读者看的。但重读此书后，我发现这本书并不是那么适合入门，主要是作者在文字中几乎处处隐含自己的哲学观点，越往后的章节越是如此，就像已经知道了问题答案，所有的论证都是往自己想要的方向靠拢一样，而不是真正抱着试图解决未知问题的心态。更重要的是很多地方逻辑并不严谨，对于自己反对的观点草草了事甚至只字不提。相比之下，我宁愿推荐罗素的《哲学问题》作为入门哲学书籍，尽管相对而言不是那么好理解。&lt;/p&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;外部世界是否存在？&lt;/li&gt;
&lt;li&gt;他人的心灵是否存在？&lt;/li&gt;
&lt;li&gt;心灵和大脑是什么关系？&lt;/li&gt;
&lt;li&gt;语言如何可能？&lt;/li&gt;
&lt;li&gt;我们是否有自由意志？&lt;/li&gt;
&lt;li&gt;什么是对与错？&lt;/li&gt;
&lt;li&gt;公正存在吗？&lt;/li&gt;
&lt;li&gt;如何看待死亡？&lt;/li&gt;
&lt;li&gt;生活的意义是什么？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是书中九章对应的九个问题，这些问题中绝大多数都尚未解决，并且其中一部分或许永远无法解决。可以看出人生最重要的问题包含在内，实际上人生问题就是哲学问题。开始学习哲学的最好方式就是直接思考这些问题。一旦开始了这种思考，就可以更好地理解那些想要解决同样问题的人们的著作了。&lt;/p&gt;
&lt;p&gt;我在这里就不重点写书中的内容了，因为已经比较好理解 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这是一本哲学入门书籍，涉及了许多哲学基本问题。其中很多问题从来没有确定的答案，或许这就是哲学的魅力吧。如果想深入思考人生，一定的哲学基础是必须的，而且很多进阶书籍，没有哲学功底是无法理解的。这是一本还算可以的入门书，不会像很多其他书那么乏味，重点是涉及面很广。&lt;/p&gt;
&lt;h2&gt;目标读者&lt;/h2&gt;
&lt;p&gt;正如书名，“你的第一本哲学书”，是给没有哲学基础的读者看的。但重读此书后，我发现这本书并不是那么适合入门，主要是作者在文字中几乎处处隐含自己的哲学观点，越往后的章节越是如此，就像已经知道了问题答案，所有的论证都是往自己想要的方向靠拢一样，而不是真正抱着试图解决未知问题的心态。更重要的是很多地方逻辑并不严谨，对于自己反对的观点草草了事甚至只字不提。相比之下，我宁愿推荐罗素的《哲学问题》作为入门哲学书籍，尽管相对而言不是那么好理解。&lt;/p&gt;
&lt;h2&gt;问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;外部世界是否存在？&lt;/li&gt;
&lt;li&gt;他人的心灵是否存在？&lt;/li&gt;
&lt;li&gt;心灵和大脑是什么关系？&lt;/li&gt;
&lt;li&gt;语言如何可能？&lt;/li&gt;
&lt;li&gt;我们是否有自由意志？&lt;/li&gt;
&lt;li&gt;什么是对与错？&lt;/li&gt;
&lt;li&gt;公正存在吗？&lt;/li&gt;
&lt;li&gt;如何看待死亡？&lt;/li&gt;
&lt;li&gt;生活的意义是什么？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是书中九章对应的九个问题，这些问题中绝大多数都尚未解决，并且其中一部分或许永远无法解决。可以看出人生最重要的问题包含在内，实际上人生问题就是哲学问题。开始学习哲学的最好方式就是直接思考这些问题。一旦开始了这种思考，就可以更好地理解那些想要解决同样问题的人们的著作了。&lt;/p&gt;
&lt;p&gt;我在这里就不重点写书中的内容了，因为已经比较好理解，概况的意义也不是很大。当然还有一个重要原因就是对应作者的很多观点，我并不认同。&lt;/p&gt;
&lt;p&gt;思考哲学问题的时候，一定要注意自己是否在思考之前就已经作下的某些假设。去除这些假设——不管它们看起来有多么合理——除非你证明了它们。实际上在哲学世界，“证明”这个词几乎是可笑的。但有一个例外，笛卡尔的“我思故我在”，这句话是非常伟大的。有人说这句话是哲学史上的最重大进展，掀开了新的篇章。因为它证明了“我”的存在，不管这个“我”和我们认为的我是否是同一件东西，但至少有一个东西是确定存在的，这代表哲学终于有一个确定的根基了。也就是说，除了“我”存在这个确定的假设，我们可以怀疑一切，诸如“我”是什么的问题也是。因为这里只是说有一个东西是确定存在的，我称它为“我”，但并没有解释“我”是什么。对于哲学入门者显然不清楚这些的重要性，他们会轻易把自己的“常识”带入到哲学问题的思考中，认为某些问题根本没有思考的必要，或者认为得出的那些结论是毫无争议的。但随着思考的深入，他们会慢慢发现看似完美的大楼在某一天轰然倒塌，而陷入彻底的迷茫，从而不得不回到起点艰难前行。而思考哲学问题的目的也不是得出一个所有人都接受的理论，而是得出一个自己能接受的、可以自圆其说的理论，但这也一点都不容易，&lt;/p&gt;
&lt;h2&gt;外部世界是否存在？&lt;/h2&gt;
&lt;p&gt;作者提出的第一个问题，是很多人认为根本不是问题的“外部世界是否存在？”。如果一个人还没有开始质疑外部世界是否存在的话，显然他还没有准备好开始思考哲学问题。&lt;/p&gt;
&lt;p&gt;“可以确信存在的，就是你自己心灵之内的东西”，这个前提看起来没问题，但直接摆出这个前提而不加论述则是有问题的。如果你把“我”等同于“心灵”，那么你的心灵存在是没问题的。但你如何证明你心灵之内存在着东西？已经“存在”二字是什么意思？这些必须提前说明，不然会对后续的论述带来无穷无尽的麻烦。&lt;/p&gt;
&lt;p&gt;我们看从“我”存在能得到什么？首先我们必须明确“存在”是什么意思。我们常说X是存在的，比如这个桌子是存在的。但实际这种说法并不完整，我们真实的含义是这个桌子存在于这个房子，之内，或者存在于这个世界中，至少是存在于外部世界（或者物质世界）中。但麻烦在于我们已经怀疑外在世界的存在性了。如果外部世界都不存在，说这个桌子存在毫无意义。存在是一种关系，而不是一种状态。我们可以说A存在于B，而不能仅仅说A存在。&lt;/p&gt;
&lt;p&gt;那再来看“我存在”这个命题，就非常有意思了。“我”是相对什么存在的？如果除了“我”，再无其他东西了，就不能说“我”存在了。那难道必须假设一个世界，这个世界包含“我”在内吗？可以这样，但由“我存在”显然无法直接得出这一点。&lt;/p&gt;
&lt;p&gt;另一个思路是切分“我”。或者说如果一个“我”是没有内部结构的，除了“我”之外没有任何东西，“我”是根本不可能发现“我”存在这一现象的。“我”发现了这一点，只能是因为这个“我”已经不再是一个整体，其中的一部分发现了另一个部分。其实从“我思故我在”中就可以看出这一点。“思”是什么？我在思考，或者说我在想一个问题，这句话是不需要证明的，因为这是对一种确定行为的描述。我在想一个问题，那问题是什么？如果问题不存在，我如何思考一个问题？其实“我思故我在”得到的是，问题相对于我是存在的。那我又是相对于什么而存在的呢？没有其他信息的情况下，显然是我相对于那个问题而存在。但“我”和我想的“问题”合在一起叫什么呢，还叫“我”。这是一个比较晦涩的逻辑，其实是两种说法，我们正常生活中也会遇到。比如我说“我的衣服”，我一般不会认为衣服是我的一部分，而是认为衣服是我拥有的东西，没有了这件衣服，我还是我。但比如说“我的身体”，情况就不大一样了，多数人会认为身体是“我”的一部分，没有了身体，我就不再完整了。同样的，“我的思想”也有两种解读方式，一种是认为思想是我所拥有的东西，另一种是思想是我的一部分。而在这里，两个“我”显然范畴是不同的。我们之前提到的是后一种，就是把思想和我拆开。但如果合在一起，它还叫“我”。其实“我思故我在”中的后一个我，指代的是合在一起的“我”，而前一个是拆分后的“我”。&lt;/p&gt;
&lt;p&gt;“我”（合在一起的“我”）是相对于什么存在的？是相对于我的组成部分存在的，比如我的想法（或者说因为“我”有内部结构，所有它必然存在）。而这想法正是作者提到的“心灵之内的东西”。它们是相对于“我”存在的。这才是“可以确信存在的，就是你自己心灵之内的东西”的证明过程。&lt;/p&gt;
&lt;p&gt;你唯一能确信存在的，就是在你自己心灵之内的东西。无论是太阳、房子、其他人，还是你自己的身体，都是建立在你经验和思想、感觉和感官的基础上的。&lt;/p&gt;
&lt;p&gt;举个简单的例子，你看到一个苹果，于是想那是处于外部世界的苹果。晚上在梦中也看到一个类似的苹果，于是认为那个苹果也是处于外部世界的。你看到一个非常逼真的苹果模型，就认为那是一个新鲜可口的苹果，想得流了口水，放到嘴边才发现咬不动，而如果不去咬，则可能一直认为那就是一个真的苹果。你看到一个红苹果，认为它非常可口，咬一口才发现非常苦涩。而如果不去咬，你会一直认为它非常可口。&lt;/p&gt;
&lt;p&gt;这些苹果究竟是外部世界的，还是在你的内心之中？&lt;/p&gt;
&lt;p&gt;如果你说如果不是有光照射到那个苹果，反射到你的眼睛中，并使你产生了视觉经验，你就不会看到它。我可以简单地反驳说：你是怎么知道这一点的呢？你能说出的理由仍然是关于外部世界以及你与它之间的关系，而这个世界必须建立在你的感官证据上。然而，你之所以能够用这些感官证据来说明视觉经验是如何产生的，只是因为你已经在心灵之内预设了外部世界的存在。但这一预设这是我们已经有所怀疑的。如果你用自己的感觉印象与证明感觉印象的可靠性，你就是在循环论证，无法得到任何关系。就比如证明那个梦里的苹果存在于外部世界。&lt;/p&gt;
&lt;p&gt;如果你所有的经验就是一场在它之外没有外在世界的“大梦”，甚至根本没有身体或大脑，连空间也不存在，只有你的心灵才是唯一存在的东西，你没有任何证据来证明所处的世界不是这样。这种观点被称为唯我论。&lt;/p&gt;
&lt;p&gt;作者对唯我论的态度是不支持。但我想说，这样去描述唯我论，和唯物论者描述唯心论的方式并无不同，认为一个正常人怎么可能接受唯我论，非常偏激。我们不能这样对待自己不认同的观点，而应该换个思路。&lt;/p&gt;
&lt;p&gt;想象整个世界，除了我的心灵并无他物，这意味着什么？比如你在看一本书，因为除了你的心灵别无他物，这本书必然不存在，那问题是这本书到底是什么，上边的文字都是怎么回事，如何解释？&lt;/p&gt;
&lt;p&gt;有人可能用梦来比喻，说梦中的书没有人写，但也出现了，所以书并不需要一个作者，这也是多数人对唯我论的理解。但需要注意的是，我们之所以说那是梦，是因为可以醒来，如果一个梦永远不会醒来，那它就不可能是梦，而是现实。在这里，梦的比喻解决不了任何问题。&lt;/p&gt;
&lt;p&gt;我们可以说书不存在，书上写着一个等式“1+1=2”，于是在脑海里也出现了这个等式，那问题是我们脑海里的这个“1+1=2”存在不？想到着就会发现一个问题，“存在”是什么意思？其实存在是一种关系，比如书上有一行文字，我们说文字“存在”于书上，这样存在才有意义。我们平时常常说A存在，而不说A存在于B，并不是说不需要B，而是B默认就是这个外在世界。而唯我论最开始就否定了这个外在世界，所以我们就不能这么用“存在”这个词了。&lt;/p&gt;
&lt;p&gt;那么在唯我论里，“存在”的意义是什么？因为只有我的心灵，存在必然是相对于我的心灵的。那么很显然，我脑海里的这个“1+1=2”是存在的，因为我的心灵感受到了。或者换个说法，“1+1=2”是组成我心灵的一部分，因为“1+1=2”不可能独立于我的心灵而存在，除了我的心灵就没有东西了。&lt;/p&gt;
&lt;p&gt;那么那本书呢？因为我感受了它，它也存在于我的心灵。对于我的心灵而言，那本书、书中的“1+1=2”、我脑海里的“1+1=2”没有什么区别，都是组成心灵的一部分。这样似乎解决了一部分问题，但麻烦在于我的心灵为什么会不断产生我之前根本不知道的东西，这背后的原理是什么？&lt;/p&gt;
&lt;p&gt;如果不去解释这背后的原理，这唯我论就是不完备的，需要完善的。如果认为这不可解释，那就会演变成不可知论。这里讨论的是完备的唯我论，而不是其他东西。&lt;/p&gt;
&lt;p&gt;那我们硬着头皮尝试解释一下。注意有一个非常关键的一点，我可以说这个世界除了我的心灵并无他物，这没问题。但如果要深入下去，心灵就不可能还是一个不可分割的东西，我们必须把心灵切分成各个部分，加以研究。比如之前我们说的，要解释我看到一本书（之前我们已经得到这本书必须存在）是怎么回事，那么就必须把心灵切分成这本书（A），和除了这本书的心灵其他部分（B），然后去思考A和B是如何作用的。同理，我看到的每一件东西，我的每一个想法，都可以被这样被切分出去。那问题是，如果所有可以切分的东西都被切走了，我的心灵还剩余什么？&lt;/p&gt;
&lt;p&gt;或者换个说法，如果我说最后被切剩下的东西才叫“心灵”，而被切下的东西其实是属于“外部世界”的，那么这种说法和唯我论有本质区别吗？注意这种观点是二元论。&lt;/p&gt;
&lt;p&gt;还有一种可能，就是如果这样切下去，不会剩余任何东西，没有哪个东西是特别的，不能被切走的。这种观点是一元论（也包括各种一元唯心论和一元唯物论等）。&lt;/p&gt;
&lt;p&gt;现在我们再回头审视唯我论（唯我论其实是被分类到一元唯心论的），还会感觉它很荒谬吗？唯我论面临的问题和其他各种二元论和一元论几乎一模一样，区别仅仅是同一个概念名称不同而已（就像相同含义的中文和英文）。&lt;/p&gt;
&lt;p&gt;然后趁热打铁，我们来看一元唯物论和一元唯心论的区别。同样一件东西，在一元唯物论中被称作“物质”，在一元唯心论中被称作“意识”（或者“心灵”、“精神”）。这有本质区别吗，还是同一个概念名称不同而已。&lt;/p&gt;
&lt;p&gt;二元论也同理，没有什么区别。&lt;/p&gt;
&lt;p&gt;最后看一元论和二元论是否有区别。正如我们之前想到的，把唯我论（极端的唯我论属于一元论）中的一本书（A）和心灵除了这本书剩余的部分（B）拆分开。一元论认为A和B属于同类，没有本质区别。二元论并认为A属于物质，B属于意识+物质（如果把所有的处于“客观世界”的东西都取出，就只剩意识了），A和B是完全不同的东西。但无论如何，必须要解释A和B是如何作用的，理论才可以完备。但这是一个最基本的哲学问题，也就是“问题3：心灵和大脑是什么关系”，没有任何一种主流哲学理论能把这个问题解释得清晰透彻，而没有任何遗漏和破绽，所以才有数不尽的哲学理论。&lt;/p&gt;
&lt;p&gt;可以看出一元论只是隐藏了这个问题，而没有解决。而二元论凸显了这个问题，但没有解释清楚。问题的本质不在于一元论还是二元论，而是如何解决这个问题。一旦这个问题解决了，有了确定一致的答案，所有一元论和二元论都没有本质区别了。&lt;/p&gt;
&lt;p&gt;我在这里没有顺着作者的思路，而是在第一个问题“外部世界是否存在？”中就把所有哲学理论遇到的共同问题抛出，而且在这里我的观点和作者观点是有着本质区别的。而没有哲学基础的人或许很难看懂，可以顺着作者的思路循序渐进，但一定要独立思考。&lt;/p&gt;
&lt;p&gt;除了一元论、二元论，还有一种重要的观点，就是之前提到的怀疑论。我们不直接探讨怀疑论，事实上也无法探讨。&lt;/p&gt;
&lt;h2&gt;他人的心灵是否存在？&lt;/h2&gt;
&lt;p&gt;实际之前我已经涉及过这个问题。&lt;/p&gt;
&lt;p&gt;我们再仔细分析他人心灵存在与不存在的两种情况，各种哲学理论有什么区别：&lt;/p&gt;
&lt;p&gt;他人心灵是存在的：
1. 一元唯心论：存在多个同等地位的心灵
2. 一元唯物论：心灵的存在形式是物质，存在多个这样的物质所构成的心灵
3. 二元论：存在多个同等地位的心灵&lt;/p&gt;
&lt;p&gt;他人心灵是不存在的：
1. 一元唯心论：只有我的心灵才存在，根本没有其他人的心灵这回事（极端唯我论）
2. 一元唯物论：心灵的存在形式是物质，只存在一个这样的物质所构成的心灵（有点奇怪，也就是说其他人都只有肉体，没有心灵，而且为什么那么多物质只能构成一个心灵）
3. 二元论：只有我的心灵才存在（有点奇怪，也就是说其他人都只有肉体，没有心灵）&lt;/p&gt;
&lt;p&gt;首先看他人心灵不存在的话，二元论的情况。只有自己有心灵，其他人都像机器人一样没有心灵，但从外表看不出任何区别。这没有矛盾，但为什么会比较奇怪呢？因为这种假设在没有解决任何问题的情况添加了复杂度，根据奥卡姆剃刀原理，这种思维是不提倡的。就像我们还没有弄清A是什么时，就假设A存在两种，这两种不一样，但我说不出为什么应该存在两种，也不清楚不同之处。甚至我还可以说心灵分为1-10十个级别，不同人的心灵属于不同的级别，同一个人可以有多个心灵，同一个心灵还可以被多个人同享等等，无穷无尽。这样平添复杂度对解决问题是没有任何用处的。他人心灵不存在的前提一元唯物论的情况也同理。&lt;/p&gt;
&lt;p&gt;再看他人心灵不存在前提的一元唯心论，其实就是我们之前讨论过的极端唯我论。&lt;/p&gt;
&lt;p&gt;还是用我们之前看书的例子，我看一本书，这里换个角度，想想这个书是怎么来的。这本书不是我写的（即使它是我心灵的一部分），我肯定是不清楚它的来源了。可能的来源：
1. 就是我创造的这本书，只是我忘了。
2. 这本书从来就存在，不需要被创造。&lt;/p&gt;
&lt;p&gt;第一个来源说就是我创造的这本书，只是我忘了。但这里的一个麻烦在于我的思维是连续的，比如我在想一个小时问题，而一本书就这样无中生有了，那么我说这本书就是我创造的问题在于，我必须会分身法，并且完全不清楚另一个分身是怎么回事。但这样这个所谓自己的分身和别人有区别吗？没有任何区别。&lt;/p&gt;
&lt;p&gt;第二个来源说这本书从来就存在。但如果这本书从来就存在，那其他的东西也一样。或者说我的心灵中不会有任何新东西，一切都早已存在。但这里麻烦在于，我们再回想一下“存在”的含义。如果一个东西“存在”，但我的心灵却不清楚，那它是相对什么存在的，显然它是不应该存在的。第二个来源根本不是来源，而是一个谬误。&lt;/p&gt;
&lt;p&gt;所以在一元唯心论里，他人的心灵存在与否没有区别。&lt;/p&gt;
&lt;p&gt;总结一下，就是纠结于他人心灵是否存在对解决更重要的问题没有任何用处，而一旦我们解决了心灵和物质的关系问题后，他人心灵是否存在也不再是问题了（比如最终的结论是二元论所描述的那样，我们终于清楚了物质在什么情况会形成意识，那其他人是否有意识自然就清楚了）。&lt;/p&gt;
&lt;p&gt;这一章我完全没有参照书的内容，说实话我感觉书中的内容一直在绕圈子，而没有涉及到问题的真正所在。&lt;/p&gt;
&lt;h2&gt;心灵和大脑是什么关系？&lt;/h2&gt;
&lt;p&gt;书中作了如下假设：认为物质世界是存在的，他人的心灵也是存在的。&lt;/p&gt;
&lt;p&gt;作者先提到了二元论，但显然是不能接受二元论的，于是重点介绍的是物理主义，也就是唯物论者对心灵和大脑的关系的解释。人只是有物质材料构成的，而人的心理状态只是他们大脑的生理状态。就想我们熟悉的其他一些事物的真实本质是由科学研究最终揭示出来的一样，我们最终也可以发现心灵体验实际上只是脑部的生理作用。就像水是由氢和氧构成的，但是这两种元素分开来看一点也不像水。发现心灵的生物学本性也不过是时间问题而已。然而用物理主义去解释身心关系也是麻烦重重，作者最后干脆说“这个世界当中也行有某种东西已经超出了物理学的理解能力”。&lt;/p&gt;
&lt;p&gt;事实上，我认为这章基本什么也没有说，看了这些零散内容几乎也不会想到任何有价值的东西。要知道这是哲学中最重要的一个问题，作者显然是知难而退了。&lt;/p&gt;
&lt;p&gt;这个问题实际是困扰了我很久，最后我费尽心思得到了如下我能接受的理论：&lt;/p&gt;
&lt;p&gt;物质和意识的既不是同一种东西，也不是完全分离的两种东西，我们应该把它们看作一个整体。然而它们都不是实体，而是属性，比如原子有质量，也有速度。质量和速度还是有关系的，比如你给不同的原子同样的力，质量小的那个原子就会获得更大的加速度，从而获得更大的速度。但你不能说质量决定速度，或者速度决定质量，也不能说质量和速度是完全分开的两种东西，可以相互作用。物质和意识也是一样。&lt;/p&gt;
&lt;p&gt;这是世界是由一种最小的单元（简称意识单元）组成，意识单元有几种基本特性，第一种就是有意识，确切地说：
1. 它知道自己是什么
2. 它可以自己做选择&lt;/p&gt;
&lt;p&gt;第二种特性就是不同的意识单元以非定域性作用力相互作用，第三种特性是不同的意识单元可结合，结合后会产生更大的意识，第四种特性就是物质性。&lt;/p&gt;
&lt;p&gt;说起来比较复杂，但也只有这些就足够了。那如何解释这个世界呢？&lt;/p&gt;
&lt;p&gt;首先从“我是什么？”开始：&lt;/p&gt;
&lt;p&gt;“我”就是很多意识单元的合成体，这些意识单元中的意识合成了“我”的意识，而它们的物质性使得我看起来有一个身体。&lt;/p&gt;
&lt;p&gt;然后“外在世界”是什么？&lt;/p&gt;
&lt;p&gt;外在世界也并无不同，比如他人也是由很多意识单元组成，和我没有本质的区别。但是不只是他人，所有的东西都是这样组成的，包括我们认为没有生命的石头，原子等等。所有的这些都是有意识的。&lt;/p&gt;
&lt;p&gt;最后“我”和“外在世界”的关系是什么？&lt;/p&gt;
&lt;p&gt;我和外在世界的关系，就是靠着意识单元的非定域性作用力相互作用的。比如我看到了一个苹果，实际上是我和苹果（已经周围的光线等等）的意识单元发生了作用，光子从苹果表面摄入我的眼睛，最后我看到了苹果的样子等等。&lt;/p&gt;
&lt;p&gt;这个看起来似乎没有解决任何问题，是因为之前我没有说清楚。&lt;/p&gt;
&lt;p&gt;“我”是什么是需要深入探寻的。其实一个意识单元就是一个“我”，这里拿两个意识单元举例。&lt;/p&gt;
&lt;p&gt;意识单元自己是没办法知道自己的存在的，只有与其他意识单元作用，它才会清楚。如果一个意识单元没有任何交互，那它就处于一种沉睡状态，一无所知。一旦发生了作用，它就会接收到一种信息，&lt;/p&gt;
&lt;h2&gt;语言如何可能？&lt;/h2&gt;
&lt;p&gt;这章讲的是语言相关的东西。语言是个比较奇怪的东西，那最简单的数字举例。我们知道数字1岁什么含义，但如果我问“数字1”存在吗？可能就不是那么好回答了。“数字1”显然不是物质的，不像一本书一样就在那张桌子上放着。那本书上确实印着“数字1”，但我们知道那只是油墨的形状，就算所有的书都被烧掉了，我们也不能说“数字1”消失了。&lt;/p&gt;
&lt;p&gt;其实就和我们之前遇到的情况一样，我们不能这样问，“数字1”存在吗？因为我们天天都会用到“数字1”，它显然是存在的，问题是它存在在哪里？它存在于人的意识中。但语言不只包含类似“数字1”的概念（我称之为实体）。比如我想“1+1=2”这个等式，其中的“+”和“=”是什么？是关系。除了实体和关系，语言里是否还包含其他东西？&lt;/p&gt;
&lt;p&gt;比如这样一句话，“我不清楚这本书写的都是什么东西，你认为呢？”&lt;/p&gt;
&lt;p&gt;其中“我”、“书”、“东西”、“你”是实体，“清楚”、“写着”、“是”是关系，但似乎还有东西没有包含在内。其实我们稍微调整一下这句话，就更方便一些。&lt;/p&gt;
&lt;p&gt;“我 否定 我 清楚 这本书 写着的 内容，我 想 知道 你 对 这本书 的 看法。”&lt;/p&gt;
&lt;p&gt;这样就全拆成实体和关系了（后半句可能不大好理解，其实“对X的”这是一种关系）。&lt;/p&gt;
&lt;p&gt;其实不只语言，我们思维中也只有实体和关系。但具体“实体”和“关系”是如何产生和运作的，这个是比较复杂了，实际上这就是和“心灵和大脑是什么关系”的问题紧密相关了。&lt;/p&gt;
&lt;h2&gt;我们是否有自由意志？&lt;/h2&gt;
&lt;p&gt;这个问题也是多数人都比较感兴趣的。&lt;/p&gt;
&lt;p&gt;什么是自由意志？&lt;/p&gt;
&lt;p&gt;举个例子，中午去吃饭时，菜单上有两道菜是你比较感兴趣的，你考虑再三，选择了其中一个。结果菜上来后，你尝一口发现一点也不好吃，于是你想选另一道菜就好了。如果你的确是有自由意志的，那你完全可能选另一道菜。而与此相反的情况是你只是认为自己有选择权，实际上并没有，你只能选那一道菜（事实上也并没有选择这回事，就像看一个早已拍完的电影，或是是由其他演员扮演的真人秀，你除了看什么也看不了），然后抱怨不好吃而后悔为什么没有选另一道菜。&lt;/p&gt;
&lt;p&gt;是否具有自由意志为什么会成为一个问题，而不是显而易见的呢？&lt;/p&gt;
&lt;p&gt;主张人没有自由意志的观点被称作“决定论”，简单说就是这个世界的下一个时刻会发生什么是被它上一个时刻的状态所决定的，如果上一个时刻的状态一样，那下一个时刻必然发生相同的事情。再看之前的例子，按绝对论的说法就是这样，你看到了菜单上的两道菜，此刻所有影响你做判断的因素都属于这个时刻的状态，比如你一直喜欢吃西红柿，比如你10岁时吃过一个没炒熟的茄子而留下了阴影，比如你此刻并不是很饿，比如和你一起来吃饭的人是谁，等等，你的想法就是由所有这些因素所决定的，从而确定了选那一道菜。或者说，你自从出生起，一切合你有关的事情都已经是确定的了。决定论又被称为科学宿命论。一般唯物主义者更容易相信决定论，否则会直接导致唯物主义难以自圆其说。&lt;/p&gt;
&lt;p&gt;如果决定论是对的，影响是巨大的。我们再也不应该去责备或者夸奖任何人，因为他必须这么做。但同时我们又不可能不去责备或者夸奖他，因为我们必须这样做。这么看似乎没什么问题，但应用于自己就不大一样了，主要原因是我们并不能预知结果。比如我早晨起来不想上班了，但又不不想被扣工资和被老板批，怎么办呢？于是我突然想到决定论，对啊，如果今天我注定是不去上班的，那我就不应该为此感到愧疚，于是心安理得地不去上班了。凡事都如此操作，我可能用不了多久就会一败涂地，甚至沦为乞丐了。但如果决定论是错的，那显然我是可以选择自己的命运的，而不会成为一个乞丐。&lt;/p&gt;
&lt;p&gt;总体说决定论更容易让人变得消极。你辛辛苦苦从零创建一个大公司，期间吃了很多苦头，费了无数心思，最后非常有成就感，结果被告知所有这些都是注定的，你和街边的那个乞丐没有任何区别，仅仅是命中注定而已，你会作何感想？更严重的事情是，小偷和强盗会更加开心，因为既然命中注定我就是要做这些，何乐而不为呢？如果每个人都相信决定论，这个世界又该是什么样呢？&lt;/p&gt;
&lt;p&gt;决定论看起来是无法反驳的，因为我们无法让世界重新回到之前的状态，观测它是否走继续之前的路线（即使我们真的可以做到，回到了之前的状态，但我们也会丢失之前这部分记忆，任何东西都无法得出）。量子力学的发展似乎让决定论遇到了问题，比如对于微观粒子，它们本身就不处于一种确定的状态，但谁又能肯定这种不确定不是更深层的确定所导致的呢？&lt;/p&gt;
&lt;p&gt;与决定论不同的观点认为我们有自由意志，所以我们应该对自己所做的事情负一定的责任。&lt;/p&gt;
&lt;h2&gt;什么是对与错？&lt;/h2&gt;
&lt;p&gt;简单说，对与错离开了作判断的主体是没有任何意义的。同样的事情对于某些人是对的，对于另一些人就是错的，甚至对于同一个人的不同年龄段也要这样的效果。我们认为某些东西是对的或者错的，只是因为这符合多数人的观点而已。&lt;/p&gt;
&lt;p&gt;即使是逻辑最为严谨的数学也是这样。数学就建立在公理之上，而这些公理，其实就是一些假设的前提。而从公理推出其他结论，则需要一些逻辑学的东西，或者说这些东西也如公理一样，是被假设成立的。而如果这些前提都完全接受后，数学就像如果“1+1=2”是对的，那么就“1+1=2”就是对的一样，但你还是可以选择不相信这推论是合理的，因为这还是基于逻辑学假设所作的判断，你可以说前边的“1+1=2”不能推出后边的“1+1=2”，这两个是完全不同的东西。&lt;/p&gt;
&lt;p&gt;和“对与错”相似的是“善与恶”，其实这是一回事，“善”就是做了一个“X是好的”是对的的判断。同样的行为，有些人认为是善的，另一些人则认为是恶的。而如果大多数人认为某些行为是善的，我们则说它是善的。&lt;/p&gt;
&lt;p&gt;但善恶和其他的对错又有不同之处，因为道德是建立在对善恶的判断之上的，它会影响到我们的为人处事。如果善和恶都是没有固定的标准的，那所谓的道德是不是无稽之谈呢？或者说人是否有一种本能，即对善恶有着一致的判断。有些人认为有一个权威的神存在，而一切善恶的判断结果都是由他确定的。&lt;/p&gt;
&lt;h2&gt;公正存在吗？&lt;/h2&gt;
&lt;p&gt;有人生来就安享富贵，有人却贫贱不堪，这公平吗？如果不公平，我们是不是应该为此做些什么？这种并非由那些受苦的人自己造成的不平等在何种程度上是件坏事？政府是否应当为此运用权力去减少这种不平等呢？&lt;/p&gt;
&lt;p&gt;某些不平等是刻意强加的，比如男女不平等、种族歧视。但是除去这些还有很多看起来不公平的事情，而且我们很难指责什么。就像两个人同时去等两趟不同的公交车，其中一个人很快等到了，另一个人则迎来了突然降临的瓢泼大雨，他在雨中足足等了半个小时，不仅迟到了，还染上了感冒。我们可以指责什么？日常生活中，总有人做着几乎相同的事情，结果则大相径庭。&lt;/p&gt;
&lt;h2&gt;如何看待死亡？&lt;/h2&gt;
&lt;p&gt;人人皆有一死，但人们对死亡的理解各不相同。一些人相信身体死亡后，灵魂依然活着，会上天堂，下地狱，或者去其他地方，比如成为鬼魂或者投胎转世，甚至不一定投胎成人。另一些人相信人一旦死去，就不再存在，因为身体死去的时候，自我也就随之消失了。有人认为死亡是可怕的事情，有人则不这么想。&lt;/p&gt;
&lt;p&gt;有一种说法是没有人能够真正设想当他自身不存在时是怎样的，所有我们也不能真正相信，随着我的死亡，我们的存在也会终结。但这显然是有问题的，你可以想自己完全睡着并且没有做梦的场景（实际上你天天做这样的事情），那段时间就可以认为是没有你的世界。而如果某个人，睡一觉就再也醒不了了，就只是把这个想象中的几小时改大而已，对于某些人是无穷大，另一些人则是一段有限的时间，并非不可想象。&lt;/p&gt;
&lt;p&gt;死后的事情相关问题是和身心问题联系在一起的。如果身体和灵魂只是组成人的两个不同部分，可以分离，那么有可能身体死后灵魂可以独自存在，并且仍然具有意识。也可能灵魂只能依附于身体之上，和身体同生共死，或者其他情况。&lt;/p&gt;
&lt;p&gt;而关于死亡的另一个问题是，我们应该以何种态度面对死亡？死亡是一件好事、坏事还是不好不坏的事情？对别人死亡的想法上一方面，但更重要的是如何能够理性面对自己的死亡？当你想到自己将来会死的时候，你会感觉恐惧、悲伤、无动于衷还是如释重负呢？&lt;/p&gt;
&lt;p&gt;这显然依死亡的本性而定。如果有死后的生活，那么你是高兴还是发愁就得看你的灵魂去往何方。然而如果死亡真的就是一了百了，我们应当对此持有何种态度？这是一件可怕的事情吗？&lt;/p&gt;
&lt;p&gt;一些人会说这对死者已经没有好坏而言；另一些人会说这样未来的一切可能性全都没有了，实在是最可怕的事情；还有人认为永生不死会无聊得让人难以忍受，死亡未必就是坏的事情。&lt;/p&gt;
&lt;p&gt;如果说死亡是好的，是因为它让一些人避免了某种坏事（如无聊或痛苦）；如果说死亡是好的，是因为它让一些人失去了某种好事（如愉悦的体验）。但无论死亡是好的还是坏的，对已经死去的人都不再具有意义，而只对还活着的人有意义，或者说死亡本身没有意义，有意义的是还没有死的人对待死亡的态度。&lt;/p&gt;
&lt;p&gt;想象一个没有你的世界将继续存在，而你已经化为乌有，这种想法对很多人都是难以接受的。但他们清楚在自己出生之前的很长一段漫长岁月，世界如常存在，而这并不可怕。如果死后就不复存在了，那这有什么可怕的呢？从逻辑上讲，似乎只有死后还继续存在并且经历一些可怕的转变的人才可以说死亡是可怕的。但还有很多人认为最可怕的事情就是从这个世界上彻底消失。&lt;/p&gt;
&lt;p&gt;作者在这一章里以疑问为主，但隐含自己的观点是死后一切都不存在了，将读者往这个方向引导。&lt;/p&gt;
&lt;h2&gt;生活的意义是什么？&lt;/h2&gt;
&lt;p&gt;或许你曾经想过，万事皆不重要，无非过眼云烟，因为百年之后，你就归于尘土。但这样能合理推出我们所做的一切都不重要吗？&lt;/p&gt;
&lt;p&gt;道理似乎是这样的：我们在名利场中你争我夺，想要达到自己的目标，让自己出人头地。但是除非这些成就是永恒的，否则我们所做的一切皆无意义。然而这些成就并非永恒，即使你写了一部伟大的文学作品，从今以后将被传诵千秋万代，但最后太阳系会寂灭，甚至宇宙会塌缩，一切都烟消云散，不留痕迹。&lt;/p&gt;
&lt;p&gt;想到这人们开始从自己有限的生命中寻找意义。初看起来这样寻找具体意义不会产生什么问题。比如你可以说出自己所做的大多数事情的目的所在：工作上为了养家糊口，吃饭时因为饿了，睡觉是因为困了，去散步是因为爱好，读报纸是为了知道世界发生的事情。既然如此，还会有什么问题呢？&lt;/p&gt;
&lt;p&gt;问题在于这些都只是生活整体的一部分，这些部分可以这样合理解释，而对于作为整体的生活则不同。如果把生活作为一个整体加以思考，看起来根本没有意义，跳出你自己的生命来看，即使你从未存在过，也无关紧要；在你死后，你曾存在这个事实也无关紧要。虽然对其他人（比如你的家人）来说是重要的，但解释他人生活意义时会遇到同样的问题。跳出来看，好像一切都无关紧要。&lt;/p&gt;
&lt;p&gt;有人会说这又如何？我知道生活中的每件事情对我是很重要的，这就够了，这就是我的生活，我不需要别的也能活下去。但除非你从来不想根本性的问题，不去追问生活整体有什么目的，这种回答才会奏效。而一旦开始想这类问题，也就触及了这种可能性：你的生活毫无意义。&lt;/p&gt;
&lt;p&gt;如果你的生活整体和某种更伟大的东西发生了关联，那是否意味着它并不是毫无意义的？比如参加政治运动，为了未来的世界更美好而奋斗。但这个更重大的东西又有什么意义呢？所有的这一一究竟有什么意义？&lt;/p&gt;
&lt;p&gt;生活的意义在宗教之中似乎有所不同。比如你相信生活的意义就在于满足上帝的意愿，回应上帝的爱。但这又面临需要解释上帝的问题，比如对上帝而言，这一切的意义是什么？或者根本不需要意义？&lt;/p&gt;
&lt;p&gt;即使生命作为整体是没有意义的，或许我们也不必为此担心，只需要关注眼前的事情。如果有人问“你活着到底是为了什么？”，你可以回答说“这么问毫无意义。如果说我根本不存在，或者对万物漠不关心，这也无关紧要。但是我的确存在，并且有我说关心的东西，这就够了。”这样的生活态度会让有些人感到非常满意，而让另一些人感到心灰意冷。部分原因在于有些人总是倾向把自己看得很重要，希望自己的生活整体从外部看也具有某种意义，如果没有的话则会感觉失落。人类的许多努力不仅仅是为了活得更好，还有某种更大意义的重要感。如果根本没有这样一种重要感，也许生命不仅没有意义，而且也是一处荒诞剧。&lt;/p&gt;
&lt;p&gt;生活的意义是大多数人都会想到的问题，而思考的过程也会遇到如何作者所写的困境。作者在做了人死后一无所有的假设后，最终更倾向认为人生作为一个整体没有意义的结论。但这里的论证是有很大的问题的，我甚至有点不明白，对于这个问题，作者为何如此草草了事，甚至没有对读者进行足够的引导。&lt;/p&gt;
&lt;p&gt;在讨论生活的意义时，“意义”是相对谁的？这是非常重要的问题。我们清楚同样一件事，对于不同的主体，意义显然是不同的。比如消灭害虫这件事情，对人来说意义是可以避免庄稼减产，但对以这些害虫为食的动物而言，显然不能认同这个意义，对于它们而言，这和天灾无异，甚至更加可怕。那问什么对于生活这样的事情，我们就可以只谈意义，而不提这意义是相对谁而言呢？意义是一种关系，可以说A对B来说是有什么意义。把一个人的生活作为一个整体，就必然不能说这个整体对他个人的意义了，因为他本身就包含在其中。就像说A+B（一个人生活的整体）对B（一个人本身）有什么意义一样，B不会对B本身产生任何作用（除非把B继续切分成可以互相作用的各个部分），我们必须把B抽离，也就是说A对B有什么意义，但这样A就已经不是一个人生活的整体了。而对于他的家人来说，他的生活整体显然是有意义的，甚至对整个人类也是，如果他写了一本伟大的书，正如作者所说的那样。&lt;/p&gt;
&lt;p&gt;继而作者有谈到了如果人类毁灭了这也不再有意义。但问题又来了，这意义是对谁而言呢？如果有其他生命，或者上帝之类存在，自然也有意义。如果没有了，那意义本身就不应该存在，又怎么可能找到所谓的意义呢？如果没有主体，何谈意义？&lt;/p&gt;
&lt;p&gt;那生活意义的问题应该如何思考而不陷入怪圈呢？正如之前提到的，谈意义必须明确主体，一旦主体明确就不存在任何模糊不清的情况。我们认为生活中的各种事情都有意义，正是因为我们是把自己独立于这些事情之外分析的，也就是分析这些事情对我而言有什么意义。而对于生活整体，就不能问它对我而言有什么意义了，只能去寻找其他主体。主体确定了，意义自然就确定了。但如果你真的关心你的生活整体对其他人有什么意义，为什么不去直接问其他人呢？如果你对“你对其他人有什么意义”这样的问题，都因为不感兴趣而不去亲自询问，你确定非常想知道你的存在对于整个宇宙有什么意义吗？你可以随意想象，遥远的未来人类灭绝了，有一群外星人来到地球，正巧发现了你的骨骼化石，皆由对这份化石的研究，外星人对人类有了充分的了解，你对外星人了解地球有了重大的意义。但你关心的真的是这种层面的意义吗？&lt;/p&gt;
&lt;p&gt;我想大多数人还是想问对自己有什么意义。也就是问你的完整生活中，除去你的部分，对你而言有什么意义。而这已经是非常具体的问题了，基本等同于我想要怎样的生活。&lt;/p&gt;
&lt;p&gt;作者把前提限制在人死后则一无所有，实际上相当于直接把“生活的意义”这个问题打残了，而思考不出更多东西。而如果认为死亡并不是这样的，该问题还有很多想象空间。其实想清楚“我”和“外部世界”的关系后，该问题也不再是问题。或者说该问题可以转述为“外部世界”对“我”而言的意义是什么。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;</content></entry><entry><title>《你就是自己的幸运星》读书笔记</title><link href="/ni-jiu-shi-zi-ji-de-xing-yun-xing-du-shu-bi-ji.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ni-jiu-shi-zi-ji-de-xing-yun-xing-du-shu-bi-ji.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这本书所写的是著名的10-10-10选择法则，对那些反复犹豫难以权衡的选择比较有帮助。&lt;/p&gt;
&lt;h2&gt;10-10-10法则介绍&lt;/h2&gt;
&lt;p&gt;简单得说就是做一个比较犹豫的选择时，分别考虑第一个10（10分钟内代表现在），第二个10（10个月内，可预见的未来），第三个10（10年后，指长远未来）三个时期，自己怎么看待不同选择的结果。&lt;/p&gt;
&lt;p&gt;这样做的原因是，一般面对犹豫不决的选择时，短期内（也就是第一个10）两种选择的得失一定是相差不大的，难以权衡。放大时间尺度后，会把一些现在的细枝末节忽略掉，而关心真正核心的东西。而第二个10和第三个10的递进，更容易体现出这一点，也就是更有助于发现自己真正需要的是什么。&lt;/p&gt;
&lt;p&gt;关于具体如何操作书里讲地非常透彻，无需赘言，这里重点讲些其他方面的。&lt;/p&gt;
&lt;h2&gt;10-10-10法则适用场景&lt;/h2&gt;
&lt;p&gt;从描述看该法则适合做具有长期影响力的选择，但还有一个比较重要的限制，就是这个长期影响是需要可预期的。&lt;/p&gt;
&lt;h2&gt;10-10-10法则的缺陷&lt;/h2&gt;
&lt;p&gt;从适用场景看，就会发现该法则第一个缺陷：&lt;/p&gt;
&lt;p&gt;人对长期未来的预测是非常不靠谱的。比如10年前，你会想到10年后会过上现在的日子吗？你现在还在坚持10年前的观点吗？&lt;/p&gt;
&lt;p&gt;虽然想问题可以假设自己到了10年后，但毕竟还是现在的自己，10年后自己的想法可能早已和现在不同了。如果牺牲掉现在，为了现在设想的未来，而真的到了未来，却发现自己早已不是10年前的那个自己了，又该做何感想呢？&lt;/p&gt;
&lt;p&gt;10年后怎样说起来容易 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这本书所写的是著名的10-10-10选择法则，对那些反复犹豫难以权衡的选择比较有帮助。&lt;/p&gt;
&lt;h2&gt;10-10-10法则介绍&lt;/h2&gt;
&lt;p&gt;简单得说就是做一个比较犹豫的选择时，分别考虑第一个10（10分钟内代表现在），第二个10（10个月内，可预见的未来），第三个10（10年后，指长远未来）三个时期，自己怎么看待不同选择的结果。&lt;/p&gt;
&lt;p&gt;这样做的原因是，一般面对犹豫不决的选择时，短期内（也就是第一个10）两种选择的得失一定是相差不大的，难以权衡。放大时间尺度后，会把一些现在的细枝末节忽略掉，而关心真正核心的东西。而第二个10和第三个10的递进，更容易体现出这一点，也就是更有助于发现自己真正需要的是什么。&lt;/p&gt;
&lt;p&gt;关于具体如何操作书里讲地非常透彻，无需赘言，这里重点讲些其他方面的。&lt;/p&gt;
&lt;h2&gt;10-10-10法则适用场景&lt;/h2&gt;
&lt;p&gt;从描述看该法则适合做具有长期影响力的选择，但还有一个比较重要的限制，就是这个长期影响是需要可预期的。&lt;/p&gt;
&lt;h2&gt;10-10-10法则的缺陷&lt;/h2&gt;
&lt;p&gt;从适用场景看，就会发现该法则第一个缺陷：&lt;/p&gt;
&lt;p&gt;人对长期未来的预测是非常不靠谱的。比如10年前，你会想到10年后会过上现在的日子吗？你现在还在坚持10年前的观点吗？&lt;/p&gt;
&lt;p&gt;虽然想问题可以假设自己到了10年后，但毕竟还是现在的自己，10年后自己的想法可能早已和现在不同了。如果牺牲掉现在，为了现在设想的未来，而真的到了未来，却发现自己早已不是10年前的那个自己了，又该做何感想呢？&lt;/p&gt;
&lt;p&gt;10年后怎样说起来容易，但真的做重大的选择还是不可以想当然的。&lt;/p&gt;
&lt;p&gt;另一个缺陷是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;它可能葬送掉自己的整个生活。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个方法潜在含义是选择非常重要，需要非常谨慎，并且以长远考虑为主。但有些人可能还记得，自己很多真正重要的选择往往不是深思熟虑出来的，而是靠一时激情作的，虽然这样未必好。不是说靠一时的激情作选择好，而是说选择真的那么重要吗？&lt;/p&gt;
&lt;p&gt;说得极端点，我今天中午吃饭，在犹豫吃米饭还是面条。是否需要搬出10-10-10法则推理一番？如果每一件稍有犹豫的选择都如此大做文章，活的得多累？&lt;/p&gt;
&lt;p&gt;这是一种生活习惯，10-10-10倡导的明显是非常严谨的风格，选择需要谨慎，容不得马虎。这样的生活真的好吗？我想过着这样的生活的人最清楚，别让自己变成一个选择工具。&lt;/p&gt;
&lt;p&gt;10-10-10法则偶尔用用尚可，切不可处处使用，尤其不能经常用于意义并不是那么重大的事情上。&lt;/p&gt;
&lt;p&gt;说句题外话，选择对于内心真正强大的人并不重要，因为所有可能的结果对他来说都不算什么。&lt;/p&gt;</content></entry><entry><title>《你值得过更好的生活》读书笔记</title><link href="/ni-zhi-de-guo-geng-hao-de-sheng-huo-du-shu-bi-ji.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ni-zhi-de-guo-geng-hao-de-sheng-huo-du-shu-bi-ji.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这本书的切入点是“金钱”，这是很多人会感兴趣的地方，但也不局限于金钱。作者认为金钱是一场游戏，这个观点并不算新颖，新颖的地方是作者把人生划分为两个阶段，我从没有在其他地方看过这样的观点。为了这个两阶段世界做铺垫，作者花费了不少笔墨，而且毫无例外地搬出“量子力学”作为科学根据。尽管如此，理论部分还是千疮百孔，不值得一驳。但此书的亮点不在于理论部分，而在于实践部分，不得不说实践部分值得一读。&lt;/p&gt;
&lt;h2&gt;目标读者&lt;/h2&gt;
&lt;p&gt;沉浸于金钱无法自拔的人，对于他们来说这是一盆非常及时的凉水，但是否能唤醒就不清楚了。&lt;/p&gt;
&lt;p&gt;世界观已经足够清晰，但不清楚如何实践以让自己生活变得更好的人。不会被作者描述中混乱的世界所误导，看实践部分有一些比较靠谱的方式。&lt;/p&gt;
&lt;p&gt;不满足以上两点的人阅读时需要谨慎。&lt;/p&gt;
&lt;h2&gt;金钱游戏&lt;/h2&gt;
&lt;p&gt;金钱几乎是多数人都会关心的问题，作者将金钱看做游戏不是没有理由的。&lt;/p&gt;
&lt;p&gt;“首先我们需要一个游戏是什么样子的，大多数游戏都有其规则和清晰的程序，也明确界定了开始和结束的时间，并清楚地定义了输赢。参与游戏者都同意遵守规则和游戏程序，这样才能让游戏得以进行。虽然有一些人以游戏为职业以此为生，但大多数人只是为了好玩和有趣才玩游戏。人们喜欢观看比赛，就是基于这样的理由。”&lt;/p&gt;
&lt;p&gt;比如橄榄球比赛有橄榄球比赛的规则，足球比赛有足球比赛的规则，这些规则都是非常明确的。但仔细想就会发现这些规则都是毫无道理的，一些人围着一个球转到底是为了什么呢？像桥牌、大富翁、撞球 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这本书的切入点是“金钱”，这是很多人会感兴趣的地方，但也不局限于金钱。作者认为金钱是一场游戏，这个观点并不算新颖，新颖的地方是作者把人生划分为两个阶段，我从没有在其他地方看过这样的观点。为了这个两阶段世界做铺垫，作者花费了不少笔墨，而且毫无例外地搬出“量子力学”作为科学根据。尽管如此，理论部分还是千疮百孔，不值得一驳。但此书的亮点不在于理论部分，而在于实践部分，不得不说实践部分值得一读。&lt;/p&gt;
&lt;h2&gt;目标读者&lt;/h2&gt;
&lt;p&gt;沉浸于金钱无法自拔的人，对于他们来说这是一盆非常及时的凉水，但是否能唤醒就不清楚了。&lt;/p&gt;
&lt;p&gt;世界观已经足够清晰，但不清楚如何实践以让自己生活变得更好的人。不会被作者描述中混乱的世界所误导，看实践部分有一些比较靠谱的方式。&lt;/p&gt;
&lt;p&gt;不满足以上两点的人阅读时需要谨慎。&lt;/p&gt;
&lt;h2&gt;金钱游戏&lt;/h2&gt;
&lt;p&gt;金钱几乎是多数人都会关心的问题，作者将金钱看做游戏不是没有理由的。&lt;/p&gt;
&lt;p&gt;“首先我们需要一个游戏是什么样子的，大多数游戏都有其规则和清晰的程序，也明确界定了开始和结束的时间，并清楚地定义了输赢。参与游戏者都同意遵守规则和游戏程序，这样才能让游戏得以进行。虽然有一些人以游戏为职业以此为生，但大多数人只是为了好玩和有趣才玩游戏。人们喜欢观看比赛，就是基于这样的理由。”&lt;/p&gt;
&lt;p&gt;比如橄榄球比赛有橄榄球比赛的规则，足球比赛有足球比赛的规则，这些规则都是非常明确的。但仔细想就会发现这些规则都是毫无道理的，一些人围着一个球转到底是为了什么呢？像桥牌、大富翁、撞球、西洋棋、跳棋、二十一点等其他大众游戏的规则和程序也有着同样的独断性。这些规则和程序看似独断，但它们后边却隐藏着创造这些规则与程序所需要的智慧、计划和意图。或者说这些游戏之所以这样，就是被一帮聪明的人设计用来玩的。&lt;/p&gt;
&lt;p&gt;金钱游戏也是同样的情况，相关的规则和程序同样很独断，也很不合理，但金钱游戏设计的背后，潜藏着让人叹服的智慧、设计和意图，而清楚这些内幕后可以方便从金钱游戏中彻底解脱。&lt;/p&gt;
&lt;p&gt;金钱游戏的规则：
1. 财富供给有限
2. 金钱会流动
3. 为了增加个人财富，你必须更努力或更聪明地工作&lt;/p&gt;
&lt;p&gt;一些支持金钱游戏规则和程序的信念：
1. 金钱是万恶之源
2. 钱永远都不够
3. 你必须掌管金钱，否则金钱就会掌管你
4. 钱总是越多越好
5. 钱不是长在树上的
6. 有些人有赚钱的本身，有些人没有
7. 人不可能既会赚钱又有灵性
8. 净资产才是衡量财富的标准
9. 你必须未雨绸缪&lt;/p&gt;
&lt;p&gt;所有这些都不是真的，就像所有游戏的规则一样，这些都是杜撰的。&lt;/p&gt;
&lt;p&gt;但金钱游戏和其他游戏又有不同之处：
1. 你无法在金钱游戏中获胜
2. 金钱游戏是为了创造彻底的失败而设计的&lt;/p&gt;
&lt;p&gt;无法在金钱游戏中获胜是因为：
1. 获胜没有清晰的定义
2. 你的钱总是岌岌可危
3. 没有正式的终点
4. 总有人比你更成功&lt;/p&gt;
&lt;p&gt;所以金钱游戏是这样一种游戏，永远无法知道谁获胜，没有正式终点，不管你怎么努力，最后总会是输家（因为你必须付出代价）。有些像玩或者观看这种游戏吗？没有！对玩家来说，这绝对是个噩梦。根本没有人会自愿参与并观看金钱游戏。&lt;/p&gt;
&lt;p&gt;金钱游戏和其他游戏的另一个不同之处是，在这个游戏中，没有任何事情是板上钉钉的，每件事都绝对可以商量。既然你无法在金钱游戏中获胜，你就只有两种选择：
1. 根据规则与程序继续玩，不管玩得多好，最终都会成为输家并付出昂贵代价
2. 从金钱游戏中彻底解脱，为自己创造一个新游戏，选择自己的规则，永久改变自己跟金钱的关系&lt;/p&gt;
&lt;p&gt;作者清晰地描述了金钱的这个游戏，却对为什么金钱是个游戏只字不提。实际上任何人都没有明确的证据证明金钱就是个游戏，或者更进一步，人生只是一个游戏。所有你只能选择相信，或者不相信。&lt;/p&gt;
&lt;p&gt;从第二章开始，作者开始有大量的篇幅描述两阶段世界：
1. 第一阶段，就是大多数人所处的正常人生，也就是作者所说的金钱游戏
2. 第二阶段，是从金钱游戏解脱后的世界，就像天堂一样，一切问题都不再是问题&lt;/p&gt;
&lt;p&gt;关于这两个阶段的理论部分，请直接去阅读原书，也许有些人认为很有道理，另外一些人认为简直是一派胡言，更多人阅读后会认为有所启发。&lt;/p&gt;
&lt;h2&gt;实践方法&lt;/h2&gt;
&lt;p&gt;第九章到第十一章主要是讲实践方法，也是我认为最重要的部分。&lt;/p&gt;
&lt;p&gt;作者提到了4个方法：
1. 表达赞赏和感谢
2. 流程
3. 迷你流程
4. 让话语充满力量和自我对话&lt;/p&gt;
&lt;p&gt;第一个方法很多人都提过，有道理但有没有那么有用，因为从知道过渡到做到比较困难。就想很多人知道“知足常乐”，但真正能做到的人太少了。同样在遭遇到挫折苦难时仍然会有发自内心的赞赏和感谢的人也太少了。&lt;/p&gt;
&lt;p&gt;第二个方法是最重要的，流程概述：
当你体验到任何不适时：
1. 深入情绪的中心
2. 全然感受这股让你不舒服的力量
3. 感受最强时，告诉自己真相为何
4. 从中收回自己的力量
5. 越来越绽放真正的自己
6. 向自己和创造物表示赞赏和感谢&lt;/p&gt;
&lt;p&gt;知道这个世界真相却又缺少实践方法的人，会明白这写的是什么，有怎样的价值，无需赘言。而不明白的人，如何解释都不会明白。很多书写过类似的东西，我却从未见过如此清晰具体的描述。&lt;/p&gt;
&lt;p&gt;第三个方法是第二个方法的补充，因为第二个方法是在体验到任何不适时才可以使用的。迷你流程和流程类似，只不过因为未感受到任何不适，不必要步骤1（深入情绪中心），其余步骤相似。&lt;/p&gt;
&lt;p&gt;第四个方法更多的是对前三个方法的综合运用。&lt;/p&gt;
&lt;p&gt;其余章节更多是对之前内容的总结，以及一些常见问题的回答。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;这本书总体还是可以归为好书，看完多少都会有一些收获。而阅读该书也有一定的代价，作者的煽动性较强，读之前一定要有比较多的主见，以怀疑的态度读理论部分，而不可全盘接受。如果自己的观点还没有成型，则很容易被误导而得不偿失。&lt;/p&gt;</content></entry><entry><title>让 MSYS2 支持 cygstart</title><link href="/rang-msys2-zhi-chi-cygstart.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/rang-msys2-zhi-chi-cygstart.html</id><summary type="html">&lt;p&gt;Cygwin中有一个很有用的工具，&lt;code&gt;cygstart&lt;/code&gt;，可以使用默认的程序打开任意文件，以及使用超级管理员运行命令（&lt;code&gt;cygstart --action=runas&lt;/code&gt;）等。但msys2每个这个命令，使用超级管理员运行命令的功能几乎没有替代品。&lt;/p&gt;
&lt;p&gt;但后来我想到既然msys2是从cygwin改的，应该也能编译出来&lt;code&gt;cygstart&lt;/code&gt;，折腾一番后果然可以。&lt;/p&gt;
&lt;p&gt;首先需要一个popt，PKGBUILD：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;# Maintainer: Gore Liu &amp;lt;goreliu@126.com&amp;gt;&lt;/span&gt;

&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;popt&lt;/span&gt;
&lt;span class="n"&gt;pkgver&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;1.16&lt;/span&gt;
&lt;span class="n"&gt;pkgrel&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;
&lt;span class="n"&gt;pkgdesc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A commandline option parser&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;arch&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;i686&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="n"&gt;x86_64&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://rpm5.org&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;license&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;custom&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//rpm5.org/files/${pkgname}/${pkgname …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;Cygwin中有一个很有用的工具，&lt;code&gt;cygstart&lt;/code&gt;，可以使用默认的程序打开任意文件，以及使用超级管理员运行命令（&lt;code&gt;cygstart --action=runas&lt;/code&gt;）等。但msys2每个这个命令，使用超级管理员运行命令的功能几乎没有替代品。&lt;/p&gt;
&lt;p&gt;但后来我想到既然msys2是从cygwin改的，应该也能编译出来&lt;code&gt;cygstart&lt;/code&gt;，折腾一番后果然可以。&lt;/p&gt;
&lt;p&gt;首先需要一个popt，PKGBUILD：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;# Maintainer: Gore Liu &amp;lt;goreliu@126.com&amp;gt;&lt;/span&gt;

&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;popt&lt;/span&gt;
&lt;span class="n"&gt;pkgver&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;1.16&lt;/span&gt;
&lt;span class="n"&gt;pkgrel&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;
&lt;span class="n"&gt;pkgdesc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A commandline option parser&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;arch&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;i686&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="n"&gt;x86_64&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://rpm5.org&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;license&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;custom&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//rpm5.org/files/${pkgname}/${pkgname}-${pkgver}.tar.gz)&lt;/span&gt;
&lt;span class="n"&gt;sha1sums&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cfe94a15a2404db85858a81ff8de27c8ff3e235e&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${srcdir}/${pkgname}-${pkgver}&amp;quot;&lt;/span&gt;
  &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grep&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="err"&gt;$&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;poptconfig&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ne&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
      &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="n"&gt;fi&lt;/span&gt;
  &lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/^&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;poptconfig&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;

  &lt;span class="n"&gt;make&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${srcdir}/${pkgname}-${pkgver}&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;DESTDIR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;${pkgdir}&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt;
  &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Dm644&lt;/span&gt; &lt;span class="n"&gt;COPYING&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${pkgdir}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;share&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;licenses&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;LICENSE&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后就是包含cygstart的cygutils，PKGBUILD：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;# Maintainer: Gore Liu &amp;lt;goreliu@126.com&amp;gt;&lt;/span&gt;

&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;cygutils&lt;/span&gt;
&lt;span class="n"&gt;pkgver&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;1.4.14&lt;/span&gt;
&lt;span class="n"&gt;pkgrel&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;pkgdesc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A collection of simple cygwin utilities&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;arch&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;i686&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="n"&gt;x86_64&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://cygutils.fruitbat.org/cygutils-package/index.html&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;license&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;custom&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;depends&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;popt&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://mirror.bit.edu.cn/cygwin/x86_64/release/cygutils/${pkgname}-${pkgver}-1-src.tar.bz2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sha1sums&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;f9f5ae35ba61aa6efccf9581c2b019c26ea6671a&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${srcdir}&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;tar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;xf&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pkgver&lt;/span&gt;&lt;span class="p"&gt;}.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xz&lt;/span&gt;
  &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pkgver&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;
  &lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;stricmp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;strcasecmp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lpr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Printer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cc&lt;/span&gt;

  &lt;span class="n"&gt;make&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${srcdir}/${pkgname}-${pkgver}&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;DESTDIR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;${pkgdir}&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt;
  &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Dm644&lt;/span&gt; &lt;span class="n"&gt;COPYING&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${pkgdir}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;share&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;licenses&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;LICENSE&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exe&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="n"&gt;cp&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${pkgdir}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
  &lt;span class="n"&gt;done&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;依次保存为PKGBUILD文件，运行&lt;code&gt;makepkg&lt;/code&gt;，然后使用&lt;code&gt;pacman auto -U *.pkg.*&lt;/code&gt;就可以了。&lt;/p&gt;
&lt;p&gt;更多的msys2包，https://github.com/goreliu/my-MSYS2-Packages。官方的repo对于msys2分支的PKGBUILD要求很苛刻，基本不收，之后自己维护了。如果有朋友有其他的PKGBUILD，可以一起维护。&lt;/p&gt;</content></entry><entry><title>人类是如何思维的？</title><link href="/ren-lei-shi-ru-he-si-wei-de.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ren-lei-shi-ru-he-si-wei-de.html</id><summary type="html">&lt;p&gt;人类的思维过程是怎样的？&lt;/p&gt;
&lt;p&gt;这个问题过于庞大和艰难，几乎无解。一个原因是我们试图以思维自身为工具来认识思维的内部结构，就像试图用一个显微镜来观察它自身的内部结构一样，必然存在盲点；另一个原因是我们至少现在无法直接观察他人的思维。但分析思维还有一个先天的优势。我们可以很仔细地观察外部世界，但我们确根本无法证明外部世界存在并且没有被我们的感知系统扭曲。而思维不同，它的存在无需证明，我们所接触到的思维也正是它原本的样子。&lt;/p&gt;
&lt;p&gt;关于思维的一个普遍却又极具诱导性的观点是，思维世界是外部世界的一个映射。简单地说，我看到桌子上有一个苹果，于是脑海中也产生一个苹果，外部世界和思维世界是映射的关系。这个观点让思维问题复杂化到难以分析，因为外部世界（如果有的话）是怎样的都是一个非常困难的问题。另一方面，这个观点是存在缺陷的。&lt;/p&gt;
&lt;p&gt;我们倾向于认为自己生活在三维世界，于是认为思维世界也是类似这样的一个三维世界，但很快就会发现存在很多问题。三维世界是基于视觉建立的，无法包容听觉、触觉、嗅觉等其他感官获得的信息。即使是只看视觉，三个维度也是无法描述完整的。最简单的一点，我们看到的任何东西，都是有颜色的，而三维中的三个维度，只包含位置信息，并没有颜色，我们必须添加至少一个维度来描述颜色。更麻烦的是思维会对原始信息做抽象，比如我看一行文字，理解之后文字就完全不是的样子，而变成了抽象的语义，这看起来不是用几个维度来描述的东西。&lt;/p&gt;
&lt;p&gt;我们需要弄清楚思维中的数据结构是什么，然后才能更了解思维的过程。&lt;/p&gt;
&lt;p&gt;我们看到书上写着一个数字1，于是脑海中也产生了这样的一个数字 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;人类的思维过程是怎样的？&lt;/p&gt;
&lt;p&gt;这个问题过于庞大和艰难，几乎无解。一个原因是我们试图以思维自身为工具来认识思维的内部结构，就像试图用一个显微镜来观察它自身的内部结构一样，必然存在盲点；另一个原因是我们至少现在无法直接观察他人的思维。但分析思维还有一个先天的优势。我们可以很仔细地观察外部世界，但我们确根本无法证明外部世界存在并且没有被我们的感知系统扭曲。而思维不同，它的存在无需证明，我们所接触到的思维也正是它原本的样子。&lt;/p&gt;
&lt;p&gt;关于思维的一个普遍却又极具诱导性的观点是，思维世界是外部世界的一个映射。简单地说，我看到桌子上有一个苹果，于是脑海中也产生一个苹果，外部世界和思维世界是映射的关系。这个观点让思维问题复杂化到难以分析，因为外部世界（如果有的话）是怎样的都是一个非常困难的问题。另一方面，这个观点是存在缺陷的。&lt;/p&gt;
&lt;p&gt;我们倾向于认为自己生活在三维世界，于是认为思维世界也是类似这样的一个三维世界，但很快就会发现存在很多问题。三维世界是基于视觉建立的，无法包容听觉、触觉、嗅觉等其他感官获得的信息。即使是只看视觉，三个维度也是无法描述完整的。最简单的一点，我们看到的任何东西，都是有颜色的，而三维中的三个维度，只包含位置信息，并没有颜色，我们必须添加至少一个维度来描述颜色。更麻烦的是思维会对原始信息做抽象，比如我看一行文字，理解之后文字就完全不是的样子，而变成了抽象的语义，这看起来不是用几个维度来描述的东西。&lt;/p&gt;
&lt;p&gt;我们需要弄清楚思维中的数据结构是什么，然后才能更了解思维的过程。&lt;/p&gt;
&lt;p&gt;我们看到书上写着一个数字1，于是脑海中也产生了这样的一个数字。最开始这个数字可能是以图片的形式呈现的，比如不同字体的1样子有所不同。但瞬间这个图片形式的数字就会转变成概念上的数字，它之前是用什么字体写的已经无关紧要。它似乎只是一个概念，没有各种维度，也无法分割，这样的东西在所谓的外部世界是根本不存在的。但我们不能说它不存在，因为如果它不存在，思维就不存在。或者说“存在”这个概念本身就存在误导性，“存在”是一种关系，而不是一种属性。我们说某种东西存在，必须指明它相对于什么存在，默认是相对于这个外部世界。但这种说法对思维中的东西并不适用，我们无需置疑思维的实在性，却可以怀疑外部世界的实在性，显然不应该以一个不知道是否存在的外部世界来作为思维内事物存在的参考物。&lt;/p&gt;
&lt;p&gt;因为思维本身存在，那么思维世界里的数字1，自然是相对于思维本身存在。这里就有一个重大的进展，我们完全可以不借助外部世界来分析思维。而在思维世界，这个数字1就是一个无法分割的实体。在进一步，当我们想“1+1=2”这样一个等式时，会把它拆分成几个部分：1、+、=、2。2显然也是和1类似的实体。+和=确有所不同，它是描述1与2的关系，1和2本来没有关系，是+=让它们发生联系。所有我们可以称+和=为关系。于是“1+1=2”这样一个等式在思维世界中是以实体和关系的形式存在的。我们可以想象一些更加复杂的东西，比如苹果，它是红色的，有一斤重，很美味。无论我们怎么丰富苹果的信息，总能用相互分离的实体和将实体联系起来的关系来描述。苹果、颜色红色、一斤、重量、味道、美味这些都是实体，而“的”、“是”是关系（可以这样转述，苹果的颜色是红色，重量是一斤，味道是美味）。当我们添加更多信息时，比如苹果的味道是又酸有甜，也完全可以用实体和关系来描述。&lt;/p&gt;
&lt;p&gt;这里我们就会发现，思维中的所有事物，不过是实体和关系。然后就会恍然大悟，实体和关系是用来描述信息的，而思维中恰是除了信息别无他物，我们的思维所处理的也正是信息。我们看到的、听到的、嗅到的，无不是一种信息。然后我们就不用纠结世界是几维的这种问题了，因为在思维世界，根本没有维度这个概念所有的一切就是分散在各处的很多实体，以及将实体以错综复杂的方式关联起来的关系。但要注意，我们这里讲的是思维世界里的事物，思维本身并不是实体或者关系，我们不清楚思维本身是什么，但至少它会使用某种方式来让这些实体和关系不断发生变化。&lt;/p&gt;
&lt;p&gt;然后我们就可以把思维简化成这样：思维的主体“我”会接受到以实体关系组织的信息，并操控这些实体关系，这些实体关系也会再反馈出去。我们可以把外部信息和实体关系相互转换的过程归为身体的功能，从而不在细究。而“我”和这些实体关系是如何交互的，成为核心问题。&lt;/p&gt;
&lt;p&gt;一个很常用的方法是将大脑与电脑作类比，因为二者看起来有相似之处。但一个严重的问题是电脑中似乎没有一个可以称作“我”的东西，这个类比是不完整的。但是思维真的需要“我”参与吗？很多时候，我们会下意识做某些事情，做过后才会感知到，这是事情确切地说是需要思维运作的，而“我”并不在当场。简单地说，我们的感官连绵不断地输入大量信息，但我们在每个时刻能关注的非常有限，但这些信息并没有因此流失，身体利对这些信息做了大量处理，来指挥我们的一举一动，而其中的大多数我们都不知情。我们只是思维的观察者，同时对思维有干预能力，而不是思维运作的必备品。&lt;/p&gt;
&lt;p&gt;除去自我之后，大脑和电脑的对比就清晰起来。有一个观点是人类的思维和电脑的运算存在本质的不同。经典例证是，比如我既不懂中文，也不懂英文，现在来将一句英文翻译成中文。我之所以能够翻译，就因为手边有一个词典，可以把每个英文单词翻译成中文，同时有一本中文语法手册，借助它我可以调整中文词语的结构使其更像一句话。这些都做完了后，懂得中文的人就很可能看懂了，但我还是不清楚那句英文究竟是什么意义。事实上这是机器翻译的过程，机器在翻译后显然还是不清楚原来的意思，这和同时懂得英文和中文的人，翻译过程显然是不同的。但真的由此可以得出大脑和电脑存在本质的不同吗？&lt;/p&gt;
&lt;p&gt;这里存在一个很大的误区。懂得是什么意思？我们真的懂得吗？&lt;/p&gt;
&lt;p&gt;新出生的小孩对外部世界知之甚少。我们每天给它展示一张桌子，同时和他说“桌子”二字，慢慢地他就会认为“桌子”二字和那张桌子存在某种联系，还会指着桌子说“桌子”。但它真的懂得桌子是什么吗？他不过是在思维中的两种实体之间建立了一个关系。这和词典中的中文和英文的关系没有任何区别。我们再回头看那个翻译的例子，比如我会意大利文，那边词典除了有英文和中文的对应关系，还有意大利文的解释，于是我看懂了原文。但这真的也在很大区别吗？我不过是建立了另一个关系，而意大利文和其他事物的关系是在更早时候建立的。这个关系是有终点的，比如意大利文显示某个单词是一种植物，这种植物我从未见过，那我在将这个单词和植物建立联系后，关系就终结了。我真的懂得这种植物了吗？就说我知道这种植物的叶片是什么形状的，几月开花等细节，就真的懂得了它吗？懂得究竟是什么意思？&lt;/p&gt;
&lt;p&gt;我们说懂得了，只不过是将一种我们之前不了解的东西和已知的思维实体建立关系。而那些已知的思维实体呢？我们把桌子的形状和“桌子”二字建立关系时，实际上对二字都没有更深的了解，只是建立一个关系。甚至很多时候我们每天都在用的词语，都是不清楚其确切含义的。比如“我”，我们每天都在用“我”这个字，它和各种思维中的实体建立错综复杂的关系。但仔细想我们就会发现，“我”的含义非常令人困惑。我们的思维就是这样，把很多实体用关系组织起来，但我们并没有真正了解那些实体，实体的含义实际是用关系体现的，我们必须用关系来解释实体是什么，而思考关系是什么的问题时，又必须将关系作为实体看待，从而必须借助其他关系，这变成了一种循环论证。我们自以为了解很多东西，实际上却是将各种我们之前不知道的东西以错综复杂的方式联系起来，然后使用一种不了解的东西来解释另一种，就认为自己了解了。这个看着词典翻译英文没有任何区别。&lt;/p&gt;
&lt;p&gt;想象有这样一种机器，它会将不同的东西之间建立联系。比如每天给它展示猫的照片，同时和它说“猫”的发音。慢慢地，它就会将猫照片和猫的声音存储起来，同时建立二者的联系。慢慢地，它接收到很多信息，关系变得错综复杂。事实上这就是我们人类学习的过程。我们认为思维是很复杂的，比如解一道数学题“123+345”，但仅需要实体和关系就可以解决。比如给机器分别展示1、2、+、=，它不清楚这些都是什么，全部记录下来。然后再展示1、+、1，它发现这连续出现的3个东西之前都有记录，于是认为三者有联系，但还是不清楚是什么联系，记录下来。然后再展示“1 + 1”、“=”、“2”，它又发现这三者之前也有记录，认为三者有联系，但还是不知道是什么联系，记录下来。然后再展示“1+1 =”，它发现这和自己记录的“1+1=2”很像，但缺了一部分，于是找出2来凑出之前的记录。但它还是不知道这是什么意思。不过到这里是否知道是什么意思已经不重要了，它已经会算“1+1”了，同理它就会慢慢学会如何算“123+345”。我们的学习过程也是一样的，并不比机器更聪明。而任何问题都是这样的。但可以这样做的前提是机器中的程序会记录展示给它的东西，并建立相互的联系，这是一个非常简单的程序，大脑也是一样。但随着实体关系积累得越来越多，机器和大脑的能力就越来越强。&lt;/p&gt;
&lt;p&gt;人的思维就是这样一种简单的过程。最初我们几乎一无所知，但感官不断给我们输入各种各样的东西，思维的固有程序会将其存储，并建立联系，从而越来越强大。&lt;/p&gt;
&lt;p&gt;但“我”的加入让问题复杂化了。我们之前那个机器中是没有“我”的，现在我们试图将“我”引入其中。这个“我”可以观察机器思维中的实体和关系，并对其干预。这个“我”并不清楚思维的运行原理，就像我们并不清楚实体是怎么被建立联系的，只知道它们被建立的联系。“我”可以干预机器中程序的运行，它必须有软件的一部分，但其他部分就很难理解。“我”并没有机器固有程序的源代码，否则就会清楚思维的运作过程。在“我”看来，机器程序是一个黑盒，数据被它以各种方式调整着。“我”不清楚“我”这个程序如果运作，因为“我”只能看到这个程序对数据输入&lt;/p&gt;</content></entry><entry><title>人生的道路上，我走到哪里了</title><link href="/ren-sheng-de-dao-lu-shang-wo-zou-dao-na-li-liao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ren-sheng-de-dao-lu-shang-wo-zou-dao-na-li-liao.html</id><summary type="html">&lt;p&gt;我曾经想，如果我的生命只剩下最后一段时间，我会做些什么。
当时的答案是：
如果只剩一天到一周，那么关掉手机，不再和任何人联系，在这个城市随便走走。
如果只剩下一周到一个月，立即办理离职，在这个城市走走，然后回家住几天。
如果只剩下一个月到五年，立即办理离职，在这个城市走走，然后回家住几天，最后在一个安静的海边城市渡过剩余的时间。
如果剩下五年以上呢？我有些犹豫了。因为我不能保证自己的积蓄足够我的花销。而且我是否能够活五年也是一个未知数吧。&lt;/p&gt;
&lt;p&gt;然而第二天，生活依然按照之前的轨迹继续着，我也只是偶尔想想类似的问题。&lt;/p&gt;
&lt;p&gt;现在，我想说我之前想到的都做到了，在我尚不清楚自己还能活多久的前提下。&lt;/p&gt;
&lt;p&gt;离职后的半个月时间，我在北京随意走了走，工作了四年多，对这里还是有感情的吧。让我没想到的是，我连续去了七天图书馆。我还是迫切地想知道一些一直困扰我的问题，比如这个世界真实的面目是怎样的，比如时间到底是什么。虽然我有了一些想法，但并不完善。我看了一些书，有了一些新想法，但也仅此而已。然后我就突然不想去图书馆了，于是在我经常去的地方走走。&lt;/p&gt;
&lt;p&gt;然后我回家待了一个月。工作以来，我从未在家待上超过十天。我不喜欢这种不自由的感觉，不喜欢被爸妈当孩子一样对待。我知道他们想对我好，但并不清楚怎样才是真的对我好 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;我曾经想，如果我的生命只剩下最后一段时间，我会做些什么。
当时的答案是：
如果只剩一天到一周，那么关掉手机，不再和任何人联系，在这个城市随便走走。
如果只剩下一周到一个月，立即办理离职，在这个城市走走，然后回家住几天。
如果只剩下一个月到五年，立即办理离职，在这个城市走走，然后回家住几天，最后在一个安静的海边城市渡过剩余的时间。
如果剩下五年以上呢？我有些犹豫了。因为我不能保证自己的积蓄足够我的花销。而且我是否能够活五年也是一个未知数吧。&lt;/p&gt;
&lt;p&gt;然而第二天，生活依然按照之前的轨迹继续着，我也只是偶尔想想类似的问题。&lt;/p&gt;
&lt;p&gt;现在，我想说我之前想到的都做到了，在我尚不清楚自己还能活多久的前提下。&lt;/p&gt;
&lt;p&gt;离职后的半个月时间，我在北京随意走了走，工作了四年多，对这里还是有感情的吧。让我没想到的是，我连续去了七天图书馆。我还是迫切地想知道一些一直困扰我的问题，比如这个世界真实的面目是怎样的，比如时间到底是什么。虽然我有了一些想法，但并不完善。我看了一些书，有了一些新想法，但也仅此而已。然后我就突然不想去图书馆了，于是在我经常去的地方走走。&lt;/p&gt;
&lt;p&gt;然后我回家待了一个月。工作以来，我从未在家待上超过十天。我不喜欢这种不自由的感觉，不喜欢被爸妈当孩子一样对待。我知道他们想对我好，但并不清楚怎样才是真的对我好。他们本可以有自己的生活，而不是把生活重心放到别人身上，却早已不清楚自己这一生的真正目的。但我不想改变他们，因为我清楚如果一个人自己不想改变，其他人的举动都是徒劳的。在家的期间，我做了一个十天的短期的旅行。结果证实了我之前的想法，我不喜欢到处走，比较累，花销也难以控制。&lt;/p&gt;
&lt;p&gt;然后，我搬到了一个坐在床上就可以看到海的地方，现在过去了一周多。&lt;/p&gt;
&lt;p&gt;以上的文字也许有些敷衍，因为这并非是我真正想写的，就当交代下背景吧。&lt;/p&gt;
&lt;p&gt;这段时间，我看了两本让我比较有触动的书，一本是还在北京时在图书馆看的，《深度唤醒 · 一位心理学家的潜医识之旅》，另一本是出去玩的某天晚上在酒店看的，《西魂》。这两本书作者的经历很相似，经历了一场事故后，对人生有了深刻的反思。&lt;/p&gt;
&lt;p&gt;钟灼辉（《深度唤醒 · 一位心理学家的潜医识之旅》作者）在“死后”面临这样一个问题：你想要离开还是留下？这是人生的最后问题。&lt;/p&gt;
&lt;p&gt;“我陷入了满足与空虚的两极，迷惘与现实的起讫之间，最后连离开或留下的决定也做不了。”&lt;/p&gt;
&lt;p&gt;“我把所有的梦想在三十岁前努力地完成了，因而在刚过三十岁生日那天，我并没有许下任何愿望，我感到人生已经满足了。所以‘离开’是当时飞机意外时第一个闪进来的选择。”&lt;/p&gt;
&lt;p&gt;“当我准备带着满足的心离开时，突然我感觉一阵莫名的心痛，无尽的空虚和悲伤像掏空了我的心。我才发现原来我的人生已经没有梦想了，我的生命里再没有让我依恋不舍的东西，我不需要任何人，也没有任何人需要我。原来，我是多么的孤单与空虚，这感觉就像一个从来没有真正活过的人，不曾存在于这个世界上。”&lt;/p&gt;
&lt;p&gt;“我的心一点也不自由，原来三十多年来自己一直跟空虚在赛跑，不停地制造梦想来逃避人生的空白。原来，梦想达成不如依然有梦。”&lt;/p&gt;
&lt;p&gt;“离开，是因为梦想达成；留下，是因为没有真正活过。”&lt;/p&gt;
&lt;p&gt;“我因为回答不了自己人生的最后问题，所以被遣返回自己破烂的身体。这既不是离开，也没有留下，只是单纯地返回自己，等准备好以后再回去作答。”&lt;/p&gt;
&lt;p&gt;这些分析是非常深刻的。然而并非所有人都和作者一样“好运”，接受了死亡的考验。当时我也陷入了沉思，我的那些梦想，也同样是用来逃避人生空白的吗？当我的人生不再有梦，我会怎样？&lt;/p&gt;
&lt;p&gt;如今，当我曾经的梦想逐一实现后，我打算重新思考这一问题。&lt;/p&gt;
&lt;p&gt;大学之前，我想要好的学习成绩。这或许不是我真的想要的，但其他人认为它很重要，我信了。我的学习成绩从来没有让我失望过。&lt;/p&gt;
&lt;p&gt;大学的几年里，我想玩，于是荒废了几年。然后我意识到有一个用来谋生的工作是必要的，于是找到了喜欢的工作。&lt;/p&gt;
&lt;p&gt;工作后，我发现用自己的努力创造价值是让人兴奋的，同时我得到了金钱。虽然没有那么多，但足够我买各种想要的东西，直到我发现再没什么东西能让我买了后感觉更幸福。&lt;/p&gt;
&lt;p&gt;我想去各种地方玩，直到我发现在任何地方面对的都是同一个自己。我想要经历更多事情，我做到了，并且学会了做清明梦，在梦中那个比现实世界更广阔的地方，我可以做任何自己想做的事情，但我却不想花费精力去做了，经历过的无不是过眼烟云。&lt;/p&gt;
&lt;p&gt;我开始想人这一生活着是为了什么，我变得前所未有的迷茫与痛苦。但最后我做到了。我想要自由，但自由不是争取来的。自由是与生俱来的，而自由的天敌是欲望，当所有的欲望逐一消失，自由便在最近的地方。&lt;/p&gt;
&lt;p&gt;梦想是经过华丽包装的欲望。欲望最初很小，得到满足后便会消失。理性可以让欲望暂时得不到满足，但理性是很脆弱的，它只能将欲望慢慢养大，却无法将其消灭。而越大的欲望越难以得到满足，直到有一天，欲望吞噬了理性，得到满足后消失不见。而重生的理性面对着新生的欲望试图继续同样的过程。&lt;/p&gt;
&lt;p&gt;在欲望的牵引下人形如机器，自由被深深压抑，人慢慢不再清楚生命最初的样子。最美好的东西往往是与生俱来的，比如健康的身体，比如自由，比如爱。欲望最初也是美好的，它像五彩的浪花，让生命更加丰富多彩。而对欲望的压制让生命的路线越偏越远，得不到满足的欲望也变得愈发狰狞。&lt;/p&gt;
&lt;p&gt;人这一生很简单，就是做自己想要成为的自己，这便是自由。没有人有权利规定怎样的人生是好的，或是坏的，是有意义的，或是无意义的，是成功的，或是失败的，是正常的，或是异常的。没有人有义务为别人的人生负责，即使是最亲近的父母或者最亲密的爱人。没有人可以提供现成的答案，那是别人的，答案来自内心，而不是外在。每个人都是知道自己这一生是来做什么的，只是被越来越多外在的东西蒙蔽了双眼，而难以识别内心中最真实的东西。或许这是这个时代或者这个社会的悲哀，但怨天尤人并不能解决问题。即使这样，做最真实的自己也并非难于登天。&lt;/p&gt;
&lt;p&gt;我很庆幸在年轻的时候付出很小的代价就得到了自己想要的答案，成为了最真实的自己。&lt;/p&gt;
&lt;p&gt;我知道在人生的道路上，我并未走到尽头。因为人生的道路不是单向的，它像一个平面，在上面可以任意作画，而没有真正意义的尽头。现在我还是经常有一些欲望，但我不再试图克制欲望，满足后自会消失不见。而欲望也变得越来越简单和容易实现。我只想这样安静地活着，听从内心的声音做自己想做的事情。或许有一天我发现人生的旅程是时候该告一段落了，我便会踏上新的旅程，我相信这段旅程是不会留下遗憾的。&lt;/p&gt;</content></entry><entry><title>如何更有效地使用键盘？</title><link href="/ru-he-geng-you-xiao-di-shi-yong-jian-pan.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ru-he-geng-you-xiao-di-shi-yong-jian-pan.html</id><summary type="html">&lt;p&gt;键盘是很多人经常使用的工具。打字机的键盘用于打字，但电脑的键盘不只用于打字，更多情况用于控制软件的行为。但键盘的键位还是以字母键为主，控制键基本位于不好按的边缘位置。但软件默认快捷键基本都是 Ctrl + a、Alt + b、Ctrl + Alt + c 这样，并不好按。更重要的是，除了 Vim 等少数软件，多数软件在非文字编辑状态是不响应直接的字母按键的，控制这样的软件，放着手指正下方下的字母键不能用，却要去找边边角角的 Ctrl、Alt、Win、Home、End、PgUp、PgDn 等按键十分不合常理。&lt;/p&gt;
&lt;p&gt;其实效率只是一方面，我不是很注重的一方面。在我看来，电脑是各种机器的结合体，比如听歌看电影时是播放器，看书看图片时是浏览器，存放文件时是存储器，而打字机也只是其中的一种机器，而且对于很多人来说，并不是最常用的一种。当我用单独的字母按键操纵一台电脑时，我感觉这真的是一台机器，每个按键都是一个按钮，按下去就给机器发送了指令，控制这台机器会用一种淋漓畅快的感觉。但如果我只能按 Ctrl、Alt …&lt;/p&gt;</summary><content type="html">&lt;p&gt;键盘是很多人经常使用的工具。打字机的键盘用于打字，但电脑的键盘不只用于打字，更多情况用于控制软件的行为。但键盘的键位还是以字母键为主，控制键基本位于不好按的边缘位置。但软件默认快捷键基本都是 Ctrl + a、Alt + b、Ctrl + Alt + c 这样，并不好按。更重要的是，除了 Vim 等少数软件，多数软件在非文字编辑状态是不响应直接的字母按键的，控制这样的软件，放着手指正下方下的字母键不能用，却要去找边边角角的 Ctrl、Alt、Win、Home、End、PgUp、PgDn 等按键十分不合常理。&lt;/p&gt;
&lt;p&gt;其实效率只是一方面，我不是很注重的一方面。在我看来，电脑是各种机器的结合体，比如听歌看电影时是播放器，看书看图片时是浏览器，存放文件时是存储器，而打字机也只是其中的一种机器，而且对于很多人来说，并不是最常用的一种。当我用单独的字母按键操纵一台电脑时，我感觉这真的是一台机器，每个按键都是一个按钮，按下去就给机器发送了指令，控制这台机器会用一种淋漓畅快的感觉。但如果我只能按 Ctrl、Alt 这些辅助键的同时再按字母，才能实现一种功能，那这只是伪装成另一种机器的打字机，并不是一个键还是两个键的问题，这有着本质的不同。&lt;/p&gt;
&lt;p&gt;提到单按键功能，不得不提 Vim 。提起 Vim 的特点，很多人说多模式。这确实是很重要的特点，但我感觉这不是最基本或者最重要的。最基本也最重要的特点是单字母键即功能。Vim 是多模式，一方面因为键盘按键数量有限，另一个很重要的原因是 Vim 是编辑器，在操作编辑器时，键盘兼任输入字母和控制功能两部分工作，如果单字母即功能，必然要实现成多模式。这也造成了 Vim 操作的复杂性，Vim 没有变成编辑器的主流（虽然用户已经不少了）。&lt;/p&gt;
&lt;p&gt;但并不是所有的软件都这样。除了文字编辑器，我们在使用其他大多数软件的过程中，很少需要输入文字，多数情况是在给软件发生一个特定的指令来控制某个功能，比如让播放器播放下一首歌，让浏览器显示一个超链接的内容。这样的软件，应该让单字母键成为功能键（同时不用像 Vim 那样设计成多模式），而不是使用复杂的Ctrl、Alt等。但因为种种原因，很少有软件这么做，导致在很多人看来，快捷键都成了摆设，除了寥寥几个非常常用的，记不住，不好按，还不如直接点菜单。&lt;/p&gt;
&lt;p&gt;个人感觉，可以考虑给软件实现这样一个交互界面。在主界面可见的功能附近都显示一个字母，直接按字母和用鼠标操作是相同的。对于主界面不可见的功能，可以方便调出按键提示，显示其他按键对应的功能是什么，作为菜单的一种替代。而连续的多个按键，作为子菜单的替代。当功能过多时，可以考虑使用 Ctrl、Alt 等组合键，但是在单字母已经不够用的情况下。用带说明的快捷键列表代替菜单，有很多好处。因为菜单并不是一个很好的设计，它当然有它的优点，比如直观、形象，如果只是试用一下这个软件，那么很好。但操作便捷性上很成问题，而且难于记忆。当我使用了几次用 p 键来发播放器的播放指令后，我就可以记住了。但如果播放功能在菜单的第 4 项，即使我用了几十次，还很难记住它的位置，更不会通过数字 4 来直接触发这个功能（菜单上有快捷键就是另一回事了，这个菜单本身无关）。当一个软件菜单栏布满密密麻麻的菜单，有些菜单还有几层子菜单，有些功能对应着莫名其妙的复杂快捷键，其余功能直接没有快捷键，就可以想想这个软件的长期用户是怎样的痛苦了。&lt;/p&gt;
&lt;p&gt;当然这只是题外话。现有的软件已经是这样了，我们不可能重新开发一遍，但这并不意味我们没有其他办法改善操作体验。&lt;/p&gt;
&lt;p&gt;再来仔细看一下我们熟悉的键盘：&lt;/p&gt;
&lt;p&gt;&lt;img alt="键盘键位" src="/images/008.gif"&gt;&lt;/p&gt;
&lt;p&gt;正常情况我们的手是在 asdf jkl; 空格 左Alt（左拇指一般能落在左Alt键上，但右拇指一般只能落在空格键上，不然很不舒服） 10个键上的。只有按这10个键是不用移动手指的，也是最方便的。&lt;/p&gt;
&lt;p&gt;退而求其次的话，只移动一个键位就能按到的，有几乎全部的其余字母键、'、CapsLock、/、Shift、右Alt。而常用的Ctrl、Tab、Esc、回车、方向键、编辑区键等继续被排除在外了。以我通常的经验，在以上这些键之外，盲打的错误率会显著提高，即使像我这样的电脑爱好者，也无法做到盲打顶端数字键、编辑区键（Home、PgUp之类，笔记本键盘的键位还不统一）、F1~F12、和部分符号键。即使有人熟练到能全键盘盲打，打这些边边角角的键和打字母的效率也是不一样的。也就是说，对于多数人，除了字母键和少数控制键，按其他键之前都是需要先看下键盘的。&lt;/p&gt;
&lt;p&gt;可以想象如果一个软件的快捷键都是Ctrl + F3、Alt + F6、Shift + End 这些，一方面需要记忆这些和功能几乎不相干的按键，一方面又要看键盘上的按键位置，有多少人愿意用，除非某个功能太常用了，已经形成条件反射了（比如Alt + f4，很多人都知道和使用这个快捷键，几乎是一个奇迹，但有人能记得Alt + f3在某个软件有什么功能吗）。&lt;/p&gt;
&lt;p&gt;但如果释放单字母键的控制功能，那么a-z直接就有了26个功能，对于不复杂的软件已经足够了。如果不够的话，Alt加字母，又有26个。如果还不够，Shift加字母，也就是大写字母，又是26个。Alt和Shift都要比Ctrl好按。如果还不够，Ctrl加字母，又26个。已经超过100个了，什么软件还不够用？软件操作确实复杂得很的话，上双字母键，26*26，直接676个，即使是双字母键，也比Ctrl+数字键好按，有必要上Ctrl+F1、Ctrl+Shift+e这些不好按或者复杂按键吗？&lt;/p&gt;
&lt;p&gt;用单字母键的另一个优势，在于字母是可以和功能相关的。比如在文件处理器中，我要编辑一个文件，Edit，我首先就想到了e，这几乎是不用记忆的事情。但如果这个快捷键是ctrl+e，就不一样了，我想到了e，但还得接着想是ctrl+e呢，还是alt+e呢，甚至ctrl+shift+e？复杂性剧增。算了，想不起来了，还是去找菜单吧……&lt;/p&gt;
&lt;p&gt;那么如何安排这些字母呢？&lt;/p&gt;
&lt;p&gt;我们可以先了解下现在系统和软件是如何使用组合键的，以Windows系统为例，Linux和Windows差别不大，OSX有些不同，但道理上差不多的。&lt;/p&gt;
&lt;p&gt;Win 键：用于系统功能。比如打开搜索框、文件管理器、系统配置界面、投影设置等。但并未占满所有 Win+字母，少有其他软件使用 Win 键。&lt;/p&gt;
&lt;p&gt;Ctrl 键：一般是软件中的首选组合键。如果软件想添加一个快捷键，一般从 Ctrl + 字母数字开始。系统自身很少用Ctrl键。&lt;/p&gt;
&lt;p&gt;Alt 键：系统中用于窗口、菜单等操作，比如关闭窗口、打开菜单、定位控件等，一般 Alt + 字母键不直接对应软件的某项具体功能。&lt;/p&gt;
&lt;p&gt;Shift 键：一个只用于输入大写字母。另外当软件的 Ctrl + 字母数字不够用时，一般会用 Ctrl + Shift + 字母数字，这是一系列非常难按的快捷键，而且一般人都很难记住。&lt;/p&gt;
&lt;p&gt;F1~F12：某些软件会将其作为功能键，但不是很多。除了直接使用，还有用 Ctrl + F1~F12 的情况，异常难按的组合。&lt;/p&gt;
&lt;p&gt;右 Alt 键、右 Ctrl 键和右 Shift 键：功能一般和左边的一样，但人们一般习惯按左边的，很少按右边的。也确实比左边的难按（右拇指要移动才能按到右 Alt，右小指要应付的符号键太多了，顾不上右 Ctrl 和右 Shift 了）。&lt;/p&gt;
&lt;p&gt;编辑区键（Home、Delete、Backspace等）：除了常用的 Delete、Backspace，其他的几乎都成了鸡肋。很多使用多年电脑的人甚至没按过几次 PgUp 和 PgDn（包括我）。而 Backspace 和 Delete 都不大好按，尤其是 Delete，位置还和具体键盘有关，但它太重要了，不好按也得按。&lt;/p&gt;
&lt;p&gt;方向键：比较常用的按键，但需要把手整体移动到键盘右下方才能按到，非常不方便。&lt;/p&gt;
&lt;p&gt;回车键：几乎是整个键盘最重要的按键了（打字时（英文直接打空格，中文选字词）最重要的是空格，控制时最重要的是回车，虽然某些界面上空格和回车是一样的功能，但按空格总感觉有些没底，没有回车靠谱，比如空格总容易多按几个）。但这么重要的按键需要照顾很多按键的右小指移动两个键位才能按到，真是苦了它了。&lt;/p&gt;
&lt;p&gt;那我们设想重新安排一下按键，先从系统功能开始。&lt;/p&gt;
&lt;p&gt;已有的几个 Win + 字母 快捷键是不用动的，而且有的改不了（比如 Win + l）。但除此之外还有一些未使用的 Win + 字母。因为 Win 按键不如左 Alt 和 Shift 好按，可以设置一些不常用的全局功能。比如启动某些常用的软件。一般常用的软件有限，剩余的字母基本够用了，如果不够的话，剩下的基本都不是那么常用的了，估计也未必能记得住快捷键，可以用在快捷启动软件（如 Launchy）直接敲软件名。&lt;/p&gt;
&lt;p&gt;除了系统功能，剩下的就都和具体的软件相关了。&lt;/p&gt;
&lt;p&gt;首先我们需要一系列全局快捷键，用来解决回车、Backspace、Delete、方向键等常用按键位置别扭、窗口操作快捷键复杂等问题。考虑到键盘上最好按的组合键是左 Alt （左拇指可以直接放在上边），所以非左 Alt + 字母莫属。这一系列快捷键在所有软件都是可用的，因为基本没有软件直接用 Alt + 字母作为功能键，所以基本上说可行的。对于不常用的 Alt 定位控件场景，可以用右 Alt 操作（右拇指按右 Alt 相对还是比较方便的，没有右 Ctrl 和右 Shift那么难堪）。&lt;/p&gt;
&lt;p&gt;然后剩余的按键都归具体软件所属了，也就是同一个快捷键，在不同的软件的功能很可能是不一样的。&lt;/p&gt;
&lt;p&gt;首先安排的自然是单字母键，26个，用来处理最常用的功能。设置时，要同时考虑操作的便捷和语义的联系。有一些约定俗成的习惯可以参考，比如j、k、h、l用于方向，q用于退出，e用于编辑，x用来删除等。但因为不同的软件功能完全不同，不用拘泥于此，具体场景具体分析，按得舒服就好。&lt;/p&gt;
&lt;p&gt;如果单字母键不够用了，优先考虑左 Shift + 字母，也就是大写字母，因为除了左 Alt 外，最方便的组合键就是左 Shift 了（当然可以考虑互换 CapsLk 和 Shift，但对 Vim 用户来说，互换 Esc 和 CapsLk 也许更合适一些）。&lt;/p&gt;
&lt;p&gt;如果大写字母也不够了，再考虑 Ctrl + 字母，Ctrl 虽然在键盘的位置不是很好，但大家 Ctrl + c、Ctrl + v 用习惯了，倒也还好。&lt;/p&gt;
&lt;p&gt;如果还不够的话，就不要再考虑 Ctrl + Shift 之类组合了，直接上双键吧。但上双键也是有策略的，比如有一个双键 ad，那么 a 就不能当单键使用了。但一个 a 换来了 26 个双键，具体怎么用就好权衡了。一般拿出几个键来做双键前缀就可以了，没有必要大动干戈。如果需要超过5个双键前缀，就需要直接考虑多模式（比如增加一个命令模式，进去后直接敲命令然后回车）了。&lt;/p&gt;
&lt;p&gt;当然如果以上只是空想就没什么意思了。&lt;/p&gt;
&lt;p&gt;下面是我设计的左 Alt 键组合功能，这些功能在所有软件都是可用的（当然能否发挥作用要看具体软件了）：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/goreliu/vimdesktop/wiki/%E5%85%A8%E5%B1%80%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%88%97%E8%A1%A8%EF%BC%88%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89"&gt;全局快捷键列表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体软件的话，以 Total Commander 为例。因为文件操作是非常复杂的，我一共映射了全部小写字母（包含一些双键）、全部大写字母、全部 Ctrl + 字母、全部的F1~F12、大部分键盘右侧符号等，一共120多个按键组合，论复杂可以说无出其右了。当然我不可能全部记住，实际使用时是可以打开按键帮助和补全提示的，要比去菜单找功能方便很多。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/goreliu/vimdesktop/wiki/TC%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%88%97%E8%A1%A8%EF%BC%88%E5%AD%97%E6%AF%8D%E9%A1%BA%E5%BA%8F%EF%BC%89"&gt;按字母排序&lt;/a&gt;
&lt;a href="https://github.com/goreliu/vimdesktop/wiki/TC%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%88%97%E8%A1%A8"&gt;按功能排序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后也是最关键的，如果自己设计出了一套适合自己的快捷键方案，如何实现呢？&lt;/p&gt;
&lt;p&gt;这就要推荐一下 VimDesktop 软件。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/goreliu/vimdesktop"&gt;VimDesktop主页&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然它名里带 Vim ，但对不熟悉 Vim 的朋友也完全使用，可以随意按照自己的心意修改按键。以上的按键列表都是默认配置中内置的。修改的话直接改配置文件就可以，很方便。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;la-h&amp;gt;=&amp;lt;left&amp;gt;[=normal]
&amp;lt;la-i&amp;gt;=&amp;lt;home&amp;gt;[=normal]
&amp;lt;la-j&amp;gt;=&amp;lt;down&amp;gt;[=normal]
&amp;lt;la-k&amp;gt;=&amp;lt;up&amp;gt;[=normal]
&amp;lt;la-l&amp;gt;=&amp;lt;right&amp;gt;[=normal]
&amp;lt;la-m&amp;gt;=&amp;lt;WindowMax&amp;gt;[=normal]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;la即左 Alt，无需文档就可以看懂按键的功能。&lt;/p&gt;
&lt;p&gt;如果需要对某个软件定制快捷键方案，添加插件也是非常方便的。以自带的 WinMerge 软件为例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;WinMerge:
    ; 功能注释，可选
    vim.comment(&amp;quot;&amp;lt;WinMerge_NextDiff&amp;gt;&amp;quot;, &amp;quot;下一处不同&amp;quot;)
    vim.comment(&amp;quot;&amp;lt;WinMerge_PrevDiff&amp;gt;&amp;quot;, &amp;quot;上一处不同&amp;quot;)
    vim.comment(&amp;quot;&amp;lt;WinMerge_FirstDiff&amp;gt;&amp;quot;, &amp;quot;第一处不同&amp;quot;)
    vim.comment(&amp;quot;&amp;lt;WinMerge_LastDiff&amp;gt;&amp;quot;, &amp;quot;最后一处不同&amp;quot;)
    ; 省略若干行

    ; normal模式
    vim.mode(&amp;quot;normal&amp;quot;, &amp;quot;WinMergeWindowClassW&amp;quot;)

    vim.map(&amp;quot;j&amp;quot;, &amp;quot;&amp;lt;WinMerge_NextDiff&amp;gt;&amp;quot;, &amp;quot;WinMergeWindowClassW&amp;quot;)
    vim.map(&amp;quot;k&amp;quot;, &amp;quot;&amp;lt;WinMerge_PrevDiff&amp;gt;&amp;quot;, &amp;quot;WinMergeWindowClassW&amp;quot;)
    vim.map(&amp;quot;gg&amp;quot;, &amp;quot;&amp;lt;WinMerge_FirstDiff&amp;gt;&amp;quot;, &amp;quot;WinMergeWindowClassW&amp;quot;)
    vim.map(&amp;quot;G&amp;quot;, &amp;quot;&amp;lt;WinMerge_LastDiff&amp;gt;&amp;quot;, &amp;quot;WinMergeWindowClassW&amp;quot;)
    ; 省略若干行
return

&amp;lt;WinMerge_NextDiff&amp;gt;:
    Send, !{down}
return

&amp;lt;WinMerge_PrevDiff&amp;gt;:
    Send, !{up}
return

&amp;lt;WinMerge_FirstDiff&amp;gt;:
    Send, !{home}
return

&amp;lt;WinMerge_LastDiff&amp;gt;:
    Send, !{end}
return

; 省略若干行
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里是用按键映射来实现的，如果软件的功能对应着快捷键，这是最容易实现的方法。如果没有的话，看看是否有可用的Com对象、消息接口、命令行工具等，如果都没有，可以再看下能否模拟菜单点击，甚至模拟鼠标操作。如果都搞不定，那就没有办法了。&lt;/p&gt;
&lt;p&gt;代码是 &lt;a href="https://autohotkey.com/"&gt;AHK&lt;/a&gt; 写的，AHK 最方便的地方在于：
1. 可以很容易地处理按键相关的操作，比如按某些键执行某些功能。
2. 可以用最简单的环境（仅需要一个不足1M的AutoHotkey.exe，加一个顺手的编辑器），就可以开发不复杂的图形界面软件（用其他语言或者开发工具一般要安装体积庞大的环境才可以开发）。
3. 可以很方便地调用COM对象和Win32 API。&lt;/p&gt;
&lt;p&gt;用来开发这样的软件实属绝配。&lt;/p&gt;</content></entry><entry><title>如何能做到宽容</title><link href="/ru-he-neng-zuo-dao-kuan-rong.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ru-he-neng-zuo-dao-kuan-rong.html</id><summary type="html">&lt;p&gt;很多人清楚宽容是一种很好的品质，但做到宽容还是一件不大容易的事情。如果去网上搜这个问题，找到的答案往往就如同圣人的行为指南一样，难以实施。&lt;/p&gt;
&lt;p&gt;我也一直在思考这个问题，清楚自己在很多地方不够宽容，而不宽容直接的结果是对自己产生了不好的影响，而不是对别人。比如我在网上看到了一条自以为非常偏激的言论，我很难做到对这条言论甚至发这条言论的人做到宽容，因此我也不会感觉到自己像刚喝过冰镇的柠檬果汁一般舒服。但发这条言论的人不会感觉到我的存在，无论我是否宽容，对他都没有任何直接的影响。而我是否宽容他，对我自己的影响很大。这里边似乎有矛盾，如果宽容是为了别人的话，为什么不宽容在很多情况对别人构不成影响，这其中必然有不对劲的地方。&lt;/p&gt;
&lt;p&gt;于是我发现个一个很大的误区：宽容的目的是对别人好，是爱别人的一种体现，是一种非常难得的崇高品质。恰恰相反，宽容的目的是对自己好，是爱自己的一种体现，和别人没有直接的关系。宽容也并不那么崇高，对别人宽容（对自己宽容自然更是如此）实质就是对自己好，就像自己饿了然后去吃东西一样，是一种非常自然的行为。没有人会说给饿了的自己吃东西是一种崇高的品质，但人们不需要被教导，就可以掌握这一行为。于是如何能做到宽容，就有了突破口，就是改变自己曾经对宽容的误解。&lt;/p&gt;
&lt;p&gt;关于宽容，有一个很难回答问题，就是“我为什么要宽容”。比如别人把我的衣服弄脏了，我可以选择宽容或者不宽容，那么“我为什么要宽容他”就成了一个很难回答的问题 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;很多人清楚宽容是一种很好的品质，但做到宽容还是一件不大容易的事情。如果去网上搜这个问题，找到的答案往往就如同圣人的行为指南一样，难以实施。&lt;/p&gt;
&lt;p&gt;我也一直在思考这个问题，清楚自己在很多地方不够宽容，而不宽容直接的结果是对自己产生了不好的影响，而不是对别人。比如我在网上看到了一条自以为非常偏激的言论，我很难做到对这条言论甚至发这条言论的人做到宽容，因此我也不会感觉到自己像刚喝过冰镇的柠檬果汁一般舒服。但发这条言论的人不会感觉到我的存在，无论我是否宽容，对他都没有任何直接的影响。而我是否宽容他，对我自己的影响很大。这里边似乎有矛盾，如果宽容是为了别人的话，为什么不宽容在很多情况对别人构不成影响，这其中必然有不对劲的地方。&lt;/p&gt;
&lt;p&gt;于是我发现个一个很大的误区：宽容的目的是对别人好，是爱别人的一种体现，是一种非常难得的崇高品质。恰恰相反，宽容的目的是对自己好，是爱自己的一种体现，和别人没有直接的关系。宽容也并不那么崇高，对别人宽容（对自己宽容自然更是如此）实质就是对自己好，就像自己饿了然后去吃东西一样，是一种非常自然的行为。没有人会说给饿了的自己吃东西是一种崇高的品质，但人们不需要被教导，就可以掌握这一行为。于是如何能做到宽容，就有了突破口，就是改变自己曾经对宽容的误解。&lt;/p&gt;
&lt;p&gt;关于宽容，有一个很难回答问题，就是“我为什么要宽容”。比如别人把我的衣服弄脏了，我可以选择宽容或者不宽容，那么“我为什么要宽容他”就成了一个很难回答的问题。我如何说服自己要宽容他呢？因为我想做一个品德高尚的人？因为我惹不起他想息事宁人？这些理由不仅看起来没有说服力，而且可能引发其他问题。由此还引发了很多讨论， 比如宽容和纵容的分界在哪，宽容和懦弱的区别是什么，甚至有人认为宽容是一种虚伪。&lt;/p&gt;
&lt;p&gt;但认识到宽容的目的不是为别人好，而是为自己好，问题就迎刃而解了。别人把我的衣服弄脏了，我依然可以问“我为什么要宽容他”。但同时，这个问题也就转换成了“我为什么要对自己好”。这个问题是不言自明的，同样地，“我为什么要宽容”这个问题也是不言自明的。选择不宽容，就是和自己过不去，简单明了。&lt;/p&gt;
&lt;p&gt;宽容是一种对待事情的态度，而不是解决问题的方法，这是很重要的。别人把我的衣服弄脏了，我选择了宽容（这表明了我对这件事的态度），但这不意味这事情就结束了。我选择接下来怎么处理这件事，和我是否选择了宽容，是没有直接关系的。我可以选择不再计较，也可以选择提示对方走路要小心些以免弄脏别人的衣服，当然还可以选择让对方赔偿，这些都是处理事情的方法，它们和是否宽容没有直接的关系。那么宽容和纵容的区别也就很明显了，纵容是放任，是一种行为，它和宽容没有直接的关系，可以宽容然后放任，也可以不宽容然后放任。而懦弱和宽容也没有直接的关系，懦弱是一种不作为，可能是宽容然后不作为，也可能是不宽容然后不作为。&lt;/p&gt;
&lt;p&gt;那么我们可以对所有的事情或者人宽容吗？其实这个问题就等同于“我们可以在遇到任何事情或者人的时候对自己好吗”，没有什么不可以的。澄清了之前那个误区，这里也就没有什么问题了。比如有个人罪大恶极，杀了很多人，甚至伤害了自己，那么我为什么要宽容他？这个问题还是一样的，我可以选择宽容他或者不宽容他，这也就是选择对自己好还是对自己不好。任何人都可以选择对自己不好，可以选择用刀去砍自己的手，就像选择不宽容别人一样，即使他伤害了我。宽容他不意味着事情就结束了，他自然要为自己的行为付出代价。和此类似的一个问题，“一个人伤害了我，我可以恨他吗”。同样地，没有什么是不可以的，但选择恨别人，就相当于选择伤害自己，每个人都有伤害自己的权利，但显然这不是一个很好的选择。&lt;/p&gt;
&lt;p&gt;所以我想我找到了能做到宽容的方法，或者这已经不再是一个方法。因为我找不到需要不宽容的理由了，为什么要对自己不好呢？&lt;/p&gt;</content></entry><entry><title>赛斯早期课 8——第 334 节（38-62）</title><link href="/sai-si-zao-qi-ke-8-di-334-jie-38-62.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/sai-si-zao-qi-ke-8-di-334-jie-38-62.html</id><summary type="html">&lt;h2&gt;第334节 1967年4月12日 星期三 晚上9点&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;晚上好。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（“晚上好，赛斯。”）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;现在。如果你画一幅画，它的整体素质来自于你内在的氛围。&lt;/p&gt;
&lt;p&gt;你以同样的方式创造了你的物质形象和你的世界。如果你想改变物质形象或者物质世界中的任何东西，那么你必须首先改变内我的氛围。&lt;/p&gt;
&lt;p&gt;这从内向外的投射是自动进行的。理解其中的过程是很有益处的。你的身体&lt;u&gt;似乎&lt;/u&gt;对物理刺激做出反应。当然，事实上它是对自己的实相做出反应，然后向外投射出去。&lt;/p&gt;
&lt;p&gt;物质宇宙中的物体仅是用来表达存在于私有领域中的其他实相的符号。内在意志总会被投射到你们的系统中。比如，一封信给你带来了好消息，你对这封信投以很高的热情，你应该理解是这热情在先，然后在物质系统将这封信物质化了，尽管在物质系统中，多层次并且很复杂的反应都聚集到一起了。&lt;/p&gt;
&lt;p&gt;如果一封恼人的信来了，你对它反应很消极，那么这消极本身同样在这封信之前产生，并在你们的系统中将这封信物质化了。你看，现在你并没有强迫任何人写这样一封信。你撒播了负面的情绪，然后这负面情绪被任何因为他们自己的目的而准备接受它们的人捡到了。&lt;/p&gt;
&lt;p&gt;我不能过分强调这是自动发生的。我不想把它过度简化的这种程度，也不想将它描述得太复杂。&lt;/p&gt;
&lt;p&gt;在这里内在情绪是主导因素。比如说，突然而强烈的仇恨、怨恨或恐惧可能会导致物质世界中的惨剧。同样地，突然而强烈的欣喜会在物质世界产生让人震惊的正面效应。也就是说，纯粹的欣喜，即使只持续短暂的时间 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;第334节 1967年4月12日 星期三 晚上9点&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;晚上好。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（“晚上好，赛斯。”）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;现在。如果你画一幅画，它的整体素质来自于你内在的氛围。&lt;/p&gt;
&lt;p&gt;你以同样的方式创造了你的物质形象和你的世界。如果你想改变物质形象或者物质世界中的任何东西，那么你必须首先改变内我的氛围。&lt;/p&gt;
&lt;p&gt;这从内向外的投射是自动进行的。理解其中的过程是很有益处的。你的身体&lt;u&gt;似乎&lt;/u&gt;对物理刺激做出反应。当然，事实上它是对自己的实相做出反应，然后向外投射出去。&lt;/p&gt;
&lt;p&gt;物质宇宙中的物体仅是用来表达存在于私有领域中的其他实相的符号。内在意志总会被投射到你们的系统中。比如，一封信给你带来了好消息，你对这封信投以很高的热情，你应该理解是这热情在先，然后在物质系统将这封信物质化了，尽管在物质系统中，多层次并且很复杂的反应都聚集到一起了。&lt;/p&gt;
&lt;p&gt;如果一封恼人的信来了，你对它反应很消极，那么这消极本身同样在这封信之前产生，并在你们的系统中将这封信物质化了。你看，现在你并没有强迫任何人写这样一封信。你撒播了负面的情绪，然后这负面情绪被任何因为他们自己的目的而准备接受它们的人捡到了。&lt;/p&gt;
&lt;p&gt;我不能过分强调这是自动发生的。我不想把它过度简化的这种程度，也不想将它描述得太复杂。&lt;/p&gt;
&lt;p&gt;在这里内在情绪是主导因素。比如说，突然而强烈的仇恨、怨恨或恐惧可能会导致物质世界中的惨剧。同样地，突然而强烈的欣喜会在物质世界产生让人震惊的正面效应。也就是说，纯粹的欣喜，即使只持续短暂的时间，也能改切实地变生活的方向。&lt;/p&gt;
&lt;p&gt;所有其他的内在情绪色调都处于这两个极端之间。各种各样的即使是强调相当低的消极情绪，也可以凝聚成一个大体是负面的情绪气候，它会将自己向外投射为物质实相。&lt;/p&gt;
&lt;p&gt;这些负面情绪会被翻译成物质世界的东西。除非你意识到你可以改变你的内在状况，知道身体症状或者不良的外在环境只是一种象征符号对你是没有太多益处的。&lt;/p&gt;
&lt;p&gt;当你将一个糟糕的物质象征符号改变成更有建设性的一个，不同就&lt;u&gt;显现&lt;/u&gt;出来了。当然这变化是在内我中先产生的。物质存在仅仅将物质系统作为一个检查板来使用。&lt;/p&gt;
&lt;p&gt;必须意识到物质环境&lt;u&gt;并不是&lt;/u&gt;持久的，而是时刻变化的。想象一下，不然你会被物质符号所催眠。每一天都应该被认为是新的一天。鲁柏不应该像这样想：“我曾经有过这样的症状和这样的时间。”这增强了思想的持久性。应该把每一天看作心灵的重生。&lt;/p&gt;
&lt;p&gt;你可以休息一下，我们稍后继续。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（9点25分。珍的速度加快了一些，眼睛时而睁开，声音已经平缓了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（现在是关于加拉赫一家人资料的时间了，他们将于本周来纽约市度假。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（9点36分。）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;请稍等我们一会。下边的将是关于我们旅行中的朋友们的印象。&lt;/p&gt;
&lt;p&gt;一排公寓楼。光线很暗，我猜是在夜间。去三楼或者二楼的一个游览。另一个场景，一个带着蜘蛛形状装饰的教堂。一个红色的前厅。一个地下场所，他们在那吃喝，有百叶窗和那个时代的氛围，1871年。&lt;/p&gt;
&lt;p&gt;切换到了另一个场景，和&lt;u&gt;矿井&lt;/u&gt;、海军和一场战争有关。一个头发花白，穿着红色的毛衣或衬衫的男人，正向耶稣讲述着一个故事。他大概61岁。&lt;/p&gt;
&lt;p&gt;另一个场景：在教堂的一个区域有一个美术学院，它在一个巨大的联邦大楼和一个公交站点或者终点站附近。一部关于间谍的书或者电影，我们朋友借入或者借出的。&lt;/p&gt;
&lt;p&gt;似乎很重要的一个片段。和鱼有关的事情，这是另一个旅程。我不清楚这里：一个矿井，或者矿井事故，和禁运。一顶帽子差点丢失了。下午茶时间，在一个听起来像阿贝克隆比的地方。他们停留在一间四层楼的屋子里。&lt;/p&gt;
&lt;p&gt;你可以休息一下。&lt;/p&gt;</content></entry><entry><title>赛斯早期课 8——第 334 节（63-87）</title><link href="/sai-si-zao-qi-ke-8-di-334-jie-63-87.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/sai-si-zao-qi-ke-8-di-334-jie-63-87.html</id><summary type="html">&lt;p&gt;&lt;em&gt;（9点50分到9点58分）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;和一个专家的相会。这和加拉赫资料是一起的。这将是简短的一课。在这周的晚些时候可能再上一节。&lt;/p&gt;
&lt;p&gt;_ （“说说帕特·诺瑞里带到波士顿课堂的第329节课的录音带的事情吧？”）_&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（帕特在回匹兹堡的家的途中顺路拜访了我们，在4月15日星期六。3月25日，她录了第329节课的音，用来在她的高中课堂上播放。在播放录音带之后她写信告知了我们。赛斯在课堂上进行了一次精彩的演讲，分两部分。见《赛斯早期课七》。）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;确实很好，就像我希望的那样。这以特别的方式，给几个年轻的学生留下了深刻的印象。坐在靠近中间一列第三个座位的男生。以及坐在远一些的右边一列第四个座位的女生。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（我在4月16日星期日写下这些。帕特在15日拜访了我们，肯定了赛斯之前所说的大部分资料。请参考她在昨天画的教室示意图，这张是我画的副本。帕特说，坐在靠近中间一列第三个座位的男生名叫Dave Lounsburg。那个远一些的右边一列第四个座位的女生叫Elaine Todd。）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（赛斯同样找对了Art Finnegan的座位，在第329节课提到过他。“还有一个坐在从前边数第三个或者第四个座位的男生，在墙左边的一排。这是他在这个系统的最后一次轮回。”）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个人的名字好像是Davis，或者全名中有Davis。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（那应该是Dave Lounsburg。）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;你有其他问题吗？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（“在学校里有其他人在这些学生之后听了录音带吗？有成年人吗？”）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其他人也听过。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（“在学校 …&lt;/em&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;（9点50分到9点58分）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;和一个专家的相会。这和加拉赫资料是一起的。这将是简短的一课。在这周的晚些时候可能再上一节。&lt;/p&gt;
&lt;p&gt;_ （“说说帕特·诺瑞里带到波士顿课堂的第329节课的录音带的事情吧？”）_&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（帕特在回匹兹堡的家的途中顺路拜访了我们，在4月15日星期六。3月25日，她录了第329节课的音，用来在她的高中课堂上播放。在播放录音带之后她写信告知了我们。赛斯在课堂上进行了一次精彩的演讲，分两部分。见《赛斯早期课七》。）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;确实很好，就像我希望的那样。这以特别的方式，给几个年轻的学生留下了深刻的印象。坐在靠近中间一列第三个座位的男生。以及坐在远一些的右边一列第四个座位的女生。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（我在4月16日星期日写下这些。帕特在15日拜访了我们，肯定了赛斯之前所说的大部分资料。请参考她在昨天画的教室示意图，这张是我画的副本。帕特说，坐在靠近中间一列第三个座位的男生名叫Dave Lounsburg。那个远一些的右边一列第四个座位的女生叫Elaine Todd。）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（赛斯同样找对了Art Finnegan的座位，在第329节课提到过他。“还有一个坐在从前边数第三个或者第四个座位的男生，在墙左边的一排。这是他在这个系统的最后一次轮回。”）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这个人的名字好像是Davis，或者全名中有Davis。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（那应该是Dave Lounsburg。）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;你有其他问题吗？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（“在学校里有其他人在这些学生之后听了录音带吗？有成年人吗？”）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其他人也听过。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（“在学校？”）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;对那些人，不是在学校播放的，我相信有两个男士和一个女士听过。可能和H B相关。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（帕特没有证实和H B相关的事情。帕特说在播放录音带时，还有两位女士也在她的课堂上，其中一位是老师。帕特还放给她校外的女性朋友Ellen Tabb，以及她的男性朋友Adrian。这样除了帕特，就一共有三位女士和一位男士听过录音，然而赛斯说有两位男士和一位女士听过。）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（或许，赛斯是指放录音时课堂坐着的两个成年人。尽管他说“其他人也听过”，我理解这是指Ellen Tabb和Adrian。我的理解是一位男士和一位女士听过录音，但赛斯说是两位男士和一位女士。）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果你有更多问题，我会回答，否则你可以结束这节课了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（“珍的下一本书是关于什么的，在《梦》之后？”）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下一本将是我的书。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（“她会像她已经开始的方式来改变它吗？”）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;是的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（“能说下会以怎样的方式吗？”）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;现在还没有必要说。以变更形式为主。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（“好的。我猜就是这样。”）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我衷心地祝福你们俩，并且度过一个最美好的夜晚。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（“晚安，赛斯。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（10点05分）&lt;/em&gt;&lt;/p&gt;</content></entry><entry><title>《生命咖啡馆》读书笔记</title><link href="/sheng-ming-ka-pei-guan-du-shu-bi-ji.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/sheng-ming-ka-pei-guan-du-shu-bi-ji.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这也是一本思考生命意义的书，特点是以讲故事为主，浅显易懂，信息量也相对比较少，但个人认为它还是同类书籍中比较好的一本。这本书可以作为思考人生意义的入门书籍。&lt;/p&gt;
&lt;h2&gt;目标读者&lt;/h2&gt;
&lt;p&gt;这本书内容的形式是讲故事，而且和其他往往讲童话故事的书不同，作者说这故事是真实发生在他身上的，虽然并不是所有读者都愿意相信，但这点也不是很重要。这本书适合之前还从没有真正仔细思考过人生的读者，因为比较好理解，相对来说也不会带来特别大的冲击，而另一些读者可能认为书中的描述过于啰嗦，反反复复都在讲同样的东西，信息量太少，也不够深入。&lt;/p&gt;
&lt;h2&gt;加班升职就是为了得到更久的加班时间？&lt;/h2&gt;
&lt;p&gt;这是第一章的标题，第一章的内容是非常吸引人的，很多人看过都会感同身受，从而自然而然继续读下去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“那个夜晚，我独自一个人走在漆黑、寂寥的漫漫长路上。如今想起来，这样的处境正好是我当时人生阶段的写照——在旅途上，我迷失方向；在生命中，我也不知道该何去何从。”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是作者当时的状态，或许很多人都会有处于类似这样状态的阶段。&lt;/p&gt;
&lt;p&gt;“当时，我向公司请了一周的假，想要摆脱和工作有关的一切。我不是说我的工作有多糟糕。当然，工作中必有不如意之处，但更重要的是，我总是疑惑着，&lt;strong&gt;每天在小小的办公隔间里耗掉十到十二个小时，就是为了升迁；而升迁的结果，却是要在另一间办公室花上十二到十四个小时继续工作，难道人生除此之外，就别无其他选择吗 …&lt;/strong&gt;&lt;/p&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这也是一本思考生命意义的书，特点是以讲故事为主，浅显易懂，信息量也相对比较少，但个人认为它还是同类书籍中比较好的一本。这本书可以作为思考人生意义的入门书籍。&lt;/p&gt;
&lt;h2&gt;目标读者&lt;/h2&gt;
&lt;p&gt;这本书内容的形式是讲故事，而且和其他往往讲童话故事的书不同，作者说这故事是真实发生在他身上的，虽然并不是所有读者都愿意相信，但这点也不是很重要。这本书适合之前还从没有真正仔细思考过人生的读者，因为比较好理解，相对来说也不会带来特别大的冲击，而另一些读者可能认为书中的描述过于啰嗦，反反复复都在讲同样的东西，信息量太少，也不够深入。&lt;/p&gt;
&lt;h2&gt;加班升职就是为了得到更久的加班时间？&lt;/h2&gt;
&lt;p&gt;这是第一章的标题，第一章的内容是非常吸引人的，很多人看过都会感同身受，从而自然而然继续读下去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“那个夜晚，我独自一个人走在漆黑、寂寥的漫漫长路上。如今想起来，这样的处境正好是我当时人生阶段的写照——在旅途上，我迷失方向；在生命中，我也不知道该何去何从。”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是作者当时的状态，或许很多人都会有处于类似这样状态的阶段。&lt;/p&gt;
&lt;p&gt;“当时，我向公司请了一周的假，想要摆脱和工作有关的一切。我不是说我的工作有多糟糕。当然，工作中必有不如意之处，但更重要的是，我总是疑惑着，&lt;strong&gt;每天在小小的办公隔间里耗掉十到十二个小时，就是为了升迁；而升迁的结果，却是要在另一间办公室花上十二到十四个小时继续工作，难道人生除此之外，就别无其他选择吗？&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;这些话非常直白地描述出作者对现有工作的迷茫，或者说是对整个未来的迷茫。很多人都有过类似想法，但认真地继续想下去的人就不是很多了。&lt;/p&gt;
&lt;p&gt;然后作者开始回顾过往的事情：&lt;/p&gt;
&lt;p&gt;“高中时代，我为了上大学做准备；上了大学，我又在为将来的工作铺路打桩。大学毕业后，我一直勤奋工作、努力表现，直到进入我现在的公司。而如今我不禁要质疑，这一路走来，那些帮助过我、扶持过我的人给我的忠告，是否也只是复述当年别人对他们所提的建议？&lt;/p&gt;
&lt;p&gt;其实这些忠告都不错，但却无法完全满足人生的追求与期望。我觉得自己只是忙着用生命换取金钱，而这样的交易似乎并不值得。我陷入了恍惚、迷惑之境。”&lt;/p&gt;
&lt;p&gt;这就是作者在讲这个故事之前的铺垫，我把大部分内容摘录下来，感觉概括得非常到位。每一个对自己工作或者生活感觉不是那么十全十美的人，都会陷入沉思，我当时看这本书时的处境和作者当时并没有太大不同，虽然那时这本书远没有解决我所有的问题，但不得不说这本书对我还是有一些帮助的。&lt;/p&gt;
&lt;h2&gt;一次不愉快的旅行&lt;/h2&gt;
&lt;p&gt;正如作者之前提到的，他请了一周的假，开车去兜风。但路上出了一些麻烦，经过长达一个小时的慢速行进后，车子完全终止不动了。很多人都打开车门，开始抱怨自己有多么重要的事情被这该死的交通给毁了。作者又等了将近一个小时，等来了警员，而他带来的信息是前方出现了比较严重的交通事故，大概还要等上一个小时才能处理完毕。作者终于忍耐不住了，逃离了原计划的路线，但因为没有携带地图，真正的麻烦开始上演。&lt;/p&gt;
&lt;p&gt;折腾了一个小时，看着一个个陌生的路名，作者正式宣告迷路了。时间已经快到晚上八点了，太阳已落下地平线，汽油已经不够返程，周围看不到一个人影，沿途没有出现任何加油站，也不清楚前方有没有。&lt;/p&gt;
&lt;p&gt;在汽油马上就要耗尽的时候，情况终于有所缓解。作者发现了路边的街灯，附近出现了一个停车场，更重要的是不远处有一个咖啡馆，虽然名字比较奇怪，“你为什么在这里咖啡馆”。之后故事开始出现比较奇幻的情节。&lt;/p&gt;
&lt;h2&gt;你为什么在这里咖啡馆&lt;/h2&gt;
&lt;p&gt;不只咖啡馆的名字比较特别，菜单也与众不同。封面下边有一排黑色小字，“点菜之前，请先和服务人员讨论，你待在这里的时间代表什么意义。”而翻开菜单，除了正常的菜品介绍外，还出现了这样的内容：&lt;/p&gt;
&lt;p&gt;等待上菜时需要思考的问题：
1. 你为什么在这里？
2. 你害怕死亡吗？
3. 你实现自我了吗？&lt;/p&gt;
&lt;p&gt;显然这不是一个普普通通的咖啡馆。&lt;/p&gt;
&lt;p&gt;作者虽然迷惑不解，但借着这个机会，也可以执行思考，并且可以和服务员和厨师探讨人生的重要问题了。&lt;/p&gt;
&lt;p&gt;剩余的部分我就不用叙事的风格来写了，因为看原文显然比看概况的更好。&lt;/p&gt;
&lt;h2&gt;我为什么在这里&lt;/h2&gt;
&lt;p&gt;第一个比较重要的问题是，我为什么在这里？这也是作者最先和服务员讨论的问题。这给问题显然不是我为什么来到这个咖啡馆就餐这么简单，而是更深层的，类似于我此刻的人生为何是这样的问题。&lt;/p&gt;
&lt;p&gt;作者直言不讳：&lt;/p&gt;
&lt;p&gt;“如果诚实面对自己，我会承认这些年来，我一直在质疑我的人生，是否还有比我目前所知更深刻的一面？这不是说我过得不好。当然，有时候挫折在所难免，尤其是最近更是如此，但我确实有个还不错的工作，也要一些好朋友。我的生活还算如意，甚至可以说很好，只不过在内心深处，我总是有种难以言喻的感觉。”&lt;/p&gt;
&lt;p&gt;很容易看出，作者或者有类似想法的其他人看人生的视角，是从别人的眼中看自己的人生。而真正切换成自己的视角，就会有所质疑。“提出这个问题会让你产生寻找答案的动机；而一个人要是找到了答案，就会生成一股极大的力量。你知道的，一个人一旦明白自己置身何处、为何存在，找到赖以生存的理由与目的，他们就会去实现自我、达成这样的理想。”&lt;/p&gt;
&lt;p&gt;一旦找到了这个问题的答案，“他们可以为了这个答案，去做任何想做的事。他们发现了答案，而这个答案就属于他们了。他们可以全权作主怎么做。”作者听到了这样的想法后，“一股兴奋之情贯穿了我的全身，就像是我刚发现了某种独特、珍贵的东西，而我的身体也证实了这一点。”很可能作者在这特定的场景，之前思考过许久的问题突然有了进展，但读者很难有类似的反应。从这开始，书中内容的跳跃感就比较强了，思考开始比阅读更重要，而且在这里未必能思考出真正有用的东西。&lt;/p&gt;
&lt;h2&gt;真的有人在偷你的时间&lt;/h2&gt;
&lt;p&gt;服务员提到了一种海龟，它看起来十分笨重，浮游在水中看上去移动也很慢，但它的速度却是人游泳也很难追上的。原因在于这种海龟是配合这大海律动在前进的，利用海浪的力量加快自己的速度。而人游泳时如果不懂得利用海浪的力量，而是与海浪对抗，自然是要更慢一些了。&lt;/p&gt;
&lt;p&gt;这个比喻直指我们的生活。每一天都有很多人说服你花时间或精力在他们身上，比如电子邮件，如果你参与、回应每一种你获知的活动、促销和服务，就根本没有任何空闲了。这样的事情非常普遍，以至于一个人一直在做其他人说做的事、或是其别人想要你做的事。这些数不尽的事情就像那不停翻滚的海浪一样，迎面而来的是那些要引起我们注意、侵占我们能量和时间、却和我们“存在目的”毫无瓜葛的事情；而往外冲刷的浪潮，则是那些能帮助我们达到“存在目的”的人、物、事。而只有真正找到自己的“存在”目的，才能甄别出这两种不同的海浪，从而利用海浪，而不是盲目和海浪抗争。&lt;/p&gt;
&lt;h2&gt;做自己真正喜欢的事情&lt;/h2&gt;
&lt;p&gt;接下来书中提到一个多数人都听过，并且有所争议的估计，就是富翁说服“懒散”的渔夫需要努力奋斗，把生意做大，赚花不完的钱，最后晒太阳享受人生的故事。不同人对这个故事有截然不同的观点，这里就不展开说了。很明显这里作者是站在渔夫的一边的，认为富翁为了以后退休后的生活，把大量的时间用在并不喜欢的工作上是不明智的。&lt;/p&gt;
&lt;p&gt;“为什么我们要花这么多时间做准备，以便在未来能做我们想做的事，却不肯现在就去实现我们的理想？”&lt;/p&gt;
&lt;p&gt;关于“做自己真正喜欢的事情”这个话题，其实有不少可以深入探讨的内容，远远不只这么简单，在本文末尾我还会有所涉及。&lt;/p&gt;
&lt;h2&gt;大多数人都掉进了坑里&lt;/h2&gt;
&lt;p&gt;正常人都会更倾向于做自己喜欢的事情，没有人专挑自己不喜欢的事情做，而没有其他的目的。但大多数人还是掉进了坑里。&lt;/p&gt;
&lt;p&gt;一个最普遍的想法，就是如同之前那个富翁那样（其实他们中的大多数都是成为不了可以那样安度晚年的富翁的），为什么我们要花这么多时间做准备，以便在未来能做想做的事，却不肯现在就实现理想？&lt;/p&gt;
&lt;p&gt;很多人都想过这个问题，但之后又继续之前的生活，应有着如同理想很丰满、现实很骨感的感慨。&lt;/p&gt;
&lt;p&gt;广告人都很清楚，只要你能有效锁定人们的恐惧心理，或是他们想要满足的欲望，就能鼓动他们去去做某件事情，比如你要推销的特定货物与服务。经常有表达这样含义的广告，“如果你拥有这个产品，生活会变得更好”。但广告内容往往不是这么直白，而是“开这辆车子会让人人生充满意义；吃这种冰淇淋能让你体验幸福感受；拥有这颗钻石将是你圆满无憾”。更微妙却更具冲击性的信息通常也会传递出来：“不只是你有了这些商品，人生就能圆满无憾；如果你没有这些产品，你的人生就是无法满足、永远都有缺陷的”。也就是说你这些广告人试图用自己的产品把消费者绑架在其中，动弹不得。&lt;/p&gt;
&lt;p&gt;广告只是宣传这种生活方式的一个推手，而类似的观念遍布在我们每时每刻的生活之中，每个人在潜移默化中都会受到不同程度的影响。问题是要想买那些“能让自己更幸福”的东西，需要花钱，于是我们就去找了一份工作，或者其他可以赚钱的手段。不管那份工作怎么样，我们都需要从那里获得金钱，然后用来购买想要的东西。当工作中遇到不顺心的事情，我们告诉自己这只是暂时的，很快就会做其他的事——与我们理想更加契合的事情。&lt;/p&gt;
&lt;p&gt;如果这份工作并不能给我们带来成就感，而我们又为它耗费了太多时间，就会越来越觉得虚度人生。所有很多人说他们有多期盼退休的那一天的来临，因为然后就可以做自己想做的事情了。但毕竟是很久以后的事情，为了补偿自己没有每天都在做想做的事情，我们就去买更多的东西，暗暗希望广告所传递的信息是真的，期盼这些产品能给我们日常工作所无法给予的充实感。遗憾的是我们买的东西越多，要付的账单也就越多，结果我们就要花更多的时间来工作，以支付所有的开销。而且由于投入时间从事的这份工作并非是我们真正想过的生活，于是当我们在工作上花越多的时间，空虚感也就越重，因为我们会更没有机会去做想做的事情了。&lt;/p&gt;
&lt;p&gt;也就是说如果一个人现在做的不是自己真正想做的事情，那么就会陷入这样一种死循环，他永远（至少相当长的一段时间）都无法做自己真正想做的事情，慢慢的可能连自己真正想做什么都不清楚了。&lt;/p&gt;
&lt;p&gt;如果摆脱这种困境？书中提到的一个方法是，每个礼拜都多留一点点时间给自己，不再用物质犒劳自己，以作为努力工作的回报；相反开始做些自己想做的事情来奖励自己。比如每天用一个小时做自己想做的事情，然后一小时变成两小时，再进步到三小时，不知不觉可能就已经全神贯注地做自己想做的事情了。这个方法看起来不错，但个人感觉可行性不是很好，至少中间必须做出一些不是那么平滑的改变。&lt;/p&gt;
&lt;h2&gt;关于死亡&lt;/h2&gt;
&lt;p&gt;书中话题陡然一转，开始讨论死亡的问题。&lt;/p&gt;
&lt;p&gt;你害怕死亡吗？&lt;/p&gt;
&lt;p&gt;大部分人都会怕吧，这是人们常有的一种恐惧。虽然我们不会天天想到死亡这样的事情，但在潜意识里，会知道随着一天天过去，去做自己想做之事的机会也在逐渐减少。就会担心在未来的某一天，这样的机会将不再，所以害怕自己要面临死亡的那一天。相反如果已经做了，或是每天都在做真正想做的事情，就不必害怕没机会去做了。&lt;/p&gt;
&lt;p&gt;关于死亡的问题，书中没有深入讨论。&lt;/p&gt;
&lt;h2&gt;关于自我实现&lt;/h2&gt;
&lt;p&gt;第三个问题就是“你实现自我了吗？”。要实现自我并不容易，比如我找到了自己真正想做的事情，但我却不知道要怎么开始，或是找不到可以与理想契合的工作，那该怎么办？我要怎么处理金钱问题？我要如何供养我自己？如何为退休做准备？如果我对这些新事物并不熟悉，或是别人会嘲笑我、不尊重我这样的做法的话，那该怎么办？&lt;/p&gt;
&lt;p&gt;想象这样一个人，他对自己每天所做的事情无比热忱，他像是把时间全都花在自己真的很喜爱、很享受的事情上。我们工作中应该可以需要这样的人，虽然可能并不多。他因为感兴趣，自然会把时间放在上面，比如利用空闲时间阅读相关书籍、观赏相关的电视节目、参加相关的会议，自然会比较精通，找工作也自然不会很困难。然后就是钱的问题，其中最糟糕的情况是一个人确实找到了自己的“存在目的”，而且也每天做着自己想做的事情，但他没有赚到“很多钱”，可这并没有什么关系，或者说这根本不是问题。&lt;/p&gt;
&lt;p&gt;书中这里的内容同样比较粗浅，找到自己真正想做的事情其实并不容易，尤其是还要把它作为自己的工作，这会难倒大部分的人。&lt;/p&gt;
&lt;h2&gt;剩余章节&lt;/h2&gt;
&lt;p&gt;“连锁的幸运”一章讲得是类似吸引力法则的现象，也就是一个人一旦找到了实现自我的道路，他就会在这条道路上顺利地走下去了，幸运会眷顾他的，不做过多描述。&lt;/p&gt;
&lt;p&gt;“如何在无数的诱惑性的劝说中找到自己”讲的则是为什么不是每个人都会去追求自己的“存在目的”，原因有很多，因人而异，这里不一一列举了。这里提到了一个故事：&lt;/p&gt;
&lt;p&gt;有个人多年来总是做同一个梦，梦到自己面对一个很难打的高尔夫球，实际上这也是他醒着的时候会面对的挑战。而梦里的场景更加困难，要打的球被放在了各种稀奇古怪的地方，怎么打都不对劲，而且他打之前就会预感到会很惨，这事情反反复复发生，让他感到挫折无比。后来有一天，他正处于绝望的谷底之际，突然领悟到可以直接把球捡起来，放到别的地方去。这根本无关紧要，除了他自己。他醒来时强烈感受到自己获得了一种重要的体悟，这样的洞察从未出现，如今却似乎再清楚不过。这个梦和某些人经常做考试的梦，最后在梦中终于下定决心直接离开考场的情况异曲同工。&lt;/p&gt;
&lt;p&gt;无论以前我们被教导要相信什么，或是在广告里听到什么、在承受工作压力时有何感受，每个人都掌握着自己每一分、每一秒的命运。不要只是努力适应着所有外来的影响，让它们掌控了我的一生。&lt;/p&gt;
&lt;p&gt;剩余的两章更多的是故事的尾声，略过不提。&lt;/p&gt;
&lt;h2&gt;离开咖啡馆之后&lt;/h2&gt;
&lt;p&gt;作者离开咖啡馆之后，“生活彻底变了，虽然这些变化并非如电光石火般惊天动地，但它们是一股影响我终生的重要动力”。作者在那个星期并没有考虑清楚“我为什么在这里”的问题，而且知道找出自己“存在目的”，光是用一段休假来思考、然后就继续像往常一样过日子是不够的，必须付出努力。&lt;/p&gt;
&lt;p&gt;最后作者用每天花一点时间去做些自己想做的事情的方法，以及尽其所能学习、尝试新事物等途径，最后终于找到了清晰明确的“存在目的”以及实现方法。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;我第一次看这本书是在几年前，当时对工作还比较满意，没有太多感受。后来又看了几次，发现它无法真正解决我的问题。就像我之前提到的一些内容，这本书可以让人容易地发现问题，但解决方法都比较牵强，对很多人都不是特别适用。尤其是想“我真正想做的事情”这个问题，我也曾经认为这个问题想清楚了，一切问题就都不存在了，放手去做就好了。可是我很长时间，使用各种方法，都没有找到满意的答案。直到后来发现这个问题没有那么重要，更重要的问题是“我想成为一个怎样的人”，而最重要的问题是想清楚“我是什么”以及“我和外部世界的关系是什么”。当我想清楚这些问题后，我发现“我想做什么事情”的问题根本不重要，或者说所有其他问题都不再重要了。&lt;/p&gt;
&lt;p&gt;所以总体上我读这本书的收获并不是很大，但我还是认为这是一本好书，所以写下这些文字。&lt;/p&gt;</content></entry><entry><title>时间的本质</title><link href="/shi-jian-de-ben-zhi.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/shi-jian-de-ben-zhi.html</id><summary type="html">&lt;p&gt;似乎从来没有像“时间”这样的东西，我们如此频繁地使用，却又如此地不了解。关于时间是什么的问题，我想了很久，看了数不清的资料，偶有领悟，但总是还有不清楚的部分。直到前几天我看赛斯书的一些部分后，终于感觉我最后的困惑解开了，但当时并没有细想。直到今天突然想仔细整理这个问题，得以沉淀。这只是我认为的可以自圆其说的对时间的解释，而未必是正确的。&lt;/p&gt;
&lt;p&gt;关于时间最让人困惑的描述在于“过去、现在和未来同时发生”，或者说“没有过去和未来，只有永恒的现在”。单单理解这一点还好说，但由此引申出来的问题却让人甚为头痛。&lt;/p&gt;
&lt;p&gt;因为从头来讲比较复杂，我们先一步到位看解释“过去、现在和未来同时发生”的时间模型。&lt;/p&gt;
&lt;p&gt;想象每一个时刻是一个点，它们“杂乱无章”地散落在一个平面上。我在其中的一个点上，我称这个点为现在，但这个点只是因为我在上边而看起来有些特殊，实际上和其他时刻并无本质的区别。&lt;/p&gt;
&lt;p&gt;如下图，a - e 是5个时刻，我在c上，所以对我来说c就是现在。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/002.png"&gt;&lt;/p&gt;
&lt;p&gt;但其中a和e点和我也有关系，在我看来a点是过去，e点是将来。也就是说我曾经视a点为现在，而以后将视e点为现在。这样a …&lt;/p&gt;</summary><content type="html">&lt;p&gt;似乎从来没有像“时间”这样的东西，我们如此频繁地使用，却又如此地不了解。关于时间是什么的问题，我想了很久，看了数不清的资料，偶有领悟，但总是还有不清楚的部分。直到前几天我看赛斯书的一些部分后，终于感觉我最后的困惑解开了，但当时并没有细想。直到今天突然想仔细整理这个问题，得以沉淀。这只是我认为的可以自圆其说的对时间的解释，而未必是正确的。&lt;/p&gt;
&lt;p&gt;关于时间最让人困惑的描述在于“过去、现在和未来同时发生”，或者说“没有过去和未来，只有永恒的现在”。单单理解这一点还好说，但由此引申出来的问题却让人甚为头痛。&lt;/p&gt;
&lt;p&gt;因为从头来讲比较复杂，我们先一步到位看解释“过去、现在和未来同时发生”的时间模型。&lt;/p&gt;
&lt;p&gt;想象每一个时刻是一个点，它们“杂乱无章”地散落在一个平面上。我在其中的一个点上，我称这个点为现在，但这个点只是因为我在上边而看起来有些特殊，实际上和其他时刻并无本质的区别。&lt;/p&gt;
&lt;p&gt;如下图，a - e 是5个时刻，我在c上，所以对我来说c就是现在。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/002.png"&gt;&lt;/p&gt;
&lt;p&gt;但其中a和e点和我也有关系，在我看来a点是过去，e点是将来。也就是说我曾经视a点为现在，而以后将视e点为现在。这样a - c - e 就是我眼中的过去 - 现在 - 未来时间线。而b、d这两个时刻，在我看来，和我没有任何关系。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/003.png"&gt;&lt;/p&gt;
&lt;p&gt;但不管我在哪，这5个点始终存在。也就是说，虽然我可能认为e点是未来的，尚未确定的一个点，但它其实已经存在了。但这不意味着我的未来是固定的，因为在c点的我，可以选择e作为我的未来，也可以选择d，看起来就像这样：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/004.png"&gt;&lt;/p&gt;
&lt;p&gt;这样的话，看起来e点就和我无关了，我将会到达d点，并把它视为现在。&lt;/p&gt;
&lt;p&gt;更神奇的是，作为过去的a点地位也不是稳固的，我可以用b点将其取而代之：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/005.png"&gt;&lt;/p&gt;
&lt;p&gt;也就是说未来和过去都可以被我“改变”。但我改变的并不是a点和e点本身，而是改我自己的过去 - 现在 - 未来时间线。事实上这5个点我都未曾改过，仅仅是从中选择了几个，串起来。&lt;/p&gt;
&lt;p&gt;通俗地说，我在每一个现在所做的事情，就是从密密麻麻的时间点中挑出来一个作为自己的下一个时刻，而其他的点，如过去的和更远的将来也是一样，只是在时间线上，它们距离我更远。因为我可以随意将时间线的每个点替换成别的，对我来说，所有点都是可以改变的，所有通常我们认为的现在不再具备特殊性。或者说既然我能同时改变过去、现在、未来，那么我可以认为每个点都是现在，也就是“过去、现在和未来同时发生”，或者“没有过去和未来，只有永恒的现在”。&lt;/p&gt;
&lt;p&gt;其实并没有一个稳固的时间线，这只是为了方便理解的一种简化，它完全是我动态产生的。当我试图将时间理解成一条线时，我就会假想一条线，然后将一些点安排到这条线上，而实际上并不存在这条线。&lt;/p&gt;
&lt;p&gt;这样解决了一些问题，同时引入了一些更难理解的问题，而这也是更重要的。&lt;/p&gt;
&lt;p&gt;这些点是怎么来的？是被创造出来的还是永恒都在的？&lt;/p&gt;
&lt;p&gt;麻烦在于一旦开始探讨这个问题，我们又引入了时间的概念。也就是说我们自以为解决了时间的问题，实际只是把它转移了，在这里我们需要重新面对被转移的问题。如果还是按照之前的思路，则进入了无尽的循环，而解释不清任何问题。这也是我之前遇到的主要麻烦。&lt;/p&gt;
&lt;p&gt;因为讨论时间问题时，我们需要使用时间相关的词汇，而这些词汇极具误导性，比如开始、结束、起源、永恒、过去、将来等等。一旦我们不知不觉用了，就又被陷入时间的迷阵，让讨论变得极为困难。&lt;/p&gt;
&lt;p&gt;一个好办法是将时间问题转化为空间问题，虽然我们对空间的理解也存在问题，但远没有时间那样地离谱。&lt;/p&gt;
&lt;p&gt;我们用空间的模型来继续解释：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/006.png"&gt;&lt;/p&gt;
&lt;p&gt;现在暂时忘记所谓过去、现在、将来的词汇。这5个点就是一个二维平面的点，而我们站在c点上。我们可以往d踏一步，也可以往e踏一步。而实际上d和e并不是之前就已经存在的。我可以往四边八方随便走，而每走一步都产生一个点。也就是说我并不是在d和e中选择一点，而是在无尽的可能中创造一点。事实上，选择和创造是一回事，见我之前的文章&lt;a href="http://www.jianshu.com/p/e105aaf80311"&gt;“选择”和“创造”的区别和联系&lt;/a&gt;。但我并不是在当我走到e点时才创造了它，我可以未雨绸缪，在还站在c点时就把e点创造出来，而d点也一样。这样实际情况是，我在c点创造出了d和e点，但最后选择了e点。虽然d点从不在我的路径中，它却是我创造的。而每一个点一旦被创造出来，它就不会消失，也不会改变，就永远在那了。当然，我走的每一个点都是我这样创造出来的。而我可以随时将我创造出来的点组织在我假想的路线（也就是时间线）。&lt;/p&gt;
&lt;p&gt;这样我们解释了点是怎么来的，以及它们是否永恒存在的问题。&lt;/p&gt;
&lt;p&gt;但要记得，我们还没有摆脱时间，因为当我说我从c点走到e点时，这还是在时间的框架说的，这个问题必须被解决掉。&lt;/p&gt;
&lt;p&gt;我们需要再进行一步抽象，把事件作为空间的一个点，以摆脱时间相关词汇的不良影响。之前我们是将时间点比喻成平面的一个点，而事件在平面之外（这样又引人了一个时间）。现在我们将我站在时间点这个事件比喻成平面的一个点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/007.png"&gt;&lt;/p&gt;
&lt;p&gt;图中每一点都是我站在某个时间点的事件。比如C点代表我站在c点的事件。在线上的点是我认为发生（在过去、现在或未来发生）的事件，不在线上的为我认为不发生的事件。但不管我认为某个事件是发生还是不发生，我一旦把这个事件创造出来，它就在那了。需要注意的是，我将B - C - D认作自己的时间线的事情，本身也是一个事件，也会出现在这张图上。只要有事件发生，这张图就会出现一点，所以在这张图之外，再也不会有时间的概念了。但是，我本身并不在这张图里，也就是我是独立于时间之外的。事件在时间的框架才有意义，在时间之外，没有事件的概念。&lt;/p&gt;
&lt;p&gt;换一种说法。我们在时间之外，但我们的一举一动都会在时间中产生事件，而事件一旦产生，就像空间的一个点，不会自己“变化”，不会“消失”，“永恒”地在那里了。每个人都可以随意去时间里读取事件，而这个过程本身又会在时间中产生事件，从而时间中的事件越来越多。而这些事件可以认为是宇宙的经验。&lt;/p&gt;
&lt;p&gt;那么，看起来还有最后一个问题。时间本身是怎么来的？&lt;/p&gt;
&lt;p&gt;当然这个问题的问法是有问题的，因为它是时间框架中的问题。实际上，时间是永恒存在的，就像宇宙是永恒存在的一样，它没有起源（当然我们可以认为在时间中产生的第一个事件是起源，但它们本身是在时间框架之外的），也不会终结，因为在时间之外（包括时间本身，它是那个容器），起源、终结这些词汇没有意义。只有脱离了时间观念，才可以理解。&lt;/p&gt;
&lt;p&gt;和时间密切相关的另一个概念是空间。理解了时间是什么后，空间就好解释多了。&lt;/p&gt;
&lt;p&gt;简单说，空间并不是一种实体，而是一种关系，它只在事件中有意义。比如这样一个事件：我坐在椅子上。这似乎隐含着有空间这样一个实体存在，而我和椅子都在空间里。实际上这只是描述了我和椅子二者的一种关系，将我和椅子抽离，就没有空空如也的空间了。当然这不是说空间不存在，空间是一种更复杂的东西在事件中的展现，在事件中以关系的形式存在。&lt;/p&gt;
&lt;p&gt;在时间之外，空间并不存在。生命（本文中的生命都是指真正的生命，而不是我们通常认为的处于时间空间中的投影）存在于时间之外，所以不需要空间供生命居住。可以认为所有的生命在所有的地方，实际上没有“地方”这样的东西。这里也一样，只有脱离了空间观念，才可以理解。&lt;/p&gt;
&lt;p&gt;一旦两个生命发生交互（这交互同样在时间之外，这个描述有问题，因为看起来像是一个事件，但语言所限没有办法），那交互就会在时间中产生事件。而交互的某些属性以空间的关系存在于事件中（比如看起来这两个生命处于空间中的两个位置，实际这是两个生命关系的展现）。这种关系不是固定的，也就是说空间并不是固定的我们所感觉到的三维空间，而可能更为复杂，甚至不能用几维来表示，但都是在表达一种关系。从某种意义上说，空间的概念没有时间重要，并不是所有的事件中都包含空间。比如我说我今年25岁，这显然产生了一个事件，但这个事件中并没有空间。空间只是一种关系，还有很多类似的关系。而至于关系是什么，就是另一个问题了，但远没有时间的问题复杂难懂。&lt;/p&gt;
&lt;p&gt;时间之外的东西，我们只是做了一个非常大的简化。因为我们的思维在脱离了时间空间的概念后难以运作，如果一定要再深究就有些强人所难了。虽然并非不可以，但事实的真相往往会被严重扭曲，而完全变了形。思维本身也不是用来做这个的，就像你不能指望一个手机可以做饭用。&lt;/p&gt;</content></entry><entry><title>使用 wsl terminal 更好地体验 Win 10 WSL 终端环境</title><link href="/shi-yong-wsl-terminal-geng-hao-di-ti-yan-win-10-wsl-zhong-duan-huan-jing.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/shi-yong-wsl-terminal-geng-hao-di-ti-yan-win-10-wsl-zhong-duan-huan-jing.html</id><summary type="html">&lt;p&gt;WSL 从最初功能不全 bug 遍地都是，到现在除了少数几个比较顽固的 bug 外，基本足以正常使用了。但自带终端模拟器的体验依然非常糟糕，而且在可以预期的未来都不会有太大的长进了。我是从去年 8 月开始开发 &lt;a href="https://goreliu.github.io/wsl-terminal/"&gt;wsl-terminal&lt;/a&gt;（&lt;a href="https://goreliu.github.io/wsl-terminal/README.zh_CN.html"&gt;中文页面&lt;/a&gt;）的，期间因为想不到可以添加什么功能而搁置了比较长时间。最近心血来潮，添加了很多实用功能，用户体验也会上升很多。&lt;/p&gt;
&lt;p&gt;希望有在使用的朋友可以多反馈下意见建议，如果之前没有尝试过，也可以体验一下，软件是一个 1.6 MB 的压缩包，解压后即可使用，不会往系统中写入任何东西（如果想添加到开始菜单或者右键菜单，可以使用 tools 中的工具）。&lt;/p&gt;
&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;用于 Windows Subsystem for Linux (WSL) 的终端模拟器，基于 &lt;a href="http://mintty.github.io/"&gt;mintty&lt;/a&gt; 和 &lt;a href="https://github.com/rprichard/wslbridge"&gt;wslbridge&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;截图&lt;/h3&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/030.png"&gt;&lt;/p&gt;
&lt;p&gt;查看&lt;a href="https://github.com/goreliu/wsl-terminal/wiki/Screenshots"&gt;更多截图&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;用法 …&lt;/h3&gt;</summary><content type="html">&lt;p&gt;WSL 从最初功能不全 bug 遍地都是，到现在除了少数几个比较顽固的 bug 外，基本足以正常使用了。但自带终端模拟器的体验依然非常糟糕，而且在可以预期的未来都不会有太大的长进了。我是从去年 8 月开始开发 &lt;a href="https://goreliu.github.io/wsl-terminal/"&gt;wsl-terminal&lt;/a&gt;（&lt;a href="https://goreliu.github.io/wsl-terminal/README.zh_CN.html"&gt;中文页面&lt;/a&gt;）的，期间因为想不到可以添加什么功能而搁置了比较长时间。最近心血来潮，添加了很多实用功能，用户体验也会上升很多。&lt;/p&gt;
&lt;p&gt;希望有在使用的朋友可以多反馈下意见建议，如果之前没有尝试过，也可以体验一下，软件是一个 1.6 MB 的压缩包，解压后即可使用，不会往系统中写入任何东西（如果想添加到开始菜单或者右键菜单，可以使用 tools 中的工具）。&lt;/p&gt;
&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;用于 Windows Subsystem for Linux (WSL) 的终端模拟器，基于 &lt;a href="http://mintty.github.io/"&gt;mintty&lt;/a&gt; 和 &lt;a href="https://github.com/rprichard/wslbridge"&gt;wslbridge&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;截图&lt;/h3&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/030.png"&gt;&lt;/p&gt;
&lt;p&gt;查看&lt;a href="https://github.com/goreliu/wsl-terminal/wiki/Screenshots"&gt;更多截图&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;用法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从&lt;a href="https://github.com/goreliu/wsl-terminal/releases"&gt;这里&lt;/a&gt;下载最新版本并解压。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;open-wsl.exe&lt;/code&gt; 可以在当前目录打开一个 WSL 终端模拟器（wsl-terminal 需要放置在本地的 NTFS 分区上，&lt;a href="https://github.com/rprichard/wslbridge#building-wslbridge"&gt;原因&lt;/a&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;tools/1-add-open-wsl-terminal-here-menu.js&lt;/code&gt; (&lt;a href="https://github.com/goreliu/wsl-terminal/blob/master/README.zh_CN.md#工具"&gt;帮助&lt;/a&gt;) 来添加一个 &lt;code&gt;Open wsl-terminal Here&lt;/code&gt; 右键菜单到资源管理器上 (运行 &lt;code&gt;tools/1-remove-open-wsl-terminal-here-menu.js&lt;/code&gt; 可以将其删除）。 如果你使用 Total Commander, 可以参考 &lt;a href="https://github.com/goreliu/wsl-terminal/wiki/Use-wsl-terminal-with-Total-Commander"&gt;在 Total Commander 中使用 wsl-terminal&lt;/a&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;run-wsl-file.exe&lt;/code&gt; 可以在 wsl-terminal 里运行任何 &lt;code&gt;.sh&lt;/code&gt; （以及任何其他的可执行文件，比如 &lt;code&gt;.py&lt;/code&gt; &lt;code&gt;.pl&lt;/code&gt; 文件) 脚本文件，你可以在文件打开方式里设置使用它来打开文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vim.exe&lt;/code&gt; 可以使用 WSL 中的 vim 打开任何文件 (在 wsl-terminal 中)，支持在打开方式中配置。如果你使用其他编辑器，可以把 &lt;code&gt;vim.exe&lt;/code&gt; 重命名成  &lt;code&gt;emacs.exe&lt;/code&gt; &lt;code&gt;nvim.exe&lt;/code&gt;  &lt;code&gt;nano.exe&lt;/code&gt; 等等，会调用对应的编辑器打开。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;快捷键&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Alt + Enter&lt;/code&gt;: 全屏&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Alt + F2&lt;/code&gt;: 新建窗口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Alt + F3&lt;/code&gt;: 搜索文本&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ctrl + [Shift] + Tab&lt;/code&gt;: 切换窗口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ctrl + =+/-/0&lt;/code&gt;: 缩放&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ctrl + Click&lt;/code&gt;: 打开光标处的文件、目录名或者网址&lt;/p&gt;
&lt;h3&gt;命令行参数&lt;/h3&gt;
&lt;h4&gt;open-wsl&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;用法&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;wsl&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="err"&gt;选项&lt;/span&gt;&lt;span class="o"&gt;]...&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;激活在运行的&lt;/span&gt; &lt;span class="n"&gt;wsl&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;terminal&lt;/span&gt; &lt;span class="err"&gt;窗口。&lt;/span&gt;
      &lt;span class="err"&gt;如果&lt;/span&gt; &lt;span class="n"&gt;use_tmux&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;，会&lt;/span&gt; &lt;span class="n"&gt;attach&lt;/span&gt; &lt;span class="err"&gt;到正在运行的&lt;/span&gt; &lt;span class="n"&gt;tmux&lt;/span&gt; &lt;span class="err"&gt;会话上。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;运行一个&lt;/span&gt; &lt;span class="n"&gt;login&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="err"&gt;（如果&lt;/span&gt; &lt;span class="n"&gt;use_tmux&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="err"&gt;则失效）。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;command&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;运行&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt; &lt;span class="err"&gt;中的命令。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;进入到&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt; &lt;span class="err"&gt;目录中，&lt;/span&gt;&lt;span class="n"&gt;WSL&lt;/span&gt; &lt;span class="err"&gt;目录（例如&lt;/span&gt; &lt;span class="sr"&gt;/home/&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="err"&gt;）。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;W&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;进入到&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt; &lt;span class="err"&gt;目录中，&lt;/span&gt;&lt;span class="n"&gt;Windows&lt;/span&gt; &lt;span class="err"&gt;目录（例如&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;:\&lt;/span&gt;&lt;span class="n"&gt;Users&lt;/span&gt;&lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="n"&gt;distro&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;切换发行版。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;options&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;传递额外的选项给&lt;/span&gt; &lt;span class="n"&gt;wslbridge&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;options&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;传递额外的选项给&lt;/span&gt; &lt;span class="n"&gt;mintty&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;显示帮助信息。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;-B&lt;/code&gt; 和 &lt;code&gt;-b&lt;/code&gt; 后可以添加的选项，请参考 &lt;a href="https://github.com/goreliu/wsl-terminal/wiki/mintty-params"&gt;mintty 参数&lt;/a&gt; 和 &lt;a href="https://github.com/rprichard/wslbridge#usage"&gt;wslbridge 参数&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;cmdtool（在 WSL 中运行）&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;用法&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;cmdtool&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="err"&gt;选项&lt;/span&gt;&lt;span class="o"&gt;]...&lt;/span&gt;
  &lt;span class="n"&gt;wcmd&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;使用&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;exe&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;运行&lt;/span&gt; &lt;span class="n"&gt;Windows&lt;/span&gt; &lt;span class="err"&gt;程序。&lt;/span&gt;
  &lt;span class="n"&gt;wstart&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;使用&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;exe&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="err"&gt;运行&lt;/span&gt; &lt;span class="n"&gt;Windows&lt;/span&gt; &lt;span class="err"&gt;程序。&lt;/span&gt;
  &lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;检查更新，如果有更新可以直接升级。&lt;/span&gt;
  &lt;span class="n"&gt;killall&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;杀死所有的&lt;/span&gt; &lt;span class="n"&gt;WSL&lt;/span&gt; &lt;span class="err"&gt;进程。&lt;/span&gt;
  &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;cbwin&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;安装&lt;/span&gt; &lt;span class="n"&gt;cbwin&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
  &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;dash&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;安装&lt;/span&gt; &lt;span class="n"&gt;Cygwin&lt;/span&gt; &lt;span class="err"&gt;中的&lt;/span&gt; &lt;span class="n"&gt;dash&lt;/span&gt;&lt;span class="err"&gt;（用于调试）。&lt;/span&gt;
  &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;busybox&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;安装&lt;/span&gt; &lt;span class="n"&gt;Cygwin&lt;/span&gt; &lt;span class="err"&gt;中的&lt;/span&gt; &lt;span class="n"&gt;busybox&lt;/span&gt;&lt;span class="err"&gt;（用于调试）。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;工具&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tools&lt;/code&gt; 目录下的工具：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件名&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1-add-open-wsl-terminal-here-menu.js&lt;/td&gt;
&lt;td&gt;添加 &lt;code&gt;Open wsl-terminal Here&lt;/code&gt; 右键菜单到资源管理器上。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1-remove-open-wsl-terminal-here-menu.js&lt;/td&gt;
&lt;td&gt;移除 &lt;code&gt;Open wsl-terminal Here&lt;/code&gt; 右键菜单。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2-add-wsl-terminal-dir-to-path.js&lt;/td&gt;
&lt;td&gt;将 &lt;code&gt;wsl-terminal&lt;/code&gt; 目录添加到 &lt;code&gt;Path&lt;/code&gt; 环境变量里。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2-remove-wsl-terminal-dir-from-path.js&lt;/td&gt;
&lt;td&gt;从 &lt;code&gt;Path&lt;/code&gt; 环境变量中移除 &lt;code&gt;wsl-terminal&lt;/code&gt; 目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3-write-distro-guids-to-config-file.js&lt;/td&gt;
&lt;td&gt;将所有发行版的 guid 写入到配置文件 &lt;code&gt;etc/wsl-terminal.conf&lt;/code&gt; 中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4-create-start-menu-shortcut.js&lt;/td&gt;
&lt;td&gt;创建一个开始菜单快捷方式，指向 &lt;code&gt;open-wsl -C ~&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4-create-start-menu-shortcut-login-shell.js&lt;/td&gt;
&lt;td&gt;创建一个开始菜单快捷方式，指向 &lt;code&gt;open-wsl -l&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4-remove-all-start-menu-shortcuts.js&lt;/td&gt;
&lt;td&gt;移除所有 wsl-terminal 的开始菜单快捷方式。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;双击 &lt;code&gt;.js&lt;/code&gt; 文件即可运行。如果 &lt;code&gt;.js&lt;/code&gt; 文件被某个编辑器关联上了，可以修改打开方式为 &lt;code&gt;Microsoft (R) Windows Based Script Host&lt;/code&gt;，或者在 &lt;code&gt;tools&lt;/code&gt; 目录运行一个 &lt;code&gt;cmd.exe&lt;/code&gt;，然后用 &lt;code&gt;wscript xxx.js&lt;/code&gt; 运行对应文件。&lt;/p&gt;
&lt;h3&gt;配置文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;etc/wsl-terminal.conf&lt;/code&gt; 是 wsl-terminal 的配置文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[config]&lt;/span&gt;
&lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;窗口标题&amp;quot;&lt;/span&gt;
&lt;span class="na"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;bash&lt;/span&gt;
&lt;span class="na"&gt;use_tmux&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;0&lt;/span&gt;
&lt;span class="c1"&gt;;icon=&lt;/span&gt;
&lt;span class="c1"&gt;;distro_guid=&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;etc/themes/&lt;/code&gt; 目录下的是主题文件，&lt;a href="https://github.com/goreliu/wsl-terminal/wiki/Use-themes"&gt;使用主题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;etc/minttyrc&lt;/code&gt; 是 mintty 的配置文件， &lt;a href="https://github.com/mintty/mintty/wiki/Tips"&gt;mintty 帮助&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;升级&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;wsl-terminal&lt;/code&gt; 里打开 &lt;code&gt;open-wsl.exe&lt;/code&gt;，然后运行 &lt;code&gt;./cmdtool update&lt;/code&gt;  可以检查 wsl-terminal 的最新版本然后升级。如果下载速度过慢，可以先使用其他方法从&lt;a href="https://github.com/goreliu/wsl-terminal/releases"&gt;发布页面&lt;/a&gt;下载 &lt;code&gt;wsl-terminal-v{version}.7z&lt;/code&gt; 文件，然后将其放入到 &lt;code&gt;wsl-terminal&lt;/code&gt; 目录，然后运行 &lt;code&gt;./cmdtool update&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该工具依赖 &lt;code&gt;wget&lt;/code&gt; 和 &lt;code&gt;7z&lt;/code&gt; 命令（安装方法。Ubuntu: &lt;code&gt;apt install wget p7zip-full&lt;/code&gt;, Archlinux: &lt;code&gt;pacman -S wget p7zip&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;升级过程不会覆盖配置文件，&lt;code&gt;etc/wsl-terminal.conf&lt;/code&gt; 和 &lt;code&gt;etc/minttyrc&lt;/code&gt; 会被放置到 &lt;code&gt;etc/wsl-terminal.conf.pacnew&lt;/code&gt; 和 &lt;code&gt;etc/minttyrc.pacnew&lt;/code&gt;。升级后 &lt;code&gt;bin&lt;/code&gt; 目录会残余一些 &lt;code&gt;.bak&lt;/code&gt; 文件，因为这些文件还在运行，不能被删除。下一次升级时，会将之前的 &lt;code&gt;.bak&lt;/code&gt; 文件全部删除，你也可以等那些进程退出后手删除那些文件。&lt;/p&gt;
&lt;h3&gt;使用 tmux&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 WSL 里安装 tmux。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;etc/wsl-terminal.conf&lt;/code&gt; 中设置 &lt;code&gt;use_tmux=1&lt;/code&gt;。如果版本号低于 &lt;code&gt;0.8.1&lt;/code&gt;，还需要添加 &lt;code&gt;attach_tmux_locally=1&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加如下代码到 &lt;code&gt;~/.bashrc&lt;/code&gt;（如果配置的是 &lt;code&gt;shell=bash&lt;/code&gt;）或者 &lt;code&gt;~/.zshrc&lt;/code&gt;（如果配置的是 &lt;code&gt;shell=zsh&lt;/code&gt;）：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[[ -z &amp;quot;$TMUX&amp;quot; &amp;amp;&amp;amp; -n &amp;quot;$USE_TMUX&amp;quot; ]] &amp;amp;&amp;amp; {
    [[ -n &amp;quot;$ATTACH_ONLY&amp;quot; ]] &amp;amp;&amp;amp; {
        tmux a 2&amp;gt;/dev/null || {
            cd &amp;amp;&amp;amp; exec tmux
        }
        exit
    }

    tmux new-window -c &amp;quot;$PWD&amp;quot; 2&amp;gt;/dev/null &amp;amp;&amp;amp; exec tmux a
    exec tmux
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后 &lt;code&gt;open-wsl&lt;/code&gt; 就会使用 tmux 了。&lt;/p&gt;
&lt;h3&gt;切换发行版&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;open-wsl -d distro&lt;/code&gt; （在 &lt;code&gt;cmd.exe&lt;/code&gt; 里运行）来切换发行版：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 列出所有发行版
&amp;gt; wslconfig /l
Legacy (默认)
Ubuntu

# 使用 Ubuntu（会运行 wslconfig /s Ubuntu 然后打开 wsl-terminal）
&amp;gt; open-wsl -d Ubuntu

# Ubuntu 已经是默认的发行版了
&amp;gt; wslconfig /l
Ubuntu (默认)
Legacy
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你不想修改默认的发行版，可以在 &lt;code&gt;etc/wsl-terminal.conf&lt;/code&gt; 里设置 &lt;code&gt;distro_guid&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;运行 &lt;code&gt;tools/3-write-distro-guids-to-config-file.js&lt;/code&gt;（&lt;a href="https://github.com/goreliu/wsl-terminal/blob/master/README.zh_CN.md#工具"&gt;帮助&lt;/a&gt;），然后会有窗口弹出结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;result has been written to ..\etc\wsl-terminal.conf:

; Legacy
;distro_guid={12345678-1234-5678-0123-456789abcdef}

; Ubuntu
;distro_guid={47a89313-4300-4678-96ae-e53c41a79e03}

remove the ; before distro_guid to use the distro.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以去掉 distro_guid 前边的 ; 来使用对应的发行版。&lt;/p&gt;
&lt;p&gt;如果你想通过命令行将 distro_guid 传递给 &lt;code&gt;open-wsl&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 将 distro guid 传递给 wslbridge
&amp;gt; open-wsl -b &amp;quot;--distro-guid {47a89313-4300-4678-96ae-e53c41a79e03}&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/goreliu/wsl-terminal/wiki/FAQ"&gt;常见问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/goreliu/wsl-terminal/wiki/TODO"&gt;开发计划&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;编译&lt;/h3&gt;
&lt;p&gt;确保已经在 WSL 里安装了这些 &lt;code&gt;wget&lt;/code&gt; &lt;code&gt;tar&lt;/code&gt; &lt;code&gt;xz&lt;/code&gt; &lt;code&gt;gzip&lt;/code&gt; &lt;code&gt;p7zip&lt;/code&gt; (安装方法。Ubuntu: &lt;code&gt;apt install wget tar xz-utils gzip p7zip-full&lt;/code&gt;, Archlinux: &lt;code&gt;pacman -S wget tar xz gzip p7zip&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;运行 &lt;code&gt;build.bat&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;许可&lt;/h3&gt;
&lt;p&gt;MIT&lt;/p&gt;</content></entry><entry><title>树莓派和其他 arm 开发板的本质区别</title><link href="/shu-mei-pai-he-qi-ta-arm-kai-fa-ban-de-ben-zhi-qu-bie.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/shu-mei-pai-he-qi-ta-arm-kai-fa-ban-de-ben-zhi-qu-bie.html</id><summary type="html">&lt;p&gt;我第一次听说树莓派时，并没有对它产生任何兴趣，因为对我来说这并不是一款新产品。在更早之前，我玩过 arm11 的开发板（S3C6410 系列），虽然和树莓派还是有区别的，比如体积更大、没有 HDMI 接口、自带触摸屏、价钱比树莓派稍贵等等，但我当时认为没有本质的不同，甚至性能和性价比上也不相上下。更重要的是，因为用户体验差和工作的原因，我的那块开发板在最初折腾几天后我就很少再用了，并且在两年前卖掉了。因此我对 arm 开发板的印象并不好，所以在之后的时间，我也没有关注树莓派的更新换代。&lt;/p&gt;
&lt;p&gt;&lt;img alt="我的那个 arm 开发板长这样，另外上边有块触摸屏" src="/images/029.jpg"&gt;&lt;/p&gt;
&lt;p&gt;几年之后，我又突然对树莓派感兴趣。我慢慢发现我当时的想法错了，因为那个错误的想法，我一直和本可以吸引我兴趣的树莓派失之交臂。&lt;/p&gt;
&lt;p&gt;树莓派的定位并不是一块用来做嵌入式开发的开发板，而是一个廉价并且高性价比的可以在一定程度取代 PC 并且硬件接口更丰富的软件开发和使用平台。有人可能会问，树莓派有 GPIO 接口，可以接很多硬件，怎么会是一个软件开发平台呢？那么我要问你 PC 有 USB 接口，可以接很多硬件，它是一个硬件开发平台吗？树莓派的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;我第一次听说树莓派时，并没有对它产生任何兴趣，因为对我来说这并不是一款新产品。在更早之前，我玩过 arm11 的开发板（S3C6410 系列），虽然和树莓派还是有区别的，比如体积更大、没有 HDMI 接口、自带触摸屏、价钱比树莓派稍贵等等，但我当时认为没有本质的不同，甚至性能和性价比上也不相上下。更重要的是，因为用户体验差和工作的原因，我的那块开发板在最初折腾几天后我就很少再用了，并且在两年前卖掉了。因此我对 arm 开发板的印象并不好，所以在之后的时间，我也没有关注树莓派的更新换代。&lt;/p&gt;
&lt;p&gt;&lt;img alt="我的那个 arm 开发板长这样，另外上边有块触摸屏" src="/images/029.jpg"&gt;&lt;/p&gt;
&lt;p&gt;几年之后，我又突然对树莓派感兴趣。我慢慢发现我当时的想法错了，因为那个错误的想法，我一直和本可以吸引我兴趣的树莓派失之交臂。&lt;/p&gt;
&lt;p&gt;树莓派的定位并不是一块用来做嵌入式开发的开发板，而是一个廉价并且高性价比的可以在一定程度取代 PC 并且硬件接口更丰富的软件开发和使用平台。有人可能会问，树莓派有 GPIO 接口，可以接很多硬件，怎么会是一个软件开发平台呢？那么我要问你 PC 有 USB 接口，可以接很多硬件，它是一个硬件开发平台吗？树莓派的 GPIO 接口，和 PC 的 USB 接口，没有本质的区别，都是用来连接硬件的，只是接口更底层一些。&lt;/p&gt;
&lt;p&gt;那么这样看，我之前用的 arm11 开发板，是否也是软件开发平台呢？答案是否定的，这要看目标用户。我们可以把目标用户简单分为三类：硬件开发者、软件开发者和使用者。硬件开发者主要是设计、改良硬件和为新老硬件编写驱动程序等等，软件开发者主要是在现有的硬件下开发软件（通常不包括驱动程序），使用者使用现有硬件和软件而不进行开发。&lt;/p&gt;
&lt;p&gt;我之前使用的 arm11 开发板，主要的目标用户是硬件开发者和软件开发者（可以不严谨地统称为嵌入式开发者），几乎没有使用者，因为对于没有开发经验的人，用户体验是很差的。而树莓派的主要目标用户是软件开发者（和嵌入式开发者有重叠但并不多）和使用者，用户体验很好，但几乎没有硬件开发者，因为树莓派的硬件相对比较封闭，不销售单独的 SoC 和其他芯片，硬件资料也并不是很完善，在硬件层面很难 DIY（对很底层的软件开发者也存在类似的问题）。&lt;/p&gt;
&lt;p&gt;那么目标用户的不同，就导致树莓派虽然看起来很像其他的 arm 开发板，基本也能用和其他的 arm 开发板一样的方式使用，性质却有很大的不同。&lt;/p&gt;
&lt;p&gt;这也解释了为什么很多嵌入式行业的软硬件开发者并不喜欢或者看好树莓派，甚至对它很不屑，而很多对嵌入式了解很少的开发者以及使用者会对树莓派趋之若鹜。&lt;/p&gt;
&lt;p&gt;那么我为什么会对树莓派感兴趣，而对之前那块 arm 开发板无感呢？最主要的问题并不是用户体验差，而是软件方面的配套环境不完善。最重要的是 Linux 内核版本支持。官方只提供低版本的 Linux 内核（2.6 系列），如果用这个内核来配合最新的发行版使用，几乎是不可能的，会遇到许多问题，一方面是这个内核缺少很多最新发行版使用的特性，另一方面是很多硬件方面的支持不只是替换内核文件和内核模块的事情（比如有些工具也需要移植），替换起来也麻烦。如果想使用更新版本的内核，需要打各种补丁以及自行修改代码，虽然硬件的资料比较齐全，理论上可以实现，但即使是经验丰富的嵌入式开发者也很难搞定，也没有人做好了提供给别人使用。这就导致几乎只能使用官方提高的老旧 Linux 镜像（或者其他古老版本的发行版）。而这个 Linux 环境几乎毫无用户体验可言，最新版本的软件很难安装上（几乎都需要自己编译，而且容易出现编译错误），常见的 USB 外设（比如摄像头、无线网卡、蓝牙）也很难驱动起来（运气好的话，可以从其他地方找来驱动代码，修复很可能出现的编译错误）。&lt;/p&gt;
&lt;p&gt;而树莓派的软件环境是很好的，基本可以使用最新的 Linux 内核和发行版（比如 Archlinux），并且有很多人为这个平台开发软件，用户体验有质的提升。即使是对嵌入式开发一窍不通的开发者或者使用者，也可以用树莓派做他们想做的事情。&lt;/p&gt;
&lt;p&gt;另外我发现一个有趣的事情，折腾树莓派的人群（至少在国内），和（曾经的） Linux 桌面用户群体很相似（我曾经混迹于 Linux 桌面用户社区，很多人折腾桌面美化、系统配置、工具优化、写小脚本等等，玩 Linux 而不是用 Linux），他们主要是使用者，可能稍微会一些脚本或者其他编程语言，但并没有独立开发完整应用程序的能力和意向。这和嵌入式开发者人群是很不同的。&lt;/p&gt;
&lt;p&gt;综上，树莓派和其他 arm 开发板的本质区别在于目标用户不同。树莓派的目标用户主要是软件开发者和使用者，而其他 arm 开发板的主要用户是硬件开发者和软件开发者。这也是树莓派能够吸引更多用户的一个重要原因。&lt;/p&gt;</content></entry><entry><title>我的编程经历</title><link href="/wo-de-bian-cheng-jing-li.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-de-bian-cheng-jing-li.html</id><summary type="html">&lt;p&gt;这算是第一篇非技术的文章吧。转眼间也陆续写了十多篇 AHK 教程，今天整理了下，没有找到特别想写的话题，就简单写下自己对 AHK 这门编程语言的看法吧，或许也会提一些其他或有关或无关的事情。&lt;/p&gt;
&lt;p&gt;前些天在 AHK 官网论坛看到这样一个帖子：&lt;a href="https://autohotkey.com/board/topic/90892-why-doesnt-ahk-get-the-respect-it-deserves/"&gt;Why doesn't AHK get the respect it deserves? &lt;/a&gt;（为什么 AHK 没有得到应有的尊重）。里边一些人的观点还是比较有参考意义的，我昨天想翻译一下其中的部分内容，现在只翻译了一部分，等完成了可能会发出来。然后我又一想，为什么不先表达一下我自己的观点呢？&lt;/p&gt;
&lt;p&gt;AHK 对于很多用户来说似乎扮演着一门启蒙编程语言的角色，用户慢慢发现 AHK 有着一些限制，于是转而使用 Python 等其他编程语言。而我不是这样的。我第一次系统学习的编程语言是 JavaScript，距离现在也已经有十年之久。在之后的十年里，我陆续学习和使用过各种各样的编程语言，在工作中用的最多的则是 C++、Shell 和 Python。而我开始对 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;这算是第一篇非技术的文章吧。转眼间也陆续写了十多篇 AHK 教程，今天整理了下，没有找到特别想写的话题，就简单写下自己对 AHK 这门编程语言的看法吧，或许也会提一些其他或有关或无关的事情。&lt;/p&gt;
&lt;p&gt;前些天在 AHK 官网论坛看到这样一个帖子：&lt;a href="https://autohotkey.com/board/topic/90892-why-doesnt-ahk-get-the-respect-it-deserves/"&gt;Why doesn't AHK get the respect it deserves? &lt;/a&gt;（为什么 AHK 没有得到应有的尊重）。里边一些人的观点还是比较有参考意义的，我昨天想翻译一下其中的部分内容，现在只翻译了一部分，等完成了可能会发出来。然后我又一想，为什么不先表达一下我自己的观点呢？&lt;/p&gt;
&lt;p&gt;AHK 对于很多用户来说似乎扮演着一门启蒙编程语言的角色，用户慢慢发现 AHK 有着一些限制，于是转而使用 Python 等其他编程语言。而我不是这样的。我第一次系统学习的编程语言是 JavaScript，距离现在也已经有十年之久。在之后的十年里，我陆续学习和使用过各种各样的编程语言，在工作中用的最多的则是 C++、Shell 和 Python。而我开始对 AHK 感兴趣是在今年（2016）年初。那么我为什么会对 AHK 感兴趣？说起来就有点话长了。&lt;/p&gt;
&lt;p&gt;在学习 JavaScript 之前，我也并不是没有接触过其他编程语言。还是在初中的时候，我偶然翻了一本哥哥的计算机书籍。那是一本大杂烩，从最开始的二进制介绍，到 Windows 的使用，再到 Office 的操作，一直讲到最后用 Visual Basic 编写简单的程序。对前边的章节我基本都不大感兴趣，却对最后一部分特别感兴趣。我还记得里边的一些例子，比如算最大公约数，解决鸡兔同笼问题等。和后来看的 C 语言教程不同，那些程序都是有图形界面的，我隐约还记得鸡兔同笼程序界面上就有小鸡和兔子的简笔画。但当时家里没有电脑，我还未成年上不了网吧（当时管得特别严，后来我上高中时管得松了就可以去了）。初中确实每周有一节计算机课，但学的是 Word 操作，用的还是 Windows 98 系统。所以那些例子我也只能看看而已了。&lt;/p&gt;
&lt;p&gt;我上高中时，可以偶尔去网吧了。当时想装个 Visual Basic 试试，但对电脑和网络了解很少，没装上就不了了之了。当时我又偶然看到哥哥的一本计算机的书，也就是那本谭浩强的《C 语言程序设计》。其实对我的吸引力没有之前那本的大，因为里边的例子都不带图形界面，看起来很枯燥。但我还是去网吧下了个 Turbo C 2.0 试试，比装 Visual Basic 容易很多，很快就装上了。然后输入个简单的程序，也运行成功了。但想在也不记得当时是否有兴奋的感觉，好像不大吧，我还是想写带图形界面的程序，所有也没有深入了解 C 语言。&lt;/p&gt;
&lt;p&gt;又过了半年多，一次我在商场的书店闲逛，发现一本讲 HTML 的书。在小城镇发现讲编程的书是非常难得的，我就看起来。前边的设置字体、超链接等内容我不大感兴趣，但翻到了表单部分突然来了兴致，这不就是我之前想写的图形界面程序吗。当时我没有买那本书，毕竟几十块钱对我来说还有点贵，但我去网吧下载了一些教程回来。我有一个当时流行的电子词典，可以把文本文档下载到里边，虽然空间只有不到 2M，但也足够看一段时间了。&lt;/p&gt;
&lt;p&gt;然后我发现 HTML 似乎只能画界面，而写不了逻辑，然后我就寻找下一个目标。当时比较流行的是 ASP 和 JSP，我就下了一些简单的教程回来看，都是在 HTML 里嵌入一些语句的那种，看得我一头雾水。更麻烦的时我想运行下看看效果，但环境还是不会搭建，很麻烦的样子。我就继续在网上搜罗各种文章，偶然下了一篇 JavaScript 的教程。我发现用 HTML 和 JavaScript 写的例子直接用浏览器打开就能运行，大喜过望。于是开始专心学习 JavaScript。&lt;/p&gt;
&lt;p&gt;现在想 JavaScript 是我学得最用功的编程语言，笔记记了好几本。无奈当时基础薄弱，又无人指点，很多地方翻来覆去想了好久才理解。提一个我印象深刻的例子。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当时看教程没几天就看到了类似这样的例子，文字解释很少，我就看不明白这个函数是在做什么。翻来覆去地想了好几天，最后才想明白。也许也因为这个原因，我之后再学习其他编程语言基本没遇到过特别困难的问题吧。现在回想当时还学了很多 JavaScript 的高级内容，比如如何实现继承。还有其他乱七八糟的主题因为印象不深现在已经忘记了。&lt;/p&gt;
&lt;p&gt;因为一般只有周末我才有时间去网吧，而且主要时间还用在到处找教程上边，实际练习编程的机会很少。学了一段时间 JavaScript 后，我渐渐也没兴趣了。一个原因是用 HTML 和 JavaScript 写的东西虽然也可以有编辑框、按钮等控件，但毕竟只是一个网页，和之前书里那些用 Visual Basic 写的程序是很不一样的，我想写那种独立运行的程序。我偶然发现将 htm 文件的扩展名修改成 hta，运行起来就真的像一个独立的程序。这个技巧我一直用到大学，后来工作后和一些做前端的同事交流时发现，大家都不清楚 hta 文件的事情。&lt;/p&gt;
&lt;p&gt;但我对 hta 还是不大满意，当时还是想写正经的 exe 程序，而不是 hta 这种“山寨货”。于是继续去网上各种搜，终于搜到了用 C 语言写图形界面软件的方法，也就是传说中的 Windows API。用过 Windows API 的人都知道用它写个带窗口的 Hello World 都挺麻烦的，但我也不在乎，下载一系列教程就开始学。现在还记得当时已经学到用代码直接在窗口绘图和创建 wmf 文件。还是之前的原因，我很少练习，主要是看教程，记笔记，但偶然在网吧编译运行一个实例时，还是很有满足感的。&lt;/p&gt;
&lt;p&gt;当然因为需要用 Windows API，我开始比较系统地学习 C 语言。同时，我又收集了各种各样的教程来看。那个时候破解技术非常火，有一个很有名的看雪论坛。我就突然对破解技术感兴趣了，不过现在印象已经不深了，只记得当时学过汇编语言，不是后来大学学的那种 16 位 8086 汇编，而是 32 位汇编，而且可以直接调用 Windows API 写程序（现在想用汇编写图形界面软件的人是怎样的心态）。当然写汇编主要不是用来写程序的，而是看反汇编的代码，和直接修改代码来破解程序。不过学破解技术没有学编程语言那么简单，我后来看手动脱壳之类的高级教程时，一是电子词典显示不了图片，文字排版也有问题，二是少有实际练习的机会，看得雨里雾里，慢慢热情也就散去了。&lt;/p&gt;
&lt;p&gt;后来我就开始学 C++，因为学 C 语言时就经常看有人提到 C++，很高级的样子。一学发现果然比 C 复杂不少，主题层出不穷，开始我还比较有兴致，后来慢慢也不了了之了。在高中快结束的时候，我还学了一段时间的 D 语言，不过也只是记了半本笔记，后来也基本全忘记了。&lt;/p&gt;
&lt;p&gt;在高考之后的假期里，我终于有了&lt;/p&gt;</content></entry><entry><title>我对《道德经》的理解（第二章 有无相生）</title><link href="/wo-dui-dao-de-jing-de-li-jie-di-er-zhang-you-wu-xiang-sheng.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-dui-dao-de-jing-de-li-jie-di-er-zhang-you-wu-xiang-sheng.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;第二章 有无相生&lt;/p&gt;
&lt;p&gt;天下皆知美之为美，斯恶已；皆知善之为善，斯不善已。故有无相生，难易相成，长短相形，高下相倾，音声相和，前后相随。是以圣人处无为之事，行不言之教。万物作焉而不辞，生而不有，为而不恃，功成而弗居。夫唯弗居，是以不去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二章直接从第一章的天地大道拉回到为人处世上，具有更大的实际价值。但因为每个人的价值观不同，对这段文字的理解也有很大的差异。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;天下皆知美之为美，斯恶已；皆知善之为善，斯不善已。&lt;/code&gt;这句话广为流传，但解释方法不一。我的理解是：如果天下人都知道怎样的东西是美的，这样就会产生丑；如果都知道怎样的行为是善的，这样就会产生恶。我看了几个版本讲解《道德经》的书，都不是这样解释的，这里暂不讨论其他的解释。前半句并不是说美是不好的，或者说因为有了美，所以丑就产生了，而是讲审美标准的问题。&lt;/p&gt;
&lt;p&gt;如果天下人的审美标准都一致，那么就出问题了。比如如果所有人都认为只有大眼睛瓜子脸是美的，那么小眼睛圆脸的人就会认为自己丑，他们没做任何错事，却从生下来就被贴上了一个丑的标签 …&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;第二章 有无相生&lt;/p&gt;
&lt;p&gt;天下皆知美之为美，斯恶已；皆知善之为善，斯不善已。故有无相生，难易相成，长短相形，高下相倾，音声相和，前后相随。是以圣人处无为之事，行不言之教。万物作焉而不辞，生而不有，为而不恃，功成而弗居。夫唯弗居，是以不去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二章直接从第一章的天地大道拉回到为人处世上，具有更大的实际价值。但因为每个人的价值观不同，对这段文字的理解也有很大的差异。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;天下皆知美之为美，斯恶已；皆知善之为善，斯不善已。&lt;/code&gt;这句话广为流传，但解释方法不一。我的理解是：如果天下人都知道怎样的东西是美的，这样就会产生丑；如果都知道怎样的行为是善的，这样就会产生恶。我看了几个版本讲解《道德经》的书，都不是这样解释的，这里暂不讨论其他的解释。前半句并不是说美是不好的，或者说因为有了美，所以丑就产生了，而是讲审美标准的问题。&lt;/p&gt;
&lt;p&gt;如果天下人的审美标准都一致，那么就出问题了。比如如果所有人都认为只有大眼睛瓜子脸是美的，那么小眼睛圆脸的人就会认为自己丑，他们没做任何错事，却从生下来就被贴上了一个丑的标签，当然会不舒服，甚至有些人为了迎合统一的审美标准去整容。但这个审美标准又不是一直以来都固定的，可能一段时间之后大家又都认为小眼睛圆脸是美的，于是另一批人又不舒服了。不管审美标准是怎样的，永远会有人因为不符合审美标准而不舒服，进而引发很多事情。那么为什么需要一个统一的审美标准？情人眼里出西施，审美本身是一个非常个性化的事情，如果没有统一的审美标准，那么大家就不会削足适履来迎合那个审美标准。这句话不是说不应该有审美标准，而是说每个人都有自己独特的审美标准，不应该也没必要统一。如果不统一，没有什么问题，追求美也是一件很正常的事情，甚至有人就喜欢瓜子脸去整容也很正常。但如果审美标准统一了，那么就会伤害很多无辜之人，这美也就变味了。而当今的世界恰好被这句话说中了，在媒体的助力下，人们或者主动或者被强迫，慢慢认同了统一的审美标准，结果大家也是都看得到的。&lt;/p&gt;
&lt;p&gt;美丑说的是审美标准，善恶说的是道德准则，我认为后半句更为重要。不应该有统一的审美标准，大家可能都好理解，但统一的道德准则都不应该有吗？这个好像有些违背常理。其实不是，二者是异曲同工的。道德准则用来评价一个人行为好不好，或者说美不美，其实和审美标准是差不多的。还是举个例子，比如如果统一的道德准则里写应该尊老爱幼。这看起来好像没问题，就和说大眼睛瓜子脸的人美一样。但如果有个老人做尽坏事，从不尊重别人，大家还必须尊敬他吗？有人说这是强词夺理，完善下道德准则排除某些特殊情况就可以了。那么问题又来了，怎么判断一件事是好事还是坏事呢？比如砍树来建造房屋对居住的人来说是好事，对在树下乘凉的人是坏事，那么好坏以谁为准呢？所以统一的道德标准必然不是在所有情况都是合理的，那么在那些不合理的情况中，人们就会因为自己做了不道德的事情而受到别人或者自己内心的谴责，甚至进而做出其他事情来。&lt;/p&gt;
&lt;p&gt;那么是说道德准则不应该有吗？我们来看下道德标准是做什么的。它用来约束人们的行为，目的是让人们往更好的方向发展，少做坏事，这里暂且不提好坏没有统一标准的问题。那么这个目的能达到吗？我们可以类比一下，法律和道德标准类似，但有处罚手段，按理说它应该比道德尊则更有效。但法律并没有杜绝违法事情的发生，甚至也没有数据能证明法律越完善或者处罚方式越重违法事情就越少。很多人明知道一件事是违法的，如果被抓到会被处罚，他还会去做。那么问题出在哪里？&lt;/p&gt;
&lt;p&gt;根本原因是人的行为是没办法完全从外界约束的。也就是说随便找来一个人，用各种方式强迫他你必须做什么和不做什么是行不通的。每种方法可能都有一定的效果，但都不会完全符合预期。那么难道就没有办法让人们不做某些公认的坏事吗？方法是有的，但立竿见影的方法是没有的。最重要的方法是教育，人们的觉悟提高后，便不会做某些坏事。那么有人问了，把一个小偷抓住教育一顿再放了就能解决问题吗？当然很可能解决不了问题。但教育是从小抓起的，一个人成为了小偷，就已经说明教育失败了，再教育也未必能解决问题。&lt;/p&gt;
&lt;p&gt;教育一个人，不是告诉他应该做什么不应该做什么，这是道德准则的内容，我们已经知道道德准则用处不大。没有什么事情是应该做的或者不应该做的，你什么都可以做或者不做，但你需要为你的行为负责。你可以打人，但你打了别人，别人疼，反过来打你，你也会感觉疼，于是你知道打人是对自己不利的，于是不再打人。你甚至不需要打别人，用手打自己，也会知道被打的滋味不舒服，自己不舒服，别人自然也会不舒服，所以不会去打人。那么一个小孩子怎么知道需要应该做什么，不应该做什么，总不能每件事情都尝试一下吧，如果没有道德准则和法律的话。他们会模仿大人，所以言传身教才是最好的教育。而小孩在模仿大人时，大人应该告诉孩子做这件事的目的是什么，为什么不那样做等等，这是教育的过程。如果孩子在不经意间做了不那么好的事情，那么应该为此承担后果（如果后果太大孩子无法承担，大人应该干涉让产生的后果尽量小些；如果后果太小孩子无法察觉到，可以加以配合设法让后果尽量大些，或者讲解已有的案例），但这后果是自然而然的结果，而不是和那件事情本身无关的处罚。同时，大人应该告诉孩子因为你这样做，导致了这样的结果，如果你不喜欢这样的结果，就应该避免以后再这样做。在这个过程中，没有任何强迫的成分，孩子便不会反抗。慢慢地，孩子就会知道自己该做什么不该做什么，不是因为什么地方写了，而是他知道不这样做会得到自己不喜欢的结果。&lt;/p&gt;
&lt;p&gt;但现在很多所谓的教育完全变了味，只是简单的告诉孩子什么应该做什么不该做，而孩子们不清楚背后的道理，自然很难全盘接受。如果他们不按要求这样做，会被处罚，而这处罚和他做的事情可能完全不沾边。问题就更严重了，因为他们同样不知道背后的道理，可能认为只要能避免被处罚到或者能够承受住处罚就没事了。在这样的教育下，任何十恶不赦的事情都可能被一个人做出来，因为教育是失败的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;故有无相生，难易相成，长短相形，高下相倾，音声相和，前后相随。&lt;/code&gt;因为美在一定的情况（当大家的审美标准一致时，看起来没什么问题，却滋生了丑）会转化成丑，善在一定情况会转化成恶，所以有和无不是那么边界明确的，无中生有，有中生无，这种转化是潜移默化的。同样地，难易、长短、高下、音声、前后之间也有类似的转化。这里不是简单地说有长的东西自然就有短的东西，或者有短的东西才能体现出长的东西这样浅显的道理，因为这是一个类比，我们需要知道类比的是什么，是相互转化，而不是相互依存。也就是难和易会相互转化，长和短会相互转化等等，那怎么理解这个呢，比如长和短相互转化，长的不就是比短的长吗，怎么转化？&lt;/p&gt;
&lt;p&gt;我们再回来看美丑，因为美丑并没有统一的标准，所以美丑不是事物的固有属性。而难易、长短等也是如此。因为没有统一标准，那么我们就不能说一个东西是长的，只能说它比另一个东西长，但和另一个更长的东西比，长的东西就变成短的了。这是长和短之间的转化，这个转化也是人们对事物发展的一种描述，是动态的而不是静态的。而这个排比类比的是这个转化，我们不能把其他的方面也类比掉，那样就说不通了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;是以圣人处无为之事，行不言之教。&lt;/code&gt;因此圣人做顺其自然的事情，用自己的行动而不是语言来教育别人。因为之前所说的，事物会自然而然地进行各种转化，圣人不会强行违法自然事物发展的规律来做事情，所以会做顺其自然的事情。无为不是不做事情，而是不刻意做事情，这个刻意是指在违反事情发展规律的情况做事情。教育也是一样，为什么行不言之教？因为言和行不一致的话，那么就可能是用言来强迫行，比如和某人说你必须做什么不做什么，这种教育效果很差。圣人不去要求别人应该做什么不该做什么，但会用自己的实际行动来告诉大家我这样做可以过得幸福，可以成为所谓的圣人，其他人如果也期待自己成为这样的人，便会去效仿。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;万物作焉而不辞，生而不有，为而不恃，功成而弗居。夫唯弗居，是以不去。&lt;/code&gt;万物顺应规律来做事情而不说（比如大树会吸收二氧化碳排放氧气，但它不会说自己在做这件事情），孕育了其他东西却不将其据为己有（比如大树孕育出种子并帮助它其成为小树，但不会将小树据为己有），有自己的作为但不会因此而强求什么（比如大树不会因为提供了动物需要的氧气而向动物强行索取什么），做出了功绩但不会以这些来自居（比如大树不会因为自己让这个世界更美好而自认为了不起）。正因为不以功绩自居，才能一直保持这样（比如大树不认为自己的行为多么了不起，所以它一直在做这件事，不会认为自己已经做够了就不做了）。&lt;/p&gt;
&lt;p&gt;而引申到人的身上也是一样的。做每一件事情时不需要大声告诉别人我正在做什么，自己创造出的东西或者生育的孩子不要据为己有，做出有作为的事情不要因此强行索取什么，做出来功绩也不要以这些功绩自居而认为自己了不起，这样才能持续下去。这不是高尚的品德，而是万物的规律，人自然也在万物之中。如果不这样做当然也可以，但那样就会产生问题。比如将自己的孩子据为己有，但他不可能每件事情都听你的，当他不听你的时你可能就会难受；再如因为自己有了很大的功绩来索取什么，如果得不到自己就会感觉不舒服等等。因为无视规律，所以会得到不理想的结果，这是需要自己承受的，而不是让别人来承受。这也是《道德经》和很多其他经典有所不同的地方，它从来不讲一个人应该怎么做，不应该怎么做，约定一个规范或者树立一个榜样，而是说如果你这样做可以得到怎样的结果，不这样做会怎样，这可以称之为规律，而具体怎样做取决于每个人的选择。&lt;/p&gt;</content></entry><entry><title>我对《道德经》的理解（第三章 无知无欲）</title><link href="/wo-dui-dao-de-jing-de-li-jie-di-san-zhang-wu-zhi-wu-yu.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-dui-dao-de-jing-de-li-jie-di-san-zhang-wu-zhi-wu-yu.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;第三章 无知无欲&lt;/p&gt;
&lt;p&gt;不尚贤，使民不争。不贵难得之货，使民不为盗。不见可欲，使民心不乱。
是以圣人之治，虚其心，实其腹，弱其志，强其骨；常使民无知无欲；使夫智者不敢为也，为无为，则无不治。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一章的内容比较平实，但争议非常大，仔细探讨也非常有意义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;不尚贤，使民不争。&lt;/code&gt;不崇尚贤能的人，让人民不为此竞争。这句话字面的意思基本上没有争议，有争议的是它是否有道理。尚贤，平白点说就是树立榜样，希望人们借助榜样的力量更好地完善自我，看起来也是一件不错的事情。但仔细想这个榜样和道德准则很相似，都是告诉人们应该做什么或者不应该做什么。而很多年的实践表明树立榜样的效果也不是非常理想的，比如我国树立了很多年的雷锋形象，是否取到理想的结果大家有目共睹。但除了和道德准则相同的问题外，尚贤还会引发一个新问题，即竞争，展开说即对名誉的竞争，竞争的问题我们后续再探讨。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;不贵难得之货，使民不为盗。不见可欲，使民心不乱。&lt;/code&gt;不将难得的物品视为贵重之物，让人民不会对它产生偷盗的心思。不炫耀可能刺激别人欲望的东西，让人民的心思不会被这欲望扰乱。&lt;/p&gt;
&lt;p&gt;这里说得是不要有统一的人生观（第一句 …&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;第三章 无知无欲&lt;/p&gt;
&lt;p&gt;不尚贤，使民不争。不贵难得之货，使民不为盗。不见可欲，使民心不乱。
是以圣人之治，虚其心，实其腹，弱其志，强其骨；常使民无知无欲；使夫智者不敢为也，为无为，则无不治。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一章的内容比较平实，但争议非常大，仔细探讨也非常有意义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;不尚贤，使民不争。&lt;/code&gt;不崇尚贤能的人，让人民不为此竞争。这句话字面的意思基本上没有争议，有争议的是它是否有道理。尚贤，平白点说就是树立榜样，希望人们借助榜样的力量更好地完善自我，看起来也是一件不错的事情。但仔细想这个榜样和道德准则很相似，都是告诉人们应该做什么或者不应该做什么。而很多年的实践表明树立榜样的效果也不是非常理想的，比如我国树立了很多年的雷锋形象，是否取到理想的结果大家有目共睹。但除了和道德准则相同的问题外，尚贤还会引发一个新问题，即竞争，展开说即对名誉的竞争，竞争的问题我们后续再探讨。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;不贵难得之货，使民不为盗。不见可欲，使民心不乱。&lt;/code&gt;不将难得的物品视为贵重之物，让人民不会对它产生偷盗的心思。不炫耀可能刺激别人欲望的东西，让人民的心思不会被这欲望扰乱。&lt;/p&gt;
&lt;p&gt;这里说得是不要有统一的人生观（第一句）和价值观（第二、三句）的。之前我们了解到统一的审美标准和道德准则都是不可取的，这里更深一层，统一的人生观和价值观就有问题。这里不得不说的是广为流传的俗语“毁三观”、“三观不正”，三观是指人生观、价值观、世界观，而在些俗语中，三观有时指价值观（即认为什么东西有价值什么东西没价值），有时也会指人生观（人生的目的和意义是什么），很少涉及到世界观（认为这个世界是怎样的。这个是比较本质的问题，不是发现天下之大无奇不有就毁世界观了），还有很多情况是误用，暂且不提。&lt;/p&gt;
&lt;p&gt;这三观是相互联系的，比如一个人的价值观必然会影响到他的人生观。我把价值观放在前边，是因为人在成长过程中往往是先认识到外部事物，然后才会认识到自己。孩子往往很早就知道什么好吃好看，什么不好吃不好看，但真正开始思考“我”的问题就比较晚了。所以价值观是在人生观之前就开始形成了，而人生观在形成过程中必然会受价值观影响。而世界观通常也和人生观一同形成，因为通常仔细考虑“我”的问题时，才会考虑到“我”和整个外部世界的关系，而更早之前虽然也会接触很多外物，但很难有一个完整世界的概念。三者中，价值观是根基。但三者中，只有世界观可以有对错之分，因为大家所指的世界是同一个（但也不是说只有一种世界观是对的其他的都是错的，世界观的问题以后有机会可以再探讨），而人生观和价值观是没有对错之分的，也就没有所谓的正不正，自然没必要也不应该统一。&lt;/p&gt;
&lt;p&gt;统一的人生观和价值观都会导致剧烈的竞争，因为前者涉及想成为怎样的人，后者涉及想得到怎样的东西。如果大家都想成为同样的人，或者得到同样的东西，一旦因为某些原因大家不能全部如愿，竞争就难以避免了。&lt;/p&gt;
&lt;p&gt;其实这和审美标准是一样的，好和坏不是事物自身的属性，而是人们根据某种标准评判的。通常情况每个人的评判标准不同，比如有人喜欢吃苹果，那么他就认为苹果好，有人喜欢吃梨，他就认为梨好。这样是没问题的，因为不会所有人都去疯抢苹果而不要梨。同样地，有人认为水晶好看，有人认为钻石好看，大家不会一窝蜂地去抢买钻石，把它的价格炒到很高。&lt;/p&gt;
&lt;p&gt;但如果有人发现钻石远比水晶稀有和难制作，那么他可能会为钻石赋予特殊的象征意义，因此可以从中牟利，不管他是否真的喜欢钻石。然后其他可能喜欢水晶而不喜欢钻石的人，因为相信它的象征意义而去购买，进而钻石价格被拉高，竞争也就产生了。有的人钱不够，但也想要钻石，就可能产生偷抢的行为。有的人本来收入没什么问题，但因为社会普遍接受的钻石象征意义而不得不牺牲生活质量来购买钻石。由此引发的问题层出不穷。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;是以圣人之治，虚其心，实其腹，弱其志，强其骨；常使民无知无欲；使夫智者不敢为也，为无为，则无不治。&lt;/code&gt;圣人执政，会是人民心中虚无而腹中饱满，野心薄弱而筋骨强壮，让人民没有不必要的知识和欲望。让聪明的人不去出风头，这样不刻意做什么，就可以治理好天下。这可能是《道德经》里最有争议的一句话，看起来很像愚民政策，让人们都变傻，然后浑浑噩噩地过日子，不惹事，自然就不用治理了。&lt;/p&gt;
&lt;p&gt;我们来看一些老子眼中“理想”的民众是怎样的，虚心、实腹、弱志、强骨、无知无欲。首先虚其心不是让他心志虚弱的意思（可以想一下无为而治重点是顺应自然不刻意做什么，一个人正常成长在没有其他人刻意干扰的情况心志不会变得虚弱），而是让他谦逊不自大。弱志是指没有庞大的野心。无知无欲指没有不必要的知识和欲望，而不是让人们没有知识和欲望（拿欲望来说，你有办法让别人没有欲望吗？基本上没有人能做到没有欲望，何谈让别人没有欲望，这显然是不切实际的，不只无为，有为也做不到。但可以做到不刺激别人的欲望，让其越来越大。知识也是一样，但大家普遍有个误解是掌握的知识越多就越好，所以可能比较难理解。其实不是这样的，生存必需的知识当然是很重要的，但很多无关的知识就不是了，读尽天下书，也未必能过得幸福，比如现在随便一个人掌握的知识就可能远超老子，但有几人敢说比老子过得幸福。所以不去刺激人们的求知欲望，反而更容易让人们过上幸福生活）。其实老子自己就是这样的人，他希望人们能和他一样过上满意的生活。&lt;/p&gt;</content></entry><entry><title>我对《道德经》的理解（第四章 和光同尘）</title><link href="/wo-dui-dao-de-jing-de-li-jie-di-si-zhang-he-guang-tong-chen.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-dui-dao-de-jing-de-li-jie-di-si-zhang-he-guang-tong-chen.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;第四章 和光同尘&lt;/p&gt;
&lt;p&gt;道冲，而用之或不盈，渊兮似万物之宗。挫其锐，解其纷，和其光，同其尘，湛兮，似或存。吾不知谁之子，象帝之先。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;道冲，而用之或不盈，渊兮似万物之宗。挫其锐，解其纷，和其光，同其尘，湛兮，似或存。吾不知谁之子，象帝之先。&lt;/code&gt;道虽然是虚无的，但怎么用也用不完，深远的像万物本源。道将自己的锋芒消磨，将自己的繁杂消解，调和自己于光芒之中，混同自己于尘土之中，他深远的好像存在又好像不存在。我不知道它是如何产生的，好像在天帝之前就已经存在了。&lt;/p&gt;
&lt;p&gt;这章是用比喻的方法对道进行进一步的描述。总结起来，道是一种无所不在却有看不到摸不着无比深远的东西。这看起来是在说道的特性，但仔细品味会发现说的是我们对道基本一无所知。它无所不在，所以我们不清楚它在哪里。它总也用不完，所以我们不知道它一共有多少。它不锋芒也不繁杂，我们不知道它有什么具体的特性。我们不知道它是怎么产生的。它很深远，所以我们没办法触及到它。&lt;/p&gt;
&lt;p&gt;《道德经》里的道到底是什么 …&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;第四章 和光同尘&lt;/p&gt;
&lt;p&gt;道冲，而用之或不盈，渊兮似万物之宗。挫其锐，解其纷，和其光，同其尘，湛兮，似或存。吾不知谁之子，象帝之先。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;道冲，而用之或不盈，渊兮似万物之宗。挫其锐，解其纷，和其光，同其尘，湛兮，似或存。吾不知谁之子，象帝之先。&lt;/code&gt;道虽然是虚无的，但怎么用也用不完，深远的像万物本源。道将自己的锋芒消磨，将自己的繁杂消解，调和自己于光芒之中，混同自己于尘土之中，他深远的好像存在又好像不存在。我不知道它是如何产生的，好像在天帝之前就已经存在了。&lt;/p&gt;
&lt;p&gt;这章是用比喻的方法对道进行进一步的描述。总结起来，道是一种无所不在却有看不到摸不着无比深远的东西。这看起来是在说道的特性，但仔细品味会发现说的是我们对道基本一无所知。它无所不在，所以我们不清楚它在哪里。它总也用不完，所以我们不知道它一共有多少。它不锋芒也不繁杂，我们不知道它有什么具体的特性。我们不知道它是怎么产生的。它很深远，所以我们没办法触及到它。&lt;/p&gt;
&lt;p&gt;《道德经》里的道到底是什么？我一直认为这个问题是没办法用文字回答的。因为一旦开始回答这个问题，我们就必须引入其他概念，于是掉入概念陷阱，我来演示一下。&lt;/p&gt;
&lt;p&gt;如果我说这个世界最初只有道，然后道慢慢分化发展成这世间万物，这里就明显产生矛盾了。“世界”这个概念怎么定义？它在道之前就存在了吗？它和道共存吗？如果道都解释不清，那“世界”这个概念怎么解释？这里还没有涉及到麻烦的时间问题。&lt;/p&gt;
&lt;p&gt;这里我们再仔细探讨下给东西命名的问题。比如三个孩子，第一个见过苹果的画，知道它叫苹果；第二个见过苹果，但不知道它叫什么；第三个没见过苹果的外形，也不知道它叫什么，但吃过被切成块的苹果。那这三个孩子谁对苹果了解更多一些？如果老师拿来一个苹果给三个孩子看，只有第一个孩子能叫出它的名字，但它既没有看过苹果实物，又没吃过，仅仅因为他知道苹果这个名字就对苹果了解更多吗？而苹果这个名字在不同语言里也是不同的。&lt;/p&gt;
&lt;p&gt;我看到了苹果，如果有人告诉我这是苹果，那么我会更了解它的信息吗？苹果这个名字不是苹果自身的属性，不包含任何苹果的信息，仅仅知道它的名字，我对它的了解并没有变多。如果有人告诉我苹果比较甜，但假如我从来没吃过甜的东西，不知道甜是什么味道，那还是不知道就苹果有关的更多信息。如果我想更了解苹果，只有两种办法，一种是直接接触苹果，比如触摸、品尝；另一种是直接接触过与苹果在某个方面（比如味道）相似的东西，然后得知苹果在那个方面和它类似。&lt;/p&gt;
&lt;p&gt;同样地，道这个字就和苹果一样，名字是不包含信息的，它写成道或者任何其他字都是没有什么区别的。那我们怎么能获得和道有关的更多信息呢？一种是直接接触道，但看起来我们的感官是没办法感受道的；另一种是和我们已经知道的东西类比，但也没有什么东西可供使用。&lt;/p&gt;</content></entry><entry><title>我对《道德经》的理解（第五章 天地不仁）</title><link href="/wo-dui-dao-de-jing-de-li-jie-di-wu-zhang-tian-di-bu-ren.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-dui-dao-de-jing-de-li-jie-di-wu-zhang-tian-di-bu-ren.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;第五章 天地不仁&lt;/p&gt;
&lt;p&gt;天地不仁，以万物为刍狗，圣人不仁，以百姓为刍狗。
天地之间，其犹橐龠乎，虚而不屈，动而愈出。
多闻数穷，不如守中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;天地不仁，以万物为刍狗，圣人不仁，以百姓为刍狗。&lt;/code&gt;天地无所谓仁爱不仁爱，把万物当成祭祀时用草扎成的狗，任凭万物自生自灭；圣人无所谓仁爱不仁爱，把百姓当成祭祀时用草扎成的狗。这里涉及一个博爱的问题，需要仔细探讨一下。&lt;/p&gt;
&lt;p&gt;我们通常认为爱是有选择的，有程度的。比如“你爱他还是爱我？”或者“你更爱他还是更爱我？”但这样的爱存在一个问题，有爱便有不爱。那有没有这样一种爱，对所有东西一视同仁，没有选择没有程度呢？可以说这种爱是博爱，但再仔细一想，当没有不爱时，爱就没有凸显的必要了，比如如果没有黑暗的话，光明就没有意义了，因为没有黑暗来衬托光明，光明就是一种常态，人一直处于光明的地方，他不会理解到什么是黑暗，也就理解不到什么是光明。天地对万物的爱就是这样的，圣人对人民的爱也应该是这样的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;天地之间，其犹橐龠乎，虚而不屈 …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;第五章 天地不仁&lt;/p&gt;
&lt;p&gt;天地不仁，以万物为刍狗，圣人不仁，以百姓为刍狗。
天地之间，其犹橐龠乎，虚而不屈，动而愈出。
多闻数穷，不如守中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;天地不仁，以万物为刍狗，圣人不仁，以百姓为刍狗。&lt;/code&gt;天地无所谓仁爱不仁爱，把万物当成祭祀时用草扎成的狗，任凭万物自生自灭；圣人无所谓仁爱不仁爱，把百姓当成祭祀时用草扎成的狗。这里涉及一个博爱的问题，需要仔细探讨一下。&lt;/p&gt;
&lt;p&gt;我们通常认为爱是有选择的，有程度的。比如“你爱他还是爱我？”或者“你更爱他还是更爱我？”但这样的爱存在一个问题，有爱便有不爱。那有没有这样一种爱，对所有东西一视同仁，没有选择没有程度呢？可以说这种爱是博爱，但再仔细一想，当没有不爱时，爱就没有凸显的必要了，比如如果没有黑暗的话，光明就没有意义了，因为没有黑暗来衬托光明，光明就是一种常态，人一直处于光明的地方，他不会理解到什么是黑暗，也就理解不到什么是光明。天地对万物的爱就是这样的，圣人对人民的爱也应该是这样的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;天地之间，其犹橐龠乎，虚而不屈，动而愈出。多闻数穷，不如守中。&lt;/code&gt;天地不就像一个风箱的皮囊？体内没有东西但不会耗尽自己，越鼓动出来的风就愈多。听闻的东西多了反而能应付的变数少了，不如守住内心的空无。&lt;/p&gt;
&lt;p&gt;《道德经》里的天地或者道并不是很多宗教中人格化的神。它没有个人的感情，没有偏好，对万物是一视同仁的，我们可以拿什么来比喻呢？规律，比如物理定律，对一切物体都是一视同仁的。这样我们就很好理解了。那么圣人应该做的，也是起到一个规律的作用，他告诉人民天地的规律是怎样的，你做什么会得到什么，而不去干涉人民具体做的事情。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;多闻数穷，不如守中。&lt;/code&gt;在通常的版本里是&lt;code&gt;多言数穷，不如守中。&lt;/code&gt;但我感觉后者在语义连贯性上有点问题，就取了前者。把天地比作风箱时，当风箱里的空气全部鼓出时，它体内是空无一物的，它并非是吸收天下精华为己用，而是空气怎么进来就怎么出去。把圣人比作风箱也是一样，而听闻的东西就和空气一样，如果让那些东西占用着自己的空间，不舍得丢弃，自己可用的空间就会越来越少，能够应付的变数也就越来越少。&lt;/p&gt;
&lt;p&gt;作为统治者更是这样的，虽说兼听则明，但一个人能力有限，是不可能尽知全天下的事情的，再努力也只会知道一部分，如果仅根据自己知道的部分对症下药处理，很可能适得其反。而无为之治不需要知道全天下发生的事情，而是维持一个自然而然的秩序。当人民按照自然秩序来做事情时，就没有什么事情是需要干预的。&lt;/p&gt;
&lt;p&gt;举个例子来说，比如一个国家北部干旱粮食少收，而南部雨水充沛粮食富足。统治者不需要知道南北部各自的情况，然后发号施令让南部支援北部，如果这样做的话会发生层出不穷的事情。相反，一方有难八方支援就属于自然秩序的一部分，如果人民确实是在按照自然秩序来做事情，那么南方的人民会自发支援北方人民，而不需要统治者操心。&lt;/p&gt;
&lt;p&gt;那人民怎么才能按照自然秩序做事情呢？这就是教育的问题，这个是需要统治者关心了。有人可能说这不是天方夜谭吗？其实可以这样说，无为而治是结果，而不是方法。前期工作全部到位了，就可以无为而治了。如果天下乱乱糟糟四方争战，还想无为而治肯定是解决不了问题的。&lt;/p&gt;</content></entry><entry><title>我对《道德经》的理解（第一章 众妙之门）</title><link href="/wo-dui-dao-de-jing-de-li-jie-di-yi-zhang-zhong-miao-zhi-men.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-dui-dao-de-jing-de-li-jie-di-yi-zhang-zhong-miao-zhi-men.html</id><summary type="html">&lt;p&gt;说来惭愧，我从来没有从头到尾读完过《道德经》，但仅从读过的一些片段中，我已经体会到了其中的魅力。这次我打算完整地读完《道德经》，并将自己的理解和感悟记录下来。我的理解未必正确，很多人对《道德经》的理解也并不相同，这是很正常并且有益的。&lt;/p&gt;
&lt;p&gt;《道德经》和很多其他经典不同，它并非一种规范或者准则，告诫人们应该做什么，不应该做什么。它告诉人们事情应该是怎样的，以及事情为什么这么做比那么做要好一些。所以，读道德经如果照本宣科，不仔细理解、思考和质疑，收获是很有限的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一章 众妙之门&lt;/p&gt;
&lt;p&gt;道可道，非常道；名可名，非常名。
无名，天地之始；有名，万物之母。
故常无，欲以观其妙；常有，欲以观其徼。
此两者同出而异名，同谓之玄，玄之又玄，众妙之门。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;道可道，非常道；名可名，非常名。&lt;/code&gt;大概是《道德经》中最广为人知的一句 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;说来惭愧，我从来没有从头到尾读完过《道德经》，但仅从读过的一些片段中，我已经体会到了其中的魅力。这次我打算完整地读完《道德经》，并将自己的理解和感悟记录下来。我的理解未必正确，很多人对《道德经》的理解也并不相同，这是很正常并且有益的。&lt;/p&gt;
&lt;p&gt;《道德经》和很多其他经典不同，它并非一种规范或者准则，告诫人们应该做什么，不应该做什么。它告诉人们事情应该是怎样的，以及事情为什么这么做比那么做要好一些。所以，读道德经如果照本宣科，不仔细理解、思考和质疑，收获是很有限的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一章 众妙之门&lt;/p&gt;
&lt;p&gt;道可道，非常道；名可名，非常名。
无名，天地之始；有名，万物之母。
故常无，欲以观其妙；常有，欲以观其徼。
此两者同出而异名，同谓之玄，玄之又玄，众妙之门。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;道可道，非常道；名可名，非常名。&lt;/code&gt;大概是《道德经》中最广为人知的一句，这句话也展示出来它与其他书籍的不同，很值得回味。这句话并非故弄玄虚，含义很明确，能够用语言表达的真理，不是恒长的真理；能够用文字书写的概念，不是恒长的概念。&lt;/p&gt;
&lt;p&gt;这里的“道”，不是我们通常所说的生活中的道理，而是更具普适性的真理。但需要注意的是，《道德经》也是用语言表达的，它也不是恒长的真理，那么《道德经》是不是在开篇第一句就把自己也否定了呢？&lt;/p&gt;
&lt;p&gt;其实&lt;code&gt;道可道，非常道&lt;/code&gt;包含了两层意思，前半句是说真理是可以用语言表达的，后半句是说用语言表达的真理不是恒长的真理，这是递进关系，不能只抓住后半句而忽略了前半句。而《道德经》的内容也确实是真理（但这里并不是说道德经中每句话都是正确的），但不是恒长的真理。那么怎么理解这个恒长呢？&lt;/p&gt;
&lt;p&gt;那么首先我们要明确什么是真理。真理是人们对事实进行归纳总结得到的一种文字抽象。比如今天上午乌云密布，然后下雨了。这是已经发生的事情，是事实。人们长期观察发现乌云密布后就会下雨，然后总结得到：如果乌云密布了，过一会就会下雨。这就是人们从事实得到的真理。但我们很容易可以看出，这个所谓的真理是有问题的，乌云密布过后未必会下雨，所以这个真理是有适用范围的，并不是恒长的真理。&lt;/p&gt;
&lt;p&gt;因为对已经发生的事情进行归纳总结，不会照顾到以后发生的事情，所以这样得到的真理都不是恒长的真理。有人说还有其他得到真理的方式，比如靠推理和证明。如果我可以证明一个真理是对的，那么它是是不是对以后发生的事情也有效，于是符合恒长的真理呢？这里需要注意的事情是，证明是有前提条件的，我们必须有预设为真的前提，才能在这些前提的基础上进行推理和证明，得到结果。而这些前提同样是归纳总结得到的，所以因为前提不靠谱，推理和证明同样得不到恒长的真理。那么有人问了，前提必须是归纳总结得到的吗，1 + 1 = 2 也不是恒长的真理吗？这里需要注意的是，数学中的公理是人们约定为真的前提，它们是数学的根基。说公理正确错误是没有意义的，因为公理必须正确，而这正确是人为规定的，所以公理不是真理，更不是恒长的真理。1 + 1 = 2 是由公理推理得到，自然也不是真理。所以没有恒长的真理，或者说“真理”这个概念本身就有问题，为了表达方便，我们还是继续用这个词。&lt;/p&gt;
&lt;p&gt;然后我们来说&lt;code&gt;名可名，非常名&lt;/code&gt;。这句话的重要性和深刻程度不亚于前半句，但容易被人忽略，这里说的是哲学中比较重要的概念边界问题。对概念人们往往有一种误解，概念是非常明确的，比如“门”这个概念，它非常明确，我们可以很容易判断一个东西是不是门。&lt;/p&gt;
&lt;p&gt;事实并不是这样的，任何概念的边界都是模糊的。拿门来举例。我们很容易判断出花盆不是门，而挂在门框上由木条拼接并且可以转动的东西是门。那么我们把这扇门卸下来，显然它还是门。然后我们从它最上边拆下来一根木条，虽然这个门不像之前那么完整了，但恐怕没有人会说缺了一根木条的门就不是门了。那么我们继续拆，拆到最后只剩下一根木条了，那么还有人说这最后一根木条是门吗？显然这最后一根木条已经不是门了。那么我们在拆一根根木条的过程中，从拆哪根木条起，门就不再是门了呢？&lt;/p&gt;
&lt;p&gt;有人可能会说，这是“门”这个概念不严谨导致的，如果我明确下“门”的概念，比如一扇门如果拆掉了一半就不再是门了，那么我们就知道从拆哪根木条起它是不再是门。这显然是错的，因为每拆掉一根木条，这扇门就变了，那么我们就应该重新计算，如果每根木条是一样大的，那么按照这个约束，最后剩两根木条时还是门。甚至如果最后一根木条比倒数第二条稍大，那么最后一根木条也还是门。那么可不可以继续明确“门”的概念来避免类似问题呢？即使把门的概念写满一本字典，也无法避免所有这类情况，即明确指出任意一扇门在任何一种持续变化中从哪一步开始就不再是门了。&lt;/p&gt;
&lt;p&gt;所以，概念的边界都是模糊的。但我们日常使用时，因为很少接触到概念的边界，所以基本不受影响，但较起真来没有一个概念是明确的。&lt;/p&gt;
&lt;p&gt;那么为什么《道德经》第一句要指出概念的局限性呢？因为如果没有概念，我们一句话也没法说，更没办法用语言来表达真理，《道德经》自然也无法被写出来。概念的不靠谱，也是&lt;code&gt;道可道，非常道&lt;/code&gt;的重要原因之一，我们必须先认识到这一点。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;无名，天地之始；有名，万物之母。&lt;/code&gt;从这句话开始，我们就能够切实感触到语言的局限性了，这句话也非常难解释。有人可能理解成“无”是宇宙的起源。这是有问题的，老子的意思不是说有一个“无”的东西是宇宙的起源。无名是什么？是无法命名的东西，或者说这个东西是不能用概念来表达的，或者说它根本不是东西，但为了要在语言中体现出它，就必须要提到它，所以就必然产生矛盾，这是无奈之举。所以&lt;code&gt;无名，天地之始&lt;/code&gt;的含义不是说宇宙起源于一个叫“无”或者“无名”的东西，也不是说宇宙没有起源，而是说我们是不能用语言来表达宇宙的起源的。&lt;code&gt;有名，万物之母&lt;/code&gt;是说我们可以用语言命名的第一种东西，是万物的起源。&lt;/p&gt;
&lt;p&gt;但这里难理解的地方在于，“天地之始”和“万物之母”有什么区别，它们不一样吗？有人可能理解它们是一样的，但同时即是“有名”又是“无名”，这体现出事物的多面性。不能说这样解释没有道理，但我不这样理解。我认为“天地之始”和“万物之母”是不同的。这两种描述有一个微妙的区别，“天地之始”本身并不是一个概念，它和“无名”差不多，都是因为语言的局限性不得不用的。&lt;code&gt;无名，天地之始&lt;/code&gt;是一种矛盾的说法，最初的时候我们是没办法用语言来描述宇宙的，但我们又不能不说，只要一说矛盾就出来了，大概是这样的意思。&lt;/p&gt;
&lt;p&gt;而&lt;code&gt;有名，万物之母&lt;/code&gt;也存在矛盾，即这个“万物之母”有母亲吗？它的母亲是自己吗？“万物之母”涵盖在万物之中吗？这样看来，说无名是万物之母好像更合理一些。其实不是的，“万物之母”就是一个概念了，而“无名”不是概念，所以“无名”不是“万物之母”，它们是有本质的区别的。“万物之母”属不属于万物，这个就属于概念边界问题了，在回答这个问题时，就和处理之前“门”的问题一样，遇到了模糊边界。不管怎么定义物体，一个物体和它的“母亲”二者的边界都是模糊的，所以万物和“万物之母”之间并没有明确的边界，所以“万物之母”属不属于万物这个问题没办法回答，因为概念不明确，一回答就会产生矛盾。&lt;/p&gt;
&lt;p&gt;同样地，“天地之始”和“万物之母”之间，即“无名”和“有名”之间，也存在类似的模糊边界。它们并不相同，但它们之间也没有明确的边界，就像说一根木条的一端是“无名”，另一端是“有名”，但没有一个明确的边界从什么地方起“无名”就变成“有名”了，只能意会了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;故常无，欲以观其妙；常有，欲以观其徼。&lt;/code&gt;这句话人们也有不同的理解，我的理解是：所以要想真正观察这世界的奇妙，就不能被概念所束缚；但如果要单独观察和分析某种事物，也需要一些概念就它和其他东西区分开来。可以说前者是宏观上的，针对的是一个事物的整体；后者是微观上的，针对的是一个事物的某个部分。在观察理解宇宙这样宏大的东西时，概念是派不上用场的，我们不能把宇宙按照不同概念的定义划分成一块块来分析宇宙整体的奇妙，或者说用还原论来分析理解宇宙这个整体是不可行的。但如果我们只想观察和分析宇宙中的一个苹果，那么我们可以把苹果的概念定义出来，划分边界把不是苹果的东西剔除，就可以单独观察分析苹果了。在这个过程中，概念是有用的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;此两者同出而异名，同谓之玄，玄之又玄，众妙之门。&lt;/code&gt;“无名”和“有名”的起源是一样的，但名字不同（原因我上文也讲过），非常玄妙，是通往所有奥秘的大门。&lt;/p&gt;
&lt;p&gt;总体来说，第一章很难理解，人们的争议也很大，如果实在想不明白也可以先跳过，好在并非《道德经》通篇都这样难理解。&lt;/p&gt;</content></entry><entry><title>我对知乎网的一些看法</title><link href="/wo-dui-zhi-hu-wang-de-yi-xie-kan-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-dui-zhi-hu-wang-de-yi-xie-kan-fa.html</id><summary type="html">&lt;p&gt;接触知乎网有几年了，陆陆续续也写了几百个回答，虽然很少有人看。一直想写写我个人对知乎网的看法，因为我知道碍于我个人的短浅目光，写出的文章必然充满偏激，所有一直没有动笔。今天却突然想写写了，主要原因大概是因为无聊吧。&lt;/p&gt;
&lt;h2&gt;知乎是个什么网站&lt;/h2&gt;
&lt;p&gt;知乎并不是一个问答网站，我想这早已是一个公开的秘密了。它是一个伪装成问答形式的话题作文网站。二者的区别，主要在于谁有权决定哪个答案有用。如果我问了一个问题，那么哪个回答对我最有用，最清楚的人显然是我自己。但在知乎，提问者也和所有其他访问者一样，只有对每一个回答投一票的权利，而没有采纳回答的权利。这就注定高票的回答很可能只是迎合了多数人的口味，却丝毫没有帮上提问者的忙。但知乎和通常的论坛还是有区别的，所有的回答都或远或近地围绕着一个话题展开，很像一群人围绕着一个个话题来写作，所以我说知乎是一个话题作文网站。&lt;/p&gt;
&lt;p&gt;当然这并不是一个问题，知乎是否是问答网站无关紧要，好不好要看内容。但说知乎这个平台好或者不好是没有意义的，因为内容是很多人创作的，知乎将大家的观点以一种不错的形式组织和展示出来，至少可以说是成功的。但这成功的背后，也确实隐藏着很多让人担忧的问题。与其说这些问题是知乎的问题，不如说是社会或者说这个时代中人们的问题。&lt;/p&gt;
&lt;h2&gt;好的方面&lt;/h2&gt;
&lt;p&gt;知乎有很多不错的内容，这是很值得一提的。在网络上遍布着或粗制滥造或千篇一律的内容的时候，知乎上的回答从形式到内容都让人感觉很干净很丰富，这是让人欣喜的。更让人欣慰的是很多无私的贡献者写着一个个精彩的回答，不计回报，甚至不关心有多少人点赞，我是很敬佩这些作者的。对于某些特定领域的问题 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;接触知乎网有几年了，陆陆续续也写了几百个回答，虽然很少有人看。一直想写写我个人对知乎网的看法，因为我知道碍于我个人的短浅目光，写出的文章必然充满偏激，所有一直没有动笔。今天却突然想写写了，主要原因大概是因为无聊吧。&lt;/p&gt;
&lt;h2&gt;知乎是个什么网站&lt;/h2&gt;
&lt;p&gt;知乎并不是一个问答网站，我想这早已是一个公开的秘密了。它是一个伪装成问答形式的话题作文网站。二者的区别，主要在于谁有权决定哪个答案有用。如果我问了一个问题，那么哪个回答对我最有用，最清楚的人显然是我自己。但在知乎，提问者也和所有其他访问者一样，只有对每一个回答投一票的权利，而没有采纳回答的权利。这就注定高票的回答很可能只是迎合了多数人的口味，却丝毫没有帮上提问者的忙。但知乎和通常的论坛还是有区别的，所有的回答都或远或近地围绕着一个话题展开，很像一群人围绕着一个个话题来写作，所以我说知乎是一个话题作文网站。&lt;/p&gt;
&lt;p&gt;当然这并不是一个问题，知乎是否是问答网站无关紧要，好不好要看内容。但说知乎这个平台好或者不好是没有意义的，因为内容是很多人创作的，知乎将大家的观点以一种不错的形式组织和展示出来，至少可以说是成功的。但这成功的背后，也确实隐藏着很多让人担忧的问题。与其说这些问题是知乎的问题，不如说是社会或者说这个时代中人们的问题。&lt;/p&gt;
&lt;h2&gt;好的方面&lt;/h2&gt;
&lt;p&gt;知乎有很多不错的内容，这是很值得一提的。在网络上遍布着或粗制滥造或千篇一律的内容的时候，知乎上的回答从形式到内容都让人感觉很干净很丰富，这是让人欣喜的。更让人欣慰的是很多无私的贡献者写着一个个精彩的回答，不计回报，甚至不关心有多少人点赞，我是很敬佩这些作者的。对于某些特定领域的问题，知乎上回答的质量也是显著高于多数其他平台的，这是大家共同努力的成果。从某种角度说，知乎确实是纷乱的（国内）互联网环境中的一块净土。&lt;/p&gt;
&lt;p&gt;当然如果我只是想夸夸知乎，就完全没有必要写一篇文章了。知乎看似灿烂的光芒隐藏不了层层值得反思的问题，这些问题也的确比那许许多多“干货”更应该引人注目。&lt;/p&gt;
&lt;h2&gt;还存在多少真情&lt;/h2&gt;
&lt;p&gt;本来我想将这一节的小标题写成“还有多少人在讲真话”，但想了想感觉有些太偏激，就改成了“还存在多少真情”。知乎的回答有一个特点，就是很少有人在回答中吐露出真情。我并不是说回答中缺少感情，因为的确有很多回答很让人感动，但这并不是我所指的真情，不然我会对小说更感兴趣。我对文字有一种独特的敏感，虽然我不可能识别出一个故事是真实的还是编造的，但我可以轻易识别出一段文字中是否蕴含着发自内心的真实感情。知乎的回答中，有这样真情的回答极少，而且那些极少的中，多数也是很少有人点赞的回答。当然在回答学术问题时，这样的真情似乎是没有必要的，但和情感、人生、社会、生活等很多和日常生活息息相关话题相关的回答就不是这样了。&lt;/p&gt;
&lt;p&gt;夸张点说，除了确定领域的偏学术类或者体验类等问题外，知乎上的回答一塌糊涂。就像一个 8 岁的孩子站在讲台，对着台下几排 4 岁的孩子高谈阔论怎样才能过上成功的一生一样，言语间透露出成功者的光彩，仔细回味，感受到的却是满满的幼稚。是啊，你如何指望未经多少世事的毛头小子评价那些比他们年长几十岁的人呢，还要带上理性二字？可是偏偏有很多这样的人，今天评价个名人，明天评价个电影，后天再评价个公众事件。评价到最后恐怕自己也有无所不知的幻觉了。聪明的人是不会轻易评价外物的，所以我显然不够聪明，还是忍不住来评价一下知乎。&lt;/p&gt;
&lt;p&gt;评价任何事物的难点在于设身处地，作为一个旁观者，谁都能高谈阔论一番。但能真正做到设身处地感受到当事人的欢喜、悲伤、愤恨、无奈等复杂情感的人却少之又少。而真正感受到后，却常常会摇头叹息，而不想多说什么了。一是很多情况没必要说，洋洋洒洒的几段话除了将自己的情绪发泄出来外，并不能真正解决问题；二是谁又能料到此番话一出，又会引起多少波澜，兴许帮助了一些人，反而害了更多人。&lt;/p&gt;
&lt;p&gt;答案的言语中并没有蕴含着真情，但一个个人物与事件，就像一面面镜子，将回答者的内心世界反映得真真切切。有些时候，我还是希望回答者都是所谓的精英，虽然自以为是一些，但也只能代表少数人而已。然而可怕的是，真正的精英反而少之又少，多数人恰好是再平凡不过的普通人，知乎在某种程度的确可以反映出这一代人的特点，让人痛心。&lt;/p&gt;
&lt;p&gt;如何才能对自己诚实，是这个时代里人们的共同问题。如果不能做到对自己诚实，其他的无从谈起。看着众人将真实的自己层层包裹，捧出了一个伪造得看似很精美实则千疮百孔的模特，自以为其他人都不了解自己，实际上真实的自己在言语中暴露无遗而不自知，怎么能让人不无奈。看着很多人针对如何拯救世界的话题夸夸其谈，我只想说第一步是做到对自己诚实。&lt;/p&gt;
&lt;h2&gt;什么才是正确&lt;/h2&gt;
&lt;p&gt;知乎上有一类经典问题是“如何正确地 XX”，这类问题又被称之为知乎体的一种。很多人不明就里地将“正确”二字当时髦词语使用，却很少反思其中隐含着什么。&lt;/p&gt;
&lt;p&gt;何为正确，何为错误？多数情况，只有立场确定后才有意义，立场不确定，正确错误毫无意义。但多数情况，不同立场的人们针对正确和错误的问题讨论得乐此不疲，甚至恶言相向，却没有注意到立场不同才是根源问题。这又回到了设身处地上来，你没有别人的经历，是很难理解他的立场的。你认为自己是在换位思考，实际却只是在望远镜里瞥了对方一眼。更可怕的是很多人认为有必要将大家的立场统一，以便可以无障碍地讨论问题。殊不知这如同杀鸡取卵，为了解决一个问题，却想付出了远比这更高昂的代价。&lt;/p&gt;
&lt;h2&gt;无所不在的优越感&lt;/h2&gt;
&lt;p&gt;和知乎紧密相连的一个词是优越感，这也是最容易遭人诟病的地方。知乎回答中的优越感是出了名的，也正是这反映出无所不在的自卑。这种自卑根深蒂固地存在着，可能需要很多代人的努力才能将其稀释殆尽。但这种发泄也是必然的，所以我不认为这种优越感是不好的，也不倡导大家应该学会谦虚。这是一个必经的阶段，什么时候刻意体现出优越感不再是一个普遍需求后，自卑自然也就随之而去了，这是强求不来的。当然这不会发生在现在，在相当长的一段时间，我们都应该宽容这种优越感。&lt;/p&gt;
&lt;h2&gt;展望&lt;/h2&gt;
&lt;p&gt;人们可以在类似知乎这样的平台上各抒己见，是一件好事情。所暴露出的问题并非无中生有，而是从深处浮现出来。所以总体上我还是乐观的，问题暴露出来就总会解决的办法，而且新一代人的问题看起来比上一代人的要少一些，这是一个不错的趋势。&lt;/p&gt;</content></entry><entry><title>我关于树莓派性能低的看法</title><link href="/wo-guan-yu-shu-mei-pai-xing-neng-di-de-kan-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-guan-yu-shu-mei-pai-xing-neng-di-de-kan-fa.html</id><summary type="html">&lt;p&gt;树莓派被广为诟病的一个地方就是性能低（这里以树莓派 3b 为准，更早产品的性能确实不能满足很多场景的需求），性能包括 CPU、GPU、网络传输、USB 传输、SD 卡读写等诸多方面。很多人希望有一款高性能的树莓派，价格贵也没关系。我开始时也是这么想的，到处找和树莓派差不多但性能更好的设备，但找来找去没发现更满意的，有的接口太少，有的软件环境太糟糕，有的资料太少没有成熟的社区，各有各的问题。但我慢慢发现自己陷入到一个性能误区里。我需要更高的性能来做什么呢？如果不把需求明确了，那就很难找到能让自己满意的设备。&lt;/p&gt;
&lt;p&gt;于是我开始想树莓派有哪些优势，适合使用者哪些场景。然后我得出了一个结论，如果认为树莓派性能太差，那绝大多数情况都是选型时出了明显的问题。&lt;/p&gt;
&lt;p&gt;那些树莓派不适合的场景以及更优选择：&lt;/p&gt;
&lt;p&gt;1、用来当路由器&lt;/p&gt;
&lt;p&gt;不适原因：CPU/GPU、接口、软件平台资源浪费，网络性能不足。
更优选择：同价位（或者更便宜）的路由器。&lt;/p&gt;
&lt;p&gt;2、NAS&lt;/p&gt;
&lt;p&gt;不适原因：接口、软件平台资源浪费，网络性能 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;树莓派被广为诟病的一个地方就是性能低（这里以树莓派 3b 为准，更早产品的性能确实不能满足很多场景的需求），性能包括 CPU、GPU、网络传输、USB 传输、SD 卡读写等诸多方面。很多人希望有一款高性能的树莓派，价格贵也没关系。我开始时也是这么想的，到处找和树莓派差不多但性能更好的设备，但找来找去没发现更满意的，有的接口太少，有的软件环境太糟糕，有的资料太少没有成熟的社区，各有各的问题。但我慢慢发现自己陷入到一个性能误区里。我需要更高的性能来做什么呢？如果不把需求明确了，那就很难找到能让自己满意的设备。&lt;/p&gt;
&lt;p&gt;于是我开始想树莓派有哪些优势，适合使用者哪些场景。然后我得出了一个结论，如果认为树莓派性能太差，那绝大多数情况都是选型时出了明显的问题。&lt;/p&gt;
&lt;p&gt;那些树莓派不适合的场景以及更优选择：&lt;/p&gt;
&lt;p&gt;1、用来当路由器&lt;/p&gt;
&lt;p&gt;不适原因：CPU/GPU、接口、软件平台资源浪费，网络性能不足。
更优选择：同价位（或者更便宜）的路由器。&lt;/p&gt;
&lt;p&gt;2、NAS&lt;/p&gt;
&lt;p&gt;不适原因：接口、软件平台资源浪费，网络性能、USB 传输性能不足，并且预算太低。
更优选择：专用 NAS、x86 平台的台式机（可以选择二手的性价比更高，可以选择小机箱更省空间）、中高端家用路由器（如果要求不高）。&lt;/p&gt;
&lt;p&gt;3、接电视（或者显示器）看视频&lt;/p&gt;
&lt;p&gt;不适原因：接口、软件平台资源浪费，网络性能、GPU 性能、USB 传输性能不足。
更优选择：同价位的安卓盒子、稍贵的电脑棒、小机箱主机（如果要求较高）。&lt;/p&gt;
&lt;p&gt;4、学习 Linux&lt;/p&gt;
&lt;p&gt;不适原因：整体浪费，并且太麻烦。
更优选择：在电脑里运行 Linux 虚拟机，或者安装 Linux 实体机。&lt;/p&gt;
&lt;p&gt;5、跑消耗性能的软件&lt;/p&gt;
&lt;p&gt;不适原因：接口、软件平台资源浪费，各种性能不足，对口软件资源不足，太麻烦，预算太低。
更优选择：根据自己的应用场景，选择对应价位的 x86 台式机（可以选择二手的节省预算，可以选择小机箱节省空间）。&lt;/p&gt;
&lt;p&gt;6、接外设后替代电脑或者平板&lt;/p&gt;
&lt;p&gt;不适原因：各种性能不足，接口浪费，太麻烦，预算太低。
更优选择：根据实际情况选择对应价位的笔记本、台式机、平板电脑等。&lt;/p&gt;
&lt;p&gt;7、作为游戏机（玩复古的模拟器游戏除外）&lt;/p&gt;
&lt;p&gt;不适原因：游戏少，软件平台资源浪费，各种性能不足，接口浪费，预算太低。
更优选择：根据实际情况选择对应价位的游戏机或者台式机。&lt;/p&gt;
&lt;p&gt;8、依赖树莓派的接口或者平台，但同时需要跑消耗性能的软件&lt;/p&gt;
&lt;p&gt;不适原因：各种性能不足，预算太低。
更优选择：树莓派 + 对应价位的 x86 台式机（可以选择二手的节省预算，可以选择小机箱节省空间）。树莓派用来完成硬件操控、数据收集、数据简单处理、将数据通过网络传输给台式机。需要消耗性能的软件在台式机运行。&lt;/p&gt;
&lt;p&gt;9、看起来树莓派可以满足需求，但性能还差一些&lt;/p&gt;
&lt;p&gt;不适原因：性能不足，预算太低。
更优选择：可以同 8。也可以选择更贵的类似树莓派的的设备（比如微软的 UP board 系列），但平台生态环境并不是和树莓派一致（虽然硬件接口基本兼容），并且性价比不高（拿 UP board 来说，它的处理器是 Atom Z8350，价格要 1000 出头。但这个价位的 Z8350 电脑棒只有 500 多，电脑棒 + 树莓派 才 700 多，要比 UP board 性价比更高。而且如果配合使用，并没必要使用性能并不高的 Z8350），需要根据实际情况选择。&lt;/p&gt;
&lt;p&gt;10、用于组成批量出售的商业设备产品&lt;/p&gt;
&lt;p&gt;不适原因：成本太高，芯片不能单独购买，硬件资料不够开放。
更优选择：根据实际情况选择其他可以单独购买、有足够资料的硬件。&lt;/p&gt;
&lt;p&gt;总结起来分两种情况：&lt;/p&gt;
&lt;p&gt;1、不需要树莓派独有的功能，那么不需要考虑使用树莓派。
2、需要树莓派独有的功能，但性能太低，可以考虑树莓派加其他设备配合使用。&lt;/p&gt;
&lt;p&gt;有人可能会说，用一台设备解决所有需求，要比用两台设备更节省预算，因为资源利用率更高。但实际情况是恰好相反的。如果你只有一个需求，可能很容易找到一个 150 元的设备可以满足。如果你有另一个需求，也可能很容易找到另一个 150 元的设备可以满足。但如果你想要找到一台设备同时满足这两个需求，那可能至少要花 500 元。如果你又有第三个需求，同样地，单独满足这个需求的设备可能只需要 150 元，但同时满足这三个需求的设备，可能至少需要 1000。如果你有第四个需求呢？那么很可能你没办法找到同时满足那四个需求的设备了，因为这些需求很可能是互斥的（比如性能高和功耗低），花多少钱也没处买。&lt;/p&gt;
&lt;p&gt;所以把需求拆开单独找可以满足的设备，然后配合使用，往往可以节省预算。&lt;/p&gt;
&lt;p&gt;那么树莓派适用怎样的场景呢？&lt;/p&gt;
&lt;p&gt;1、作为一个低能耗的 Linux 家用服务器，用于运行硬件性能可以满足的软件，提供各种服务（比如网络相关、文件相关、视频音频相关）。&lt;/p&gt;
&lt;p&gt;2、连接硬件用来做数据采集、监控、分析、发布等事情。&lt;/p&gt;
&lt;p&gt;3、作为类似小车、飞行器、机器人、智能家居等智能设备的控制中心。&lt;/p&gt;
&lt;p&gt;4、作为一个电脑的轻量级替代物，用于一些简单的场景，或者用来作软件开发启蒙，适合预算不足以买电脑的用户（主要是孩子）。这个是树莓派的最初目的。&lt;/p&gt;
&lt;p&gt;5、用于大中小学的教育。&lt;/p&gt;
&lt;p&gt;6、用于搭建原型产品。&lt;/p&gt;
&lt;p&gt;7、单纯地用来玩（折腾）而不是使用。&lt;/p&gt;
&lt;p&gt;可以看到，在这些场景中，树莓派的性能完全不成问题。不把全部需求集中在一个设备上，选择的范围就很广了。&lt;/p&gt;</content></entry><entry><title>我和 Linux 的故事</title><link href="/wo-he-linux-de-gu-shi.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-he-linux-de-gu-shi.html</id><summary type="html">&lt;p&gt;我最早接触Linux是2006年，那时还是高中。当时我对Windows下的破解技术很感兴趣，那个时候看雪论坛很火，里边有很多破解教程，我就经常下载到电子词典里看。其中有一本书破解方面的书第一部分讲的是在Linux下破解，比如将scanf的缓冲区溢出漏洞，漏洞利用程序是用Perl写的（而Windows下破解基本都用GUI的工具，比如Ollydbg，我电子词典只能看文本文件，没有截图看起来很费事），后边还有很多ShellCode相关内容。我就去查了下Linux相关内容，虽然不是很感兴趣，但也感觉比较新鲜。&lt;/p&gt;
&lt;p&gt;后来，我们教室安装了投影用的电脑，因为我对电脑比较熟悉，钥匙在我这。于是我经常没事就折腾，突然就想起了之前听说的Linux。第一次安装使用的发行版是很多人没听说过的ThizLinux，至于为什么是ThizLinux，原因很简单。当时我去电脑店问有没有Linux光盘，老板找了4张光盘出来，其中3张是Ret Hat的3张，另1张是ThizLinux。我一想反正就是装来玩的，1张比3张便宜，就它了吧（没从网上下载镜像的原因是当时u盘还没有流行，而且价钱很贵，我高三时买了个2G的u盘花了将近200块，而当时我只有一个128M的mp3可以用来存文件）。因为当时没有自己的电脑，但我们教室用了投影的电脑，我去网吧下了一个免安装版（因为电脑有还原卡，每次都安装很麻烦，如果安装后需要重启更没法用）的VMWare，装上了这个ThizLinux。&lt;/p&gt;
&lt;p&gt;但教室的电脑毕竟不方便，尤其是不能上网，简单体验一下各个预装软件也就作罢。印象比较深的是桌面环境是KDE …&lt;/p&gt;</summary><content type="html">&lt;p&gt;我最早接触Linux是2006年，那时还是高中。当时我对Windows下的破解技术很感兴趣，那个时候看雪论坛很火，里边有很多破解教程，我就经常下载到电子词典里看。其中有一本书破解方面的书第一部分讲的是在Linux下破解，比如将scanf的缓冲区溢出漏洞，漏洞利用程序是用Perl写的（而Windows下破解基本都用GUI的工具，比如Ollydbg，我电子词典只能看文本文件，没有截图看起来很费事），后边还有很多ShellCode相关内容。我就去查了下Linux相关内容，虽然不是很感兴趣，但也感觉比较新鲜。&lt;/p&gt;
&lt;p&gt;后来，我们教室安装了投影用的电脑，因为我对电脑比较熟悉，钥匙在我这。于是我经常没事就折腾，突然就想起了之前听说的Linux。第一次安装使用的发行版是很多人没听说过的ThizLinux，至于为什么是ThizLinux，原因很简单。当时我去电脑店问有没有Linux光盘，老板找了4张光盘出来，其中3张是Ret Hat的3张，另1张是ThizLinux。我一想反正就是装来玩的，1张比3张便宜，就它了吧（没从网上下载镜像的原因是当时u盘还没有流行，而且价钱很贵，我高三时买了个2G的u盘花了将近200块，而当时我只有一个128M的mp3可以用来存文件）。因为当时没有自己的电脑，但我们教室用了投影的电脑，我去网吧下了一个免安装版（因为电脑有还原卡，每次都安装很麻烦，如果安装后需要重启更没法用）的VMWare，装上了这个ThizLinux。&lt;/p&gt;
&lt;p&gt;但教室的电脑毕竟不方便，尤其是不能上网，简单体验一下各个预装软件也就作罢。印象比较深的是桌面环境是KDE（当时没有概念，后来回想的），鼠标点开软件后软件的图标在鼠标旁边一跳一跳的，里边有个叫Kate的文本编辑器可以选择很多编程语言高亮方案，其他的基本都记不得了。后来我也尝试安装了Ubuntu 7.10，好像是在网吧电脑的虚拟机，细节基本完全忘记了。直到高中毕业我有了自己的笔记本，买回来几天就装上了Ubuntu 8.04（预装的Windows XP还保留），自然那时是08年，Ubuntu已经比较火了，同时比较有名的桌面发行版就是Fedora。家里也没有网，所有十分不方便，我曾经去网吧把源里的deb包下到u盘里回来安装，但经常因为少下了依赖而安装不上，后来索性不折腾了。&lt;/p&gt;
&lt;p&gt;悲剧的是大一不让带电脑，我上学期就没有带。但悲剧地发现有同学带来电脑也没人管……那时我们专业有一个免费机房，但上不了网，我们周末经常去那玩（还有个收费机房，应该是一块钱一小时，比较大，印象最深的就是病毒猖狂，基本随便找个机器插上u盘，都无一幸免）。系统是Windows 2000的，我就想着弄个虚拟机装Linux。但试了几个都用不了，费了不少事找到了一个支持Windows 2000的Virtual PC。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当时的记录，下同
20081109
找到了
终于找到W2K下能用的V PC了,我都快放弃了.更让我激动的是找到一带gnu编译程序包的LINUX LIVE CD ISO,这样工具就全了,也不用再忍受计算中心病毒之苦了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有次我下了个Puppy Linux，然后用虚拟机体验了下，感觉这个发行版好小，里边工具却很多，挨个点开玩了玩。有次在大街上还看到有人卖Open Solaris的光盘，果断买了一张，结果发现真的可以启动起来，界面和Linux相差不大。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;20081107
光盘引导
学校那计算中心,我啥也不说了.今天却发现一个好办法,用光盘引导.虽然是solaris的,和linux的看上去差不多.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当时我还是对Windows更了解的，无论是使用上还是编程方面。但当时我作了一个决定，把平台全部切换的Linux，原因大概有这样几个吧：机房里的Windows系统病毒太猖狂，用起来非常难受；教材里C语言还使用VC 6.0开发编译，用起来不方便；机房里电脑里的软件都是盗版的，对盗版软件很反感等等。当时写了这样一篇文章（现在看来有点想笑）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;20081228
不得不考虑&lt;/p&gt;
&lt;p&gt;也许对于一般用户,用什么系统和软件并不十分重要,然而对于另一些人,则至关重要,因为这与发展方向密切相关.
想着最近发生的事,太多的要考虑,以至于我不知道从何谈起.&lt;/p&gt;
&lt;p&gt;还是熟悉的XP,不同的感觉,八年的驰骋,让许多人为之震撼,然而它又能撑多久?
技术的落后无法挽救,越来越大的阻力终会让现在只靠惯性运动的它.VISTA无法接任,唯有不远将来的WIN7.也许会吧,但真的很乐观吗?我们到时候还会很自然地说“走,上网下个深度的WIN7”吗?即使可以,我们还会这么舒服吗.雨林木风宣布止步了,其他的还会远吗?
更重要的是,学WIN底层和平台编程也许会很糟糕,会有变化吧.能不能用起呢?......
种种原因,我作以下决定:
将开发平台全部转至linux,放弃开发和学习基于WIN API的软件和技术.放弃对WINDOW下平台相关破解及逆向等技术的学习研究.放弃对其下病毒作技术性研究.放弃深入研究基于COM的脚本技术.拒绝研究.net平台,拒绝研究其内核和驱动.拒绝研究WINCE WM 平台相关技术.
上述决定很痛苦,因为我曾投入相当多精力,而今却要挥手离去.
我决定从寒假回校起以linux作为开发平台和主应用平台,用WIN作辅应用平台,并争取摆脱WIN.不再使用msoffice vc iis ie 等软件.只给WIN分30G以下大小的分区.
以后界面程序以QT库应用为主......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以及这篇：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;20090206
盗版的反思&lt;/p&gt;
&lt;p&gt;盗版，忘记了最初接触是什么时候了，印象中有一个小插曲。在看一些台湾教程时，常看作者提到过“D版光盘“，当时不太理解，还以为光盘还分ABCD四等呢，后来才知道其实就是“盗版光盘“。也许是因为今年发生挺多和盗版相关的事（从番茄花园，到XP黑屏，到微软产品降价……）吧，应该人们对这个词已经不陌生了，然而仅是知道这个词是不行的。
　　打开你的电脑，或者到网吧、机房或是一些小公司看看，看看什么是盗版吧。拿我几个月前的电脑来说吧（因为那时的比现在的更有特点）。打开电脑，Windows xp系统就启动了，这个系统也有点来头。深度技术Ghost xp6.5，应该是我高三下学期在电脑小店买的，安过多少次我也记不清了，而且每次安后我都要进行一系列麻烦的设置，直到我没有看着不顺眼的地方。里边有我常用的软件（其实有些很少用，但看起来舒服），如Office2003，Foxit Reader，Autocad 2004，Photoshop6.0，VC++6.0，WinRar3.71，3dmax8.0，Mathematica5，VMwareWorkstation6.0，玩转手机，一直感觉挺不错的，虽然我知道这些都是盗版的，而且其价格不菲。我也习惯上网下载软件时找“……破解版”“……特别版”之类的，而且因为有几个喜欢的软件一直找不到破解版的而十分郁闷。我想有许多人都也都是这么想吧，会认为怎么会有人傻到花几千甚至几万去买一个软件回来。但当真冷静想这些时，不由得有些怕了。
　　我写过软件，当然知道一个能让crackers为了破解它而不择手段的软件是多么艰辛；我也学过破解软件，当然明白破解一个用商业加密技术保护的软件有多么困难。然而他们都没有错，一个为了谋生，为了计算机相关领域的发展；另一个则更为高尚，他们为了软件的普及，付出那么多却很少在乎个人利益（如果不信去网上找一找相关资料吧），如果没有他们，中国恐怕二十年之后电脑也不会这样普及（虽然硬件越来越便宜，但软件的价格成倍上涨，想想吧）。然而结果呢，我们看上去是占了便宜，而实质上则是主动放弃了一次又一次机会，使国内相关技术水平被落得越来越远。
　　前些日子在学校时，我打算下载一个XPsp3系统，但我在gougou翻了几十页也没找到一个能下载的连接，这不禁让我心为之一震，当然我知道如果想下一定可以找到，但我也知道迟早有一天会找不到的。系统这样，软件又有什么区别，到那一天我们怎么办？尤其是一个学软件工程的人，到时候连操作系统都买不起，自己写一个吗，笑话。
　　再次打开VC++6.0感觉更加别扭了。如果不是书上用的是它，我无论如何都不会去用，我宁可用EditPlus +  gcc，而那个EditPlus也是盗版的，我无语。我不得不承认在Windows下，离开盗版的日子是没法过的。况且连系统都已经是盗版的了，又何必在乎那几个软件呢？
　　临回来时，我下了一个Window7测试版和一个Ubunbu衍生版，想试一试哪一个更好用，因为我还没有作好离开Windows的准备，同时也想体验新技术了。但一件事使我放弃了尝试Win7的打算。电脑又感染病毒了，一塌糊涂，手边也没有什么东西，害得我丢了许多东西。我受够Win下的病毒了，仅一个学期我的U盘就被感染不下几十回。我不怕病毒，尤其是那些一看就明白是怎么回事的病毒，我只是不想把时间和精力扔到那没有用的东西上。当然Linux下也会有，但至少我用不着提心掉胆地动不动就怀疑是不是又感染病毒了。
　　所以对我来说没有什么其它更好的选择了，我不想再用看着就别扭的Windows了，也不想弄其下独有的技术了，包括我我高中费尽心思学的Win32编程和平台软件破解，还有基于COM对象的脚本，等等。我突然发现离开了Windows，我几乎一无所有。但也许这样会轻松些。
　　但种种原因，我还离不开Windows，离不开盗版。mtk手机同步工具肯定是没有Linux版的了，U盘量产工具也一样吧，下学期还学什么3dmax，我都快疯了，放着专业课不学，学这种不可能用到的东西，还有我现在也不知道怎么能让它识别出摄像头，……。
　　慢慢的，我发现许多时候不用盗版的东西也能轻松地解决问题，我也习惯了这种方式。感觉一些事情挺好笑的，也挺正常的，分怎么看吧。前几天去书店看一看，还是那些书，盗版软件不可能不流行，或者说如果一个商业软件如果不被破解就永远不会流行起来。突然想来老师的那句话，我发现有人买盗版的OS/2，回去告诉他们，他们兴奋地蹦起来，OS/2终于有盗版的了！前几天我真的有兴看到os/2的界面了，的确，是图形界面的鼻祖。
　　不管怎样，感觉中国的软件事业的前景还是很堪忧的。一个几乎完全模仿别人的软件也会成为“国人的骄傲”，获得各种奖项，我无语。开源的东西到国内多半就变成商业的了，我也没什么可说的了。
　　如果有一天盗版会从中国消失，我想……，我应该不用想了，至少我在有生之年是看不到了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直到大一下学期，我终于有了自己的能上网的电脑了。立即将原来的Ubuntu 8.04改成Ubuntu 8.10，但当时用的是一个Ubuntu衍生版，貌似是以C开头的一个名字，镜像2G多，黑色调，源还是Ubuntu的。然后平时就使用Ubuntu，很少用Windows（忘了从什么时候开始把Windows删掉的）。当时的截图很难找到了，找了半天翻出来一个能看清的：
&lt;img alt="image" src="/images/017.jpg"&gt;
这张是当时用Dropbox时写了篇文章（ http://osily.lofter.com/post/161c56_3dfe4a  ）截的，鹦鹉螺文件浏览器。这个绿色的主题我用了一年以上，当时还自己将一些图标换成更好看的，现在看还是有些感情的。&lt;/p&gt;
&lt;p&gt;然后想起了输入法。Ubuntu预装的是SCIM，感觉不大好用。当时比较流行的是Fcitx，但感觉那个输入法状态条很丑（细细的，颜色惨白，最左边有一只小企鹅。几年之后这个状态栏变好看了。）有次突然发现一个新的输入法，叫yong（小小输入法）。装上后十分吃惊，又好用又美观，论坛里还有很多漂亮的皮肤。&lt;/p&gt;
&lt;p&gt;当时写的文章，开始：&lt;/p&gt;
&lt;p&gt;20091019
小小输入法
终于可以换个输入法了，fcitx用了一年多，不是因为它有多好，而是找不到比它更好的了。之前试了三四个输入法，不是太慢太大就是功能不全，有的兼容性还有问题……
昨天又重试了一下小小输入法，感觉有不少长进，终于可以换上了。感觉除了模糊拼音它没有，我再不需要别的功能了，另外平时很少用拼音，有没有也无所谓了。
首先界面上，这是我见得最好的，虽然界面并不能作为选择的第一标准，但常用的输入法，界面自然比其他软件重要的多，在这一点我实在无法忍受fcitx。它可以换皮肤，这在linux下似乎绝无仅有，因为这，我特意自己做了几个皮肤，但遇到点问题直到刚才才基本解决。
在我看来比较好的特点：
码表txt格式，易于修改。
用户词汇和主词库分开，易于备份。（fcitx就是合并的，很麻烦）
可以很容易地外挂词库，而且词库里只写词就可以了，而不用写码。
安装方便，还可以外挂。（当初安fcitx真是费劲，乱码问题都折腾我好久）
界面不错，设置方便。
体积很小，速度也可以。
跨平台。（虽然Windows下我想会用搜狗五笔……）
更新较快。（fcitx几年了也没把全角字符问题解决了，无语……）
论坛比较活跃。
这些对我来说就足够了，没什么太高要求了……
贴几个图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/018.jpg"&gt;
（有点像“绿色软件”，安装后只是把主程序链接到/usr/bin里，一些词库会拷到家目录。）
&lt;img alt="image" src="/images/019.jpg"&gt;
（这个功能可能需要完善一些……）&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/020.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/021.jpg"&gt;
&lt;img alt="image" src="/images/022.jpg"&gt;
前两个是自己从搜狗的改的。搜狗的皮肤真不少，如果能写个程序自动转换就好了……
状态条在这个主题下显示不正常，也不习惯用，就让它隐藏了，另外这让做皮肤轻松了许多。&lt;/p&gt;
&lt;p&gt;当时写的文章，结束&lt;/p&gt;
&lt;p&gt;还写了一个搜狗输入法皮肤转小小输入法皮肤的工具（http://osily.lofter.com/post/161c56_3dfe2c）。&lt;/p&gt;
&lt;p&gt;当时喜欢逛Ubuntu中文，有个子版块是Arch，开始时没注意，后来有次进去看了下，发现经常有人从Ubuntu转到Archlinux的。当时学校事情也比较少，平时也没事情做，就也尝试下Archlinux，那时是09年。先在Virtualbox安装，比较顺利，当时写的文章（博客周转了好几个地方，居然还能找到）：&lt;/p&gt;
&lt;p&gt;当时的文章，开始：&lt;/p&gt;
&lt;p&gt;20100108
安装archlinux
按这系列文章（dante.im/archlinux-on-virtualbox-note-2-setup）安装，果然十分顺利，虽然中间也遇到一些文章，还是比较方便地解决了。安gnome时下载了300M+的东西，又是在virtualbox里，用了不少时间，又因为中间有一次虚拟机出错，重下了一回，源不好用，中途换源，最后总算看到桌面了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/023.jpg"&gt;
&lt;img alt="image" src="/images/024.jpg"&gt;
尤其是这回分区和网络都没有出任何问题，配置文件也没有太大的改动，总体感觉并不难。总结起来，大致步骤：
1.启动后，以root登陆，运行/arch/setup运行安装程序：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/025.jpg"&gt;
2.进入1，选择cd，2可以先不管，3分区格式化，4选择包，5安装包，6设置系统，7安装grub，就完了。但也不像ubuntu那么容易，3就不好弄，可以看下http://antimalicious.blogspot.com/2009/04/archlinux.html
习惯就行了，也不算很难。
再就是7了，现在可以不设置太多，设置点基本信息，再就是设置下源，当然这些也可以在安装后在设置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/026.jpg"&gt;
3.重启后以root登陆，不出意外就可以继续了，如果以lan联网不用设置就能上网，不然就要设置了。然后更新：
pacman –Sy 让pacman&lt;strong&gt;将本地的包数据库与远程的仓库进行同步&lt;/strong&gt;。
pacman -Su 是&lt;strong&gt;对系统自带的包进行更新。&lt;/strong&gt;
&lt;strong&gt;pacman -S xorg #提示没有这个包，但提示一些，安装就行&lt;/strong&gt;
&lt;strong&gt;pacman -S hal dbus&lt;/strong&gt;
&lt;strong&gt;/etc/rc.d/hal start&lt;/strong&gt;
&lt;strong&gt;startx&lt;/strong&gt;
&lt;strong&gt;这就进入了一个图形环境，非常简陋，有三个xterm，一个时钟如果鼠标键盘能用就没问题了。&lt;/strong&gt;
&lt;strong&gt;pacman -S gdm&lt;/strong&gt;
&lt;strong&gt;pacman -S gnome&lt;/strong&gt;
&lt;strong&gt;然后改/etc/rc.conf&lt;/strong&gt;
DAEMONS=(syslog-ng network netfs crond hal dbus gdm)
&lt;strong&gt;重启后如果正常就进入gdm里，登陆（以非root，之前要创建）就能进入gnome。&lt;/strong&gt;
&lt;strong&gt;再安几个软件试试，有的软件找不到，不知道是包名称错了，还是源没设置明白。但安装的包版本都比较高。&lt;/strong&gt;
&lt;strong&gt;因为没安装额外的包，感觉有点别扭，shell的补全奇差，但估计能设置好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当时的文章，结束。&lt;/p&gt;
&lt;p&gt;但在实体机安装就比较痛苦的，主要是显卡驱动非常麻烦，我的笔记本显卡是ati x2300，费了不少劲才把X启起来并把分辨率弄对，但用起来还是比Ubuntu卡（当时流行跑glxgears，结果一直比之前在Ubuntu的低）。安装折腾了我将近两天，然后发现使用也比Ubuntu麻烦，比如无线网卡驱动和蓝牙驱动折腾了我好几回，显卡驱动性能一直感觉有问题。装的是64位系统，但当时Archlinux是没有multilib的，如果想使用32位软件需要chroot等方法，十分不方便，而有几个软件是没有64位的。其他的小问题就想不起来了。但慢慢也习惯了，主要是感觉系统轻巧了不少。当时用Ubuntu时经常感觉系统预装的东西太多，想删一些，但包太多不知道都是什么功能，删错了就会出各种问题。而Archlinux预装的包很少，就不用考虑这个问题了。&lt;/p&gt;
&lt;p&gt;后来就感觉Gnome特别臃肿，而且看起来也没有Ubuntu的好看。有个印象特别深刻的事情是Gnome左上角的菜单上有几个我从来用不到的Avahi相关菜单项，看起来十分烦人，但没有办法单独卸载Avahi相关的东西。于是就慢慢不想用Gnome了。当时逛论坛很多人用轻量级WM，我也尝试了好多，基本能装上的都试过了。试了几个发现openbox不错，配上tint2，很简洁，资源占用也上，于是用来几个月。后来有看到很多人推荐平铺式WM，之前我用不习惯也不想记那么多快捷键，基本上装上看一眼就卸了，这次又重新装上试一试，发现dwm比较合我胃口。主要是体积小，印象深刻，代码一共不到2000行，编译后好像只有17K，内存占用也很少。于是用它取代了openbox和tint2，从此再也没换过，直到后来我不再使用Linux的GUI环境。&lt;/p&gt;
&lt;p&gt;期间也听人说Gentoo很好用，我也试了试，在Archlinux上编译，然后直接使用Archlinux自己的内核把Gentoo启动起来。因为当时我已经不需要编译Gnome之类的大家伙了（当时用的openbox），安装十分顺利，也直接切换了过去。&lt;/p&gt;
&lt;p&gt;当时写的笔记，开始：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;20100304

gentoo安装和使用体验

进行了将近一天的惊心动魄的升级后（很庆幸系统没有挂掉，而且感觉更快了），终于想静下心来把一个星期以来的安装、配置以及升级gentoo大致写出来，一是想纪念一下，另外也许对其他想用gentoo的朋友有一些参考价值。
我使用linux不算很长，大概用了一年半的ubuntu和一年的archlinux。用archlinux时逛论坛经常有人谈及gentoo，好像用gentoo的都是高手。当时感觉可笑，各各发行版区别都那么大吗，之前用ubuntu转到archlinux也就是显卡驱动那碰到点问题，其他都比较顺利，gentoo又能难到哪去呢？另外gentoo安装软件都是要编译的，我的本性能也不好，就想如果以后换了新的再考虑吧，所以中间虽然想了几次，但一定没有尝试。
一个星期前（2010 3月4号），我把mplayer和ffmpeg都手动升级下，发现编译起来有点纠结，mplayer需要ffmpeg的源码，但ffmpeg还要单独编译，后来让mplayer用ffmpeg的so后升级ffmpeg后mplayer居然挂了，重编了几回才弄好。系统里有好几个包都自己编译，主要是想去掉不用的依赖，但手动维护太麻烦了，于是又想到了gentoo。当时已经10点多了，于是想第二天开始着手。
废话完毕。

之前的硬盘分区就这样的：
/dev/sda1 ext4 6g /
/dev/sda2 2g 未使用
/dev/sda3 ntfs 30g
/dev/sda4 jfs 66g /home
其中/dev/sda2是以前的swap，但后来不用休眠功能后感觉swap意思不大，就不用了。其余的三个分区都比较重要，基本动不得，这给怎么装啊。想来想去，先用sda2试试吧，如果装不上就没事了，装上再进一步考虑吧。
于是把sda2格成了reiserfs（某人说这种格式好，但我从来没用过，正好体验一下）。下载 stage3-i686-20110301.tar.bz2 和portage-latest.tar.xz。（前一个文件一周一更新）（我用的32位）
国内的镜像有：
http://mirrors.163.com/gentoo/
http://mirrors.sohu.com/gentoo/
http://mirror.bjtu.edu.cn/gentoo/
http://mirrors.xmu.edu.cn/gentoo/
这两个文件可以在里边找。

把sda2挂在/media/z上，并把文件放进去：
sudo mount /dev/sda2 /media/z
sudo tar xvpf stage3-i686-20110301.tar.bz2 -C /media/z
sudo tar xvpf portage-latest.tar.xz -C /media/z/usr
准备chroot环境：
sudo mount -t proc none /media/z/proc
sudo mount -vt devpts devpts /media/z/dev/pts
sudo chroot /media/z/ /bin/bash
现在就chroot进去了，之后的操作如不特别说时都是在这个环境下进行的。

初始化环境变量：
env-update;source /etc/profile

修改/etc/make.conf，这个非常重要，最好首先改到位，不然之后有你受的（我就是，不得要领，改了多回，改完还要重编译各种东西）：
加入源：
GENTOO_MIRRORS=&amp;quot;http://mirror.bjtu.edu.cn/gentoo/&amp;quot;
SYNC=&amp;quot;rsync://mirror.bjtu.edu.cn/gentoo-portage&amp;quot;
上边那四个网站都有说明如何写这个。
MAKEOPTS=&amp;quot;-j3&amp;quot; #-jn，n是内核数加1，多线程编译用的，不设置也行
INPUT_DEVICES=&amp;quot;keyboard mouse synaptics&amp;quot; #键盘、鼠标、触摸板
#下面的是很重要的USE，开始时可以只用USE=&amp;quot;X gtk&amp;quot;，但最开始写好以前就省事了，不然以后会麻烦重重。
USE=&amp;quot;-pppd -alsa -fortran sse sse2 ssse3 mmx sdl v4l v4l2 oss oss4 X gtk unicode truetype jpeg png gif cairo zsh-completion fontconfig video opengl&amp;quot;
VIDEO_CARDS=&amp;quot;radeon&amp;quot; #这个至关重要，显卡驱动类型，具体请查看官方wiki，我的是ati x2300，只能用这个开源驱动。
#CCEPT_KEYWORDS=&amp;quot;~x86&amp;quot; #这个要注意，如果要用最新的软件，可以加上这行，但如果是第一次装，强烈不建议加，不然会提升安装难度
先改这些就差不多了。

改/etc/locale.gen,加（按照自已需要写）
en_US.UTF-8 UTF-8
zh_CN.UTF-8 UTF-8
zh_CN.GB2312 GB2312
zh_CN.GBK GBK
运行locale-gen

cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
修改/etc/conf.d/clock
CLOCK=&amp;quot;local&amp;quot;
TIMEZONE=&amp;quot;Asia/Shanghai&amp;quot;

改/etc/resolv.conf，把本机的/etc/resolv.conf内容写出其中，不然上不了网。
改/etc/fstab，这个也可以安装完内核再写，这个应该都会写。

查看网络是否正常（如果电脑联网了，resolv.conf也改了就可以上了），然后同步portage（如果portage-latest.tar.xz是刚下的也可以略过这步，但最好还是运行下吧）：
emerge --sync
安装内核源码：
emerge gentoo-sources
下边就开始编译内核了，如果有手动配置内核的经验强烈建议手动配置编译:
cd /usr/src/linux
make menuconfig
make; make modules_install
cp arch/x86/boot/bzImage /boot
，不然最好使用genkernel：
emerge genkernel
cd /usr/src/linux/
genkernel --menuconfig all

关于配置内核请上网自行查询，如果下一种方式实在不会也可以不配置，一般也能启动起来。
编译时间和很多因素有关，几十分钟到几小时不等。

用户相关：（osily是自己要创建的用户名）
passwd
useradd -m -G audio,cdrom,portage,usb,video,wheel,users -s /bin/bash osily
passwd osily

如果fstab之前没改好现在一定要改好，然后改自己系统的/boot/grub/menu.lst。
此处官方wiki写的很清楚，建议查看。

现在可以继续安装其他软件，如xorg-server，但最好还是重启看看能不能进去。
如果不能的话多半是内核（尤其是自己编译的内核）的问题，如果内核没问题，看看/boot/grub/menu.lst是不是有问题，多改几回。
如果可以正常进去的话，可以直接在这继续编译，但最好还是返回原来的系统继续。

可以写个类似这样的脚本：
#!/bin/bash
sudo mount /dev/sda2 /media/z/
sudo mount -t proc none /media/z/proc
sudo mount -vt devpts devpts /media/z/dev/pts
sudo chroot /media/z/ /bin/bash

运行就可以进去chroot环境，如果进去环境变量不正常运行：
env-update;source /etc/profile
然后就是安装需要的东西了，主要看自己了，比如dhcpcd、sudo、vim……，一般的工具直接
emerge xxx就可以了，emerge的具体用法网上查吧。
但如果你想要桌面环境的话，最好按以下的步骤：
安装点基本工具后，直接安装xorg-server，注意前提/etc/make.conf里显卡和输入设备等变量一定是正确的。
这会安装许多东西，基本要用一个小时以上，耐心等待吧。
安装完后：（xorg-x11和驱动相关，请查看官网wiki相关部分，这部好像可以省略，记不清了）
eselect opengl set xorg-x11
如果安装好了，可以先重启试试，进去后，运行startx，这是很刺激的一刻了，如果显示找不到xterm找不到什么的，恭喜你，显卡驱动基本正常了，不然就会有各种稀奇古怪的问题&amp;amp;……&amp;amp;×……&amp;amp;……%×&amp;amp;，那么也恭喜你，在接下来的时间你将对安装显卡驱动、写xorg.conf等有深刻而透彻的了解。
如果是前者，你可以回去继续安装其他东西，如xterm（最好安装完再重启下看看是不是正常，如果不正常，那么你可以回过头处理显卡驱动问题了）、openbox甚至gnome、kde。下文再说。
如果是后者或者刚才的xterm显示分辨率不对、鼠标键盘触摸板不能用，那么你要折腾一会了，虽然之前安装内核没有难到你，这里很可能让足够纠结甚至放弃。

这也是我安装过程中最混乱的地方，已经没法清晰地回忆了，因为这的问题我先后重装了4次，（第一次因为2g空间不够，2、3次都因为X段错误，非常纠结），而且其中改了几回显卡驱动类似，重编译了多回。
如果是X段错误，看出错信息是不是加载某个so出的错，如果是可以先把那个so移到别的地方重试。如果不是段错误，可能是xorg.conf有问题，有的驱动是不需要这个问题的，默认也是没有了，所以如果有先删掉试试，不行的话用
X -configure
生成一个新的再
X -config xorg.conf.new
尝试
如果不行的话，还很有可能是内核没配置的问题，这往往比较麻烦，可以先仔细阅读官网wiki，不行再去linuxsir等论坛去找找或者问问。重编译内核后最好把和X相关的包也重编译下（有许多……）。
再有很可能是你选择的驱动不支持你的显卡，比如老的ati显卡很多都不能用现在的闭源驱动。这样可以试试其他的，改/etc/make.conf，然后必须把相关的包重新编译。
还有其他的可能吧……
如果xterm能进去了，但鼠标键盘等不能用，保证/etc/make.conf正确的话，安装xf86-input-evdev，如果
xf86-input-keyboard xf86-input-mouse xf86-input-synaptics 没有的话说明/etc/make.conf没写对，这时安装上这几个包也未必好用，可能要重新编译更多包。
这个问题应该是比较好解决的。
如果分辩率不正常，首先要确认用的不是xf86-video-vesa的驱动（按我的流程不会安装到这个包），如果是那很可以分辨率就不调不正常了。然后还是显卡驱动安装问题，还有xorg.conf，上网多找找吧。
显卡驱动问题如果一时解决不了的话，可能会拖很长时间，甚至直到放弃，或者你甘愿不用图形界面。

如果以上都正常了，gentoo离你就很近了。
接下来主要部署桌面环境，推荐比较轻量的，(如openbox、fluxbox、fvwm、dwm、awesome等），可以配合面板（tint2、bmpanel、pypanel等），不然要花很长时间编译。
安装完后就按自己的需要进行配置了。

现在还没有涉及的问题主要还有：声卡、网卡、摄像头等设备的驱动，以及触摸板不正常等。

如果触摸板用手指点无反应，但手指移动有反应，试试：
synclient TapButton1=1
如果横向滚动不能用：
synclient HorizEdgeScroll=1
其他问题请查询synclient用法
要把上边的命令放在启动脚本里，如是.xinitrc，确保它能在进入X前被调用。

声卡问题，如果用alsa的话，genkernel默认编译的内核包含了alsa驱动，应该就要以正常使用了，如果没包含就要有点麻烦。
如果内核包含了oss驱动（这是旧版本的），可能也可以正常用，但效果应该不好，能忍就算了吧。
如果都没有的话如果内核启用的声卡支持（menuconfig里有一层的里边是alsa和oss，它的上一层要选上），你可以选择安装alsa或者oss驱动，个人推荐用oss4，它音质比较好，占用资源少（我试和内核的alsa里比mplayer放mp3时cpu占用省了一半）。但安装oss4不是很容易，因为它不在portage里，要用layman，还要能连接国外网。alsa没装过，官网wiki有详细说明。
如果现在就要安装oss4，也好：
emerge layman
layman -a oss-overlay
然后再/etc/make.conf里加一句：
source /var/lib/layman/make.conf
然后
emerge oss或者emerge oss-devel
如果网络没问题的话应该正常安装。
要保证/usr/src/linux指向的是当前用的内核
然后/etc/init.d/oss start，一般要等几分钟因为要编译内核模块，如果成功了基本就可以用了，可以试试osstest，不成功的话问题就麻烦了，很可能你要重新编译内核了，看是不是有什么漏选或多选了。在此处我重编译了一次内核，因为之前把alsa编译进去了。
如果解决不了还是多读官网wiki，不行再逛论坛或者问别人。
但总体声卡驱动安装还是比较容易的。

然后你可能发现无线网卡没驱动起来，运行
ifconfig -a
找不到无线网卡，那么恭喜你又基本又需要重编译内核了。
而且要先确实自己网卡的型号(lspci|grep net)，然后去menuconfig选项里找，如果没有的话可能要再安装驱动。我的是Atheros，调整选项重编译内核可以了。不行的话还是看官网wiki，上过说的比较清楚，各论坛也有许多相关的贴子。

摄像头的话看/dev/video0是否存在，如果不存在，那么你应该猜到了，再调整选项重编译一回内核吧。其实应该只重编一回把驱动问题都解决了，不然真是痛苦啊。关于怎么改选项wiki和论坛也有……

如果你还有其他一些东西（如麦克风）无法驱动，解决的办法是类似的。

注意，即使你用的genkernel编译的内核也很可能少各种驱动，所以如果对内核选项不了解的话基本就寸步难行了。但如果感觉某个设备可以先不用的话可以先学习点基础东西再回过来处理。

如果你的各种驱动都正常了，那么基本问题都解决了，剩下的问题一般不会很难如果你不想再折腾了。

你可以安装上所有自己需要的东西，而且安装过程一般不会出什么问题，除了时间比较长。
你可以好好熟悉gentoo的和配置文件和启动流程，按自己的方式修改。
再有就是熟悉emerge和其他相关命令是非常必要的，但这也许比你想象的复杂，开始我想到相关命令和archlinux的一一对应起来，但发现这是不大可能的，二者差别很大，你必须从头认识和了解。

网上有些资料是过时的，你很可能发现上边说的某个文件系统里根本就没有，但到现在应该有足够的能力解决这样的问题了。

如果没有什么其他的需求，就可以正常用了。

如果你想启用~ARCH，那么在升级时还要折腾一番，而且如果准备不充分很可以把辛辛苦苦配好的系统弄得一团糟甚至挂掉。
如果你准备好了要用~ARCH的软件（更新，但出bug的几率更高），在/etc/make.conf（32位的）里加：
ACCEPT_KEYWORDS=&amp;quot;~x86&amp;quot;
然后选择合适的时间进行系统升级：
gentoo的升级尤其是大幅度升级不想某些发行版是一条命令的事，要做好充足的准备。
如果你想用新的gcc编译包，可以先升级gcc （注意，编译gcc要1G以上的空间，具体我也不清楚，如果/var/tmp是内存虚拟的一定要看看够不够2G或更多，如果没有还是先用硬盘吧）：
emerge -u gcc
但这条命令我没用，当时我感觉安装和升级是一个概念，就直接用了
emerge gcc 我不大清楚结果是不是一样的。
但这并不会直接升级gcc，而不是两个gcc并存，而且默认是之前那个，要手动调整成后一个：
gcc-config -l
gcc-config i686-pc-linux-gnu-4.5.2 #选择后一个版本
然后最要先升级python（我开始没有这么做，出了不少麻烦）
不想有些发行版python2和python3是分两个包，gentoo里这是一个包，现在如果你要把python2.6升级到2.7，直接
emerge -u python，它会安装python2.7但不会马上卸了2.6，此时的操作非常重要：
不要忙着去升级其他包而要先把python的问题解决明白了，不然你可以自己感受下~~
先把python2.7设成默认的python2
eselect python list
eselect python set --python2 num #num是上面输出的行号
python-updater
这将会用不少时间，其中会升级一些包。
如果没有错误，那么可以升级其他包了：
emerge -uDN system
同样要用许多时间，如果中间出错了只是按实质情况解决了。如果有的包提示python语句错误很可能是有的用python2但写的是#!/usr/bin/python，这样的话要先手动按之前的方法把默认python改成python2：
eselect python list
eselect python set num
一般就能解决。

之后可以升级其他包：
emerge -uDN world

这个运行之后还没有完，一定要注意：
清除没有用的包
emerge --depclean
检查依赖
revdep-rebuild
更新配置文件
dispatch-conf

更新配置文件时要注意，不要把自己有用的配置给覆盖了，或者留下了不兼容的旧配置文件，了解清楚再选择。

注意在整个升级前要把USE确定好，不要在升级中改USE，不然要能要重编译许多包。

整个升级要用挺长时间，如果要中断可以用ctrl+c，恢复再用之前的命令，如果要关机就要注意，系统完全可以启动不正常，如分区不能正常挂载、X不能启动、声音不正常等，要有能力处理这些问题，但有些问题是要等升级完才能完全解决的，所以先临时处理下就行。

升级中一些低层的包有较大改动，如openrc，这样配置文件会有不小的改变，要了解清楚再作改动。

如果升级圆满成功，那折腾基本告一段落了，可以去做自己喜欢做的事了。

其中许多细节记不大清了，许多东西也是参考了网上的许多资料。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当时的笔记，结束。&lt;/p&gt;
&lt;p&gt;除了安装软件需要编译慢了些，其他的还好，于是决定改用Gentoo。后来也用自己编译的内核替换掉了Archlinux的，甚至为了缩小内核体积，反复修改配置编译，最后缩到大概1M多，没有initrd。&lt;/p&gt;
&lt;p&gt;当时的截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/027.jpg"&gt;&lt;/p&gt;
&lt;p&gt;可能看不清，是openbox+tint2，uname -a的结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux localhost 2.6.36-gentoo-r5 $1 SMP Mon Mar 7 15:09:30 CST 2011 i686 Intel(R) Pentium(R) Dual CPU T2390 @ 1.86GHz  GNU/Linux&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但用了大概两个月，感觉Gentoo没有人们说的那么好。当时写的东西找不到了，现在回想大概有这样几个问题：
1. USE的定制不够细。当时在Archlinux，我为了精简软件包的大小，手段是否苛刻，像vim、mplayer、ffmpeg等比较大依赖比较多的包，我全部自己修改PKGBUILD去掉自己不需要的依赖重新编译，基本上缩得不能再小了。而Gentoo的USE虽然能定制，但不能这么细地定制。而且我发现ebuild文件没有PKGBUILD好写，索性也不想改了。
2. 系统里有很多没有被Portage跟踪的文件，也就是说很多文件是查不到属于哪个包的，这对有洁癖的我是很难接受的，Archlinux绝大多数文件都是属于某个包的，除了少数安装或者运行时产生的配置文件或者pyc之类文件，不仅量很少，也与已有的包相关。
3. 系统配置没有Archlinux方便。当时Archlinux还是rc.conf一统天下，/etc下的其他配置文件很少需要改，修改配置十分方便。而Gentoo就要改好几个文件，甚至还有/usr下的文件。
4. Archlinux的netcfg（现在的netctl）是否方便，而Gentoo网络的配置就比较繁琐了，现在我已经想不起来怎么配了。
5. 安装软件包太慢，我笔记本性能也不是很好，发热严重。像firefox之类大软件源里有bin包，但我用了一阵发现bin包的质量普遍堪忧，比如我遇到过依赖的so文件和系统中的so版本不兼容，也无法使用USE，和自己编译的完全不是一个体验。
6. 最重要的问题，我没有发现对我来说Gentoo的优势。USE对我的吸引力很少，同一软件的多版本共存也是，因为我从来都是追最新版本。&lt;/p&gt;
&lt;p&gt;于是我又换回了Archlinux，还好当时没有删。从此我再没有更换过发行版，最多偶尔用Live CD试用体验一下。&lt;/p&gt;
&lt;p&gt;再然后就开始工作了。上学时我几乎不使用虚拟机（当折腾过wine，折腾过好多次，至今还感觉不适不想提起），在学校基本没有什么是Linux搞不定的。当工作后发现一个麻烦的问题，需要使用一个只要Windows版本的聊天软件，虽然也有Web版，但Web版功能过于简略（我开始时还是用Web版的，但比如关了浏览器聊天记录就再也找不回来了，功能上也有严重缺失，最后不用了），只好用Virtualbox装个XP虚拟机（除了那个聊天软件，偶尔也需要用下Word、Excel等。有个插曲是之前用永中Office，但它有个bug，保存出来的文件可以再也打不开了，被坑一次后我再也不敢用了。Openoffice对doc文档的支持很成问题，完全走了样没法用。Wps的Linux版本已经是后来的事情了。）。&lt;/p&gt;
&lt;p&gt;然后这个虚拟机对我来说就如鲠在喉，特别不爽。比如占用大量的内存，当时电脑内存是4G的，平时工作都需要开着虚拟机（里边一直运行的聊天软件也不是省油的灯，偶尔需要开MS Office等）、浏览器（Firefox）、邮件客户端（Thunderbird）、终端模拟器（Xterm），有时浏览器页面开多了内存就不足了。界面切换也比较麻烦，当时还是用的dwm，第一个桌面是Xterm和Firefox，第二个桌面是Thundervird，第三个桌面是Virtualbox。Xterm和Firefox是用Ctrl+Tab切换，3个桌面是用Win+数字切换。但进了Virtualbox后，Win键就被XP占用了，得按下右Ctrl才能再用Win+数字切换到其他桌面。虽然习惯了也能用，但还是不爽。我们是有一个笔记本加一台显示器（22寸），开始时我只有显示器，因为同时看显示器和笔记本屏幕（12.5寸）不是很方便，高度也不好调节。后来因为Virtualbox切换麻烦，加上经常没有及时看到聊天软件的消息，把Virtualbox的窗口放到笔记本屏幕上了，这样稍微好了些。&lt;/p&gt;
&lt;p&gt;工作后的另一个改变，是很少再折腾桌面Linux了，时间原因还是其次，主要是没兴趣了。所以经典的软件搭配（dwn+Firefox+Zsh+Tmux+Xterm+工作后新加的Thunderbird）一直用到最后我也没再换。但并不是没有问题，前三个还好，Xterm的主要问题是不支持实时调节字体大小，和使用Tmux时rz、sz没法使用。字体大小平时是不需要调节的，但接投影演示时是需要的，只能去改配置文件重启，比较麻烦。更麻烦的是rz、sz，因为我们登陆服务器要经中转机，直接scp文件是不行的，比较方便的办法就是rz、sz（C-Kermit是支持的，直接用ssh不支持），或者走Samba（在Linux用比较麻烦），或者自己在服务器搭Http Server（更麻烦）。所以需要传文件时，需要另开一个不进Tmux的Xterm，有时一着急就容易忘，直接把Tmux的一个Tab卡死，有时那个Tab是很重要的，比如有重要的history，或者中转了好几个机器才进去的，就非常麻烦）。&lt;/p&gt;
&lt;p&gt;直到14年，当时我对桌面Linux已经没什么热情了，我才想是不是可以改用Windows。当时只是试一试，但没想到不到两周的时间，我已经完全适应了在Windows下工作，另外装了Cygwin（后来改成Msys2）和Virtualbox中的Archlinux。一般的操作在Cygwin都是可以完成的，用起来和原生Linux相差不多，如果不频繁启动新进程，性能上也没有明显差距。而运行着Archlinux的Virtualbox内存占用通常不到50M（里边看使用了23M左右）。内存问题完全解决，再没出现浏览器开了过多页面内存不足的情况。Xterm改成了Xshell+mintty。连接中转机统一使用Xshell，不得不说Xshell还是很好用的，虽然多数功能我都用不到。而本地的Cygwin和Archlinux都用mintty，我感觉比Xterm好用。&lt;/p&gt;
&lt;p&gt;这里提下我为什么坚守Xterm，而不要Urxvt和各种基于vte的终端模拟器。基本上我见过的都尝试过了，Urxvt的问题是字体方面，怎么调整都别扭，不是字体间距有问题，就是有些全角字符显示有问题，而对我来说，相比Xterm几乎没有什么优势，资源占用还更多。而基于vte的终端模拟器有一个共同的问题，就是在里边用Tmux时，下边的色块显示有问题，这个不大好形容，不影响功能，但看起来十分别扭，我多次试图解决都无功而返。而且vte本身的主要问题是能配置的东西太少，没记错的话背景颜色都没法改，比Xterm功能还有少很多。而基于vte的家伙一个比一个臃肿，那些功能都不是我想要的，有因为vte那个共性的问题，我最多尝试来其中某个一两天时间就又放弃了。另外一个值得一提的是mlterm，看起来很漂亮，配置也比较方便。但有一个致命的问题，一时想不起来了，好像是无法快捷地复制，要不就和中文有关，或者有个什么致命的bug，说数次尝试都发现问题犹在而无法使用。最后发现能用的只有Xterm。但Xterm也有几个问题，除了之前说的不能实时更改字体大小，还有配置文件比较麻烦，经常需要上网各种搜，然后改一下重启一下Xterm（有时为了调整字体和字体间距需要改好多次效果才可以接受），不能配置成右键用来粘贴（印象中是这样，可能记错了），复制好像也存在问题（后来好像在配置文件里配的某个快捷键是复制，或者选择直接复制，想不起来了），命令输出内容过多时需要滚动好久等等。而这些问题mintty都没有。&lt;/p&gt;
&lt;p&gt;关于和Windows的其他事情需要以后再单独写了。&lt;/p&gt;</content></entry><entry><title>我们真的了解思维吗？</title><link href="/wo-men-zhen-de-liao-jie-si-wei-ma.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-men-zhen-de-liao-jie-si-wei-ma.html</id><summary type="html">&lt;p&gt;“思维”如何运作是一个至关重要又无比困难的问题。我无法描述清楚我是怎么一步步得到这个结论的，只是阐明自己的看法。&lt;/p&gt;
&lt;p&gt;思维只是一种模拟过程，它做到是解释已经发生的事情，更抽象地说是对世界做一种解释。但它的功能是有很大的局限性的，简单说它永远无法认识到真实情况是怎样的，它本身也只是结果，而不是原因，思维总是滞后的。&lt;/p&gt;
&lt;p&gt;简单说，今天午饭时间，我在想是吃米饭还是吃面条，最后我选择了米饭。我可能会认为我选择米饭是思考的结果。但实际上不是，我不清楚我为什么真的选择了米饭，思考只是对这个行为的一个解释。或者说就算我不思考，我其实还会选择米饭，只是那种情况我就更不清楚选择米饭的原因了，因为我放弃了这一次解释。&lt;/p&gt;
&lt;p&gt;首先需要明确，这和决定论是不同的，相反它更像不可知论，但更深入一些。我开始时一直认为它和决定论是等同的，从而不肯深入思考。&lt;/p&gt;
&lt;p&gt;我们来看一些看似无关的事情。我们清楚一些物理定律，就知道从高空掉落的铁球是以怎样的速度掉落的。但我们不会相信铁球内部运行着一个程序，它内置各种物理定律，接受地球质量、空气密度等参数，从而计算它的运动途径。但如果我们想在计算机模拟这一过程，则有所不同，我们的程序并且清楚所有的物理定律和参数，才能模拟的和物理世界相同，或者至少看起来相同。那么问题是，如果我们认为的真实世界不是更高层世界的一个模拟，那么就不应该有任何一个系统知道所以的物理定律，并通过计算来模拟。&lt;/p&gt;
&lt;p&gt;也就是说，如果我们真的认为我们所认识的世界是真实世界，而不是一个模拟出来的世界 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;“思维”如何运作是一个至关重要又无比困难的问题。我无法描述清楚我是怎么一步步得到这个结论的，只是阐明自己的看法。&lt;/p&gt;
&lt;p&gt;思维只是一种模拟过程，它做到是解释已经发生的事情，更抽象地说是对世界做一种解释。但它的功能是有很大的局限性的，简单说它永远无法认识到真实情况是怎样的，它本身也只是结果，而不是原因，思维总是滞后的。&lt;/p&gt;
&lt;p&gt;简单说，今天午饭时间，我在想是吃米饭还是吃面条，最后我选择了米饭。我可能会认为我选择米饭是思考的结果。但实际上不是，我不清楚我为什么真的选择了米饭，思考只是对这个行为的一个解释。或者说就算我不思考，我其实还会选择米饭，只是那种情况我就更不清楚选择米饭的原因了，因为我放弃了这一次解释。&lt;/p&gt;
&lt;p&gt;首先需要明确，这和决定论是不同的，相反它更像不可知论，但更深入一些。我开始时一直认为它和决定论是等同的，从而不肯深入思考。&lt;/p&gt;
&lt;p&gt;我们来看一些看似无关的事情。我们清楚一些物理定律，就知道从高空掉落的铁球是以怎样的速度掉落的。但我们不会相信铁球内部运行着一个程序，它内置各种物理定律，接受地球质量、空气密度等参数，从而计算它的运动途径。但如果我们想在计算机模拟这一过程，则有所不同，我们的程序并且清楚所有的物理定律和参数，才能模拟的和物理世界相同，或者至少看起来相同。那么问题是，如果我们认为的真实世界不是更高层世界的一个模拟，那么就不应该有任何一个系统知道所以的物理定律，并通过计算来模拟。&lt;/p&gt;
&lt;p&gt;也就是说，如果我们真的认为我们所认识的世界是真实世界，而不是一个模拟出来的世界，或者我们真正想认识的是一个真实世界的话。所有的物理定律都只是解释这个世界的一种工具，而不存在这个世界按某种定律运行的描述。通过物理定律对世界做解释，就像用一个函数对一个数据变化趋势进行拟合一样，你可以拟合地丝毫不差，但不意味着数据是因为知道了这个函数，然后才知道它如何变化的。这是一个本质的区别。&lt;/p&gt;
&lt;p&gt;即使我们真的得到了对整个世界的完整描述，也不是真的了解了这个世界。二者存在着一种无法抹去的隔阂。&lt;/p&gt;
&lt;p&gt;现在我们再看思维。思维其实就是这样的一个模拟器，它所做的就是对我们所认识到的世界做某种解释。但就像用计算机模拟现实世界一样，现实世界无需做任何计算，而计算机为了模拟，需要做大量计算，二者是存在本质的区别的，完全是不同的模式。除了是否需要计算的区别，还有一个重大区别。对于一件事情，模拟的过程是有先后顺序的，因为系统需要根据原因计算结果，而计算本身是需要耗时的，无论速度多快。而真实世界是没有先后顺序，一个事情发生了，因和果就是同时发生，甚至其中根本就没有所谓的因和果，我们认为有因果，只是因为这是一种解释。同样地，思维也是在进行某种计算，以对外部世界做模拟。&lt;/p&gt;
&lt;p&gt;想想我们在看一个电影，如果电影的剧情不是那么一目了然，我们又想真正了解剧情的话，我们就需要调动思维对电影里角色的一举一动做分析，这很正常。但我们正常的生活实际上也并无不同。我们的一举一动并不是由思维确定的，我们实际上根本不清楚这一举一动是怎么回事，思维要做的就是对这个问题做解释，但无论怎么解释，这和实际情况都是不是一回事。&lt;/p&gt;
&lt;p&gt;如果我们对外部世界的认识都是有问题的，我们又怎么可能对自己思维的运作方法有透彻的了解。我之前一直认为思维的潜力是很大的，我们没想清楚，只是因为没有找到正确的方法。但现在我相信了模拟终归是模拟，模拟地再想，和实际情况也是有本质的不同的。&lt;/p&gt;
&lt;p&gt;我没有证明这个想法是正确的，我认为是无法证明的，我也无法反驳很多其他想法。不然这个问题就不好讨论了几千年仍没有一致的结论。&lt;/p&gt;
&lt;p&gt;一个引导我产生这个想法的事情是今天早晨做的几个梦。实际我已经醒了，但看时间尚早，就继续睡去。梦中我发现周围有很多机器（或者说程序）在运行，而我的思维停滞了。感觉过了好长时间，我醒来看时间，只过了不到5分钟。我又睡去，做同样的梦，再醒来还是只过了几分钟，反复了3-4次。最后醒来后我开始回想当时的场景，就像是在告诉我我的思维本身毫无用处，真正做事情的是那些机器。&lt;/p&gt;
&lt;p&gt;这个想法看起来不是那么直观，如果它没有解决任何问题，那它毫无意义。&lt;/p&gt;
&lt;p&gt;思维真实的样子。&lt;/p&gt;
&lt;p&gt;举个简单的例子。我走到了一个十字路口，我选择了一个方向。当时我确实思考了，但事后回忆时，我想当时是因为A原因这么走的，但这并不是实际情况，它只是一个模拟。当时思考过程是怎样的我并不清楚，事后的思想只是对当时状况的一个理解。&lt;/p&gt;
&lt;p&gt;如果我不在对思考本身进行理解，实际上在我看来就没有思想的过程了，连“我”本身都不应该存在了，因为只有在对现实进行模拟时，才需要这样一个“我”。&lt;/p&gt;
&lt;p&gt;所有实际上有两种思考，一种是真正的思考，另一种是对思考过程的模拟。我们是使用后一种来认识前一种。实际上我们可以完全不进行第二种思考，那看起来我就不在思考了，也不存在一个主观的“我”了。&lt;/p&gt;
&lt;p&gt;思考的一个主要方式就因果关系。但要知道因果关系是对真实世界的模拟，它并不存在。比如起风了，树在动。我们容易认为起风是原因，树动是结果。但实际是并不是先起风，树才动，二者是同时发生的。换个例子，两个球以相同的速率相反的方向相撞后，弹飞了。那么这个过程中谁是因谁是果呢？风和树的作用也是类似。我们划分因果只是对事情的有种解释，所有同时发生的事情，因果关系是不存在的。那么有时间顺序的呢，如果A在B之前发生，A可以作为B的因吗？比如还是刚才风吹树的例子，我们知道风是有速度的，那么我们是否可以认为风抵达树的过程是风最后吹动树的结果呢？实际上这就和树没关系了，我们可换一个例子。一个小球在没有外界作用力的情况下，它会保持运动状态。那么最初小球是匀速直线运动的，它就会一直持续这个运动。那么我们可以说小球下一个时刻的运动是果，前一个时刻的运动是因吗？如果小球是静止的的，它就一直是静止的。那么我们说它下一个时刻的静止是果，上一个时刻的静止是因吗？因果只是我们认识事情发生过程的一种方式，真实世界中没有因也没有果，更没有一个程序更加因计算果。&lt;/p&gt;
&lt;p&gt;如果我们承认因果关系并不真正存在，只是我们解释事情的一种方式。那么我们想这个问题，你想吃一个面包，然后你确实吃了，那么这是一个因果关系吗？如果之前在物质世界发生的事情中没有因果关系，那么这个因果就很可能是不存在的，只是我们解释时添加的。也就是说我想吃面包，我吃了面包，这是自然发生的， 不存在因果关系。而因为我想吃面包，所有我吃了，是对这个自然发生事情的因果解释，这个解释是错误的。&lt;/p&gt;
&lt;p&gt;但正如我们不清楚一个匀速运动的小球为何会这样运动，牛顿定律只是对它的解释，而不是它的原因。我们也不清楚思维是如果运作的，所有的解释都不是原因。&lt;/p&gt;
&lt;p&gt;那么如何能理解这件事情。我想吃面包了，于是买来一个面包，并且吃掉了。首先我们需要把我们对思维的解释去除，也就是我们对这件事情的回忆。那样“我想吃面包”就不是一个确定性的事件，而是我对事件的解释。当我说“我想吃面包了，于是买来一个，并且吃掉了”时，真正发生的事情是“我买了一个面包，并且吃掉了”。至于原因。如果我们不清楚一个匀速运动的小球为什么会匀速运动下去，也不会清楚“我买了一个面包，并且吃掉了”的原因。这两件事并没有本质的区别。但我们并没有否认“我产生我想吃面包”这一思想的事件，这件事确实发生了，它所我们对其他事情的一种解释，但它的原因我们还是不清楚。&lt;/p&gt;
&lt;p&gt;如果这样看的话，我们有自由意志吗？&lt;/p&gt;
&lt;p&gt;如果“自由意志”是指我们想做什么就做什么，那么我们没有自由意志。因为事情不是这样的，并不是我们先知道想做什么，才去做什么。而是我们做了什么，才去想做它的原因。我们做一件事情，肯定是有原因的，但如果我们弄不清楚原因是什么，我们就不应该说我们有自由意志。我们做的任何事情我们都不清楚它的原因，包括思考本身，我们在下一次思考的可能是上一次自己做的事情的原因，而这一次思考的原因又可以在下一次思考。但每次思考的原因，我们都不清楚。每次思考会产生怎样的影响，我们也不清楚。实际上因为因果关系并不存在，这样的说法本身就是有问题的。&lt;/p&gt;
&lt;p&gt;但如果从更上层看，我做的每一件事情是注定的吗？不一定，我们不知道做的每一件事情的原因是什么，也许所有事情都是注定的，或者不存在类似时间的东西，也可能每一个“我”的背后都存在一真正做决定的主体。&lt;/p&gt;
&lt;p&gt;这是决定论吗？或者这和决定论有冲突吗？&lt;/p&gt;
&lt;p&gt;这个观点不依赖决定论，和它也没有矛盾。所有它更像不可知论。&lt;/p&gt;
&lt;p&gt;这样的观点对我们的生活有什么影响？&lt;/p&gt;
&lt;p&gt;首先有几个陈述是不对的：
1. 我想做什么，是我做某件事情的原因。因为并没有因果关系，而且我知道“我想做什么”是滞后的，对于真正的“我想做什么”因为我并不清楚，这个“我”的指代是不明确的，从而这个描述是有问题的。
2. 无论我怎么想，都改变不了自己的命运。因为我想一件事情，这是一个具体的事件，就和我吃了一个面包一样，并没有特殊性。
3. 我的一举一动受自己控制。我的一举一动也许受某种东西控制，但不是“自己”，因为我不清楚是谁控制的，不能把一种我不清楚的东西称为“自己”。
4. 时间是存在的。时间是我们在解释事物的时候引入的，就像物理定律一样。我们引人时间某种程度是因为我们相信因果律，而因果律需要时间。如果物理定律不是存在于某处，时间也是一样。当我们不试图对发生的事情做任何解释是，我就就意识不到时间。&lt;/p&gt;
&lt;p&gt;当我们发现思考和吃饭之类行为并不本质不同，我们思考不出吃饭的原因，也思考不出来思考的原因后，“思考”的问题就告一段落了，但还有一个至关重要的问题没有解决，我是什么？&lt;/p&gt;
&lt;p&gt;“我”也是思考引入的。我们为了解释一些事情，引入了“我”的概念。“我”就像时间一样，并不存在于任何地方。当我们不去解释任何事情时，“我”就消失了。&lt;/p&gt;
&lt;p&gt;那现在的问题是如何接受“时间”、“我”是不存在的。或者说，“时间”、“我”是思维引入的概念，这个如何理解？&lt;/p&gt;
&lt;p&gt;只有思维在模拟一个事情时，才需要“我”、“时间”的存在。在深入思考这个问题时，“语言”甚至思维本身都遇到了麻烦。因为语言假设了“我”的存在，如果抛弃“我”，甚至没有办法解释任何问题。当思维引入了“我”的概念时，实际发生了什么。我们无法知道真正发生了什么，我们只能找出一种解释。但因为“我”是非常让人困惑的概念，它引入的问题甚至比解决的还要多，所以有必要换一种解释方法。&lt;/p&gt;
&lt;p&gt;我们需要大概模拟出思维的运作方法。思维在想一个事情时，必须有一个概念被引入到思维中，这是一个假设，而不是一个事实。当思维在想一个数字1时，并不是1真的存在，而是这个概念在思维中产生了。思维中的所有东西都是外来的，都是五中生有或者是对其他东西的模拟。“我”也一样。人和人直接为了交流，“我”的概念就必要的。但它的含义是让人困惑的。&lt;/p&gt;
&lt;p&gt;思维为了模拟其他东西，必须创建一些概念，这些概念可能是无中生有的（比如数字1），有些是对应各某些东西（比如一个苹果，但即使这样这个概念和苹果本身也是不同的）。那么问题是“我”是一个无中生有的概念，还是对应着一个实体。如果我可以证明没有一个“我”可以与之对应的特定实体，“我”就是无中生有的。&lt;/p&gt;
&lt;p&gt;我们使用的“我”指代的到底是什么？
身体？精神？当我们使用“我的”时，任何后边的东西都可以从“我”中抽离开。那有什么东西属于我，但不能使用“我的xx”来说吗？&lt;/p&gt;
&lt;p&gt;“我”只是一种指代，它可以指代很多东西，比如身体、精神、灵魂，以及思维自身。&lt;/p&gt;</content></entry><entry><title>“我”为什么不存在？</title><link href="/wo-wei-shi-yao-bu-cun-zai.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-wei-shi-yao-bu-cun-zai.html</id><summary type="html">&lt;p&gt;在这里，我将要论述一个至关重要却无比艰难的哲学问题，关于“我”。这个问题如此吸引人，解决了它就解决了一多半哲学问题，但无数哲学家终其一生也得不到一个能让多数人不再困惑的答案。我深知自己也没有这样的能力，我所要做的，仅仅是让自己不再为“我”的概念困惑，至于别人是否理解，甚至认同，都不再重要。&lt;/p&gt;
&lt;h2&gt;“我”是什么？&lt;/h2&gt;
&lt;p&gt;“我”是什么，这是触及到“我”的第一个问题，也是最后一个问题。它的艰难之处在于我们无法将这个问题化解，分而治之。&lt;/p&gt;
&lt;p&gt;我们基本每天都在生活中使用“我”这个字，我的工作、我的身体、我的心情等等。我们是否自然地在各种地方使用“我”这个字，就像我们都十分清楚它的确切含义。但这里的“我”的含义真的一样吗？&lt;/p&gt;
&lt;p&gt;“我”看起来是一个范畴，它包含着一些东西，但我们可以把一些东西从“我”中拿走，这样“我”的含义就发生了变化。
“我的工作”中的我，是不包含工作 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;在这里，我将要论述一个至关重要却无比艰难的哲学问题，关于“我”。这个问题如此吸引人，解决了它就解决了一多半哲学问题，但无数哲学家终其一生也得不到一个能让多数人不再困惑的答案。我深知自己也没有这样的能力，我所要做的，仅仅是让自己不再为“我”的概念困惑，至于别人是否理解，甚至认同，都不再重要。&lt;/p&gt;
&lt;h2&gt;“我”是什么？&lt;/h2&gt;
&lt;p&gt;“我”是什么，这是触及到“我”的第一个问题，也是最后一个问题。它的艰难之处在于我们无法将这个问题化解，分而治之。&lt;/p&gt;
&lt;p&gt;我们基本每天都在生活中使用“我”这个字，我的工作、我的身体、我的心情等等。我们是否自然地在各种地方使用“我”这个字，就像我们都十分清楚它的确切含义。但这里的“我”的含义真的一样吗？&lt;/p&gt;
&lt;p&gt;“我”看起来是一个范畴，它包含着一些东西，但我们可以把一些东西从“我”中拿走，这样“我”的含义就发生了变化。
“我的工作”中的我，是不包含工作，恐怕没有人认为工作是“我”的一部分。
“我的身体”中的我，则存在歧义。歧义在于“的”的含义。这里即可以理解身体是“我”的一部分，也可以理解为身体是“我”拥有的东西，而不是“我”的一部分。但这并不是主要问题，在这两种理解下，“我”分别包含身体，和不包含身体。
“我的心情”中的“我”也一样，两种理解分别是包含心情和不包含心情。&lt;/p&gt;
&lt;p&gt;于是，在一些情况“我”的含义就可以确定下来了。比如对于认为“我”应该包含心情，但不包含身体的人，“我”的概念就是确定的。但同样地，这时“我”就失去了它原本的含义。我们需要清楚，“我”是一个代词，类似的还有“你”和“他”。但我们很少问“你”是什么，或者“他”是什么，因为指代什么就是什么。唯有“我”，存在这样的疑惑，因为对不同的人来说，“我”指代的东西有所不同。一旦“我”的含义确定了，它便消失了。认为“我”和身体等同的话，任何“我”出现的地方，都可以用身体取代，“我”只是一个代号，本身不具备特别的意义。&lt;/p&gt;
&lt;p&gt;但“我”令人困惑的地方在于并不是所有情况它的含义都可以被这样确定下来。某些人认为，在“我是XX”中，无论XX是什么，它都只是“我”说拥有的东西，而不是“我”的一部分。那么看起来“我”就不是一个代词，它是有确定含义的，那么这个含义是什么？这个“我”才是哲学上的“我”。&lt;/p&gt;
&lt;h2&gt;思维是什么？它如何运作？&lt;/h2&gt;
&lt;p&gt;为了继续探讨“我”是什么的问题，我们必须深入下去，进入另一个哲学问题，思维是什么？&lt;/p&gt;
&lt;p&gt;这个问题一点也不比“我”的问题容易，实际上我正是思考这个问题才不断对“我”是什么有更深入的认识。&lt;/p&gt;
&lt;p&gt;当我们只想一个数字1时，我们的思维中有什么？只有一个数字1。那如果我问数字1存在吗？你如何回答。这里涉及到“存在”的问题，在这个问题上我不想耗费过多时间。存在是一种关系。也就是说，我们不能只说A存在，而要说A存在于B。日常生活中我们通常省略B，而B默认指的是外部世界。但在讨论思维时，我们必须明确B指代什么，就是思维自身。所以数字1存在于思维世界中。当我们想“1+1=2”时，时间上思维中存在4种东西，“1”、“+”、“=”、“2”，我们可以称其中“1”、“2”是实体，“+”、“=”是关系。实体和关系是处理信息时用到的，没错，思维处理的正是信息，而且任何信息都可以用实体和关系加以描述。&lt;/p&gt;
&lt;p&gt;当我们想一个苹果时也是一样，思维中出现了一个苹果的实体，注意思维中的苹果和实际的苹果已经完全不同了，它是对实际苹果的一种模拟。而思维中出现“我吃苹果”的场景，“我”和苹果是实体，“吃”是关系。“我”也是思维中的一个实体。那我们就可以继续想“我”的问题了。如果在“我是XX”中，无论XX是什么，它都只是“我”说拥有的东西，而不是“我”的一部分，“我”是什么。这个答案是我突然间意识到的，这种情况，“我”指代思维本身。实际上思维会对思维中的实体分为两类，一类是“我”的，另一类不是“我”的，而这个“我”，正是指思维本身。至此，“我”的指代问题已经清楚，“我”的问题已经瓦解，问“我”是什么，就想问“他”是什么一样，不再有意义。&lt;/p&gt;
&lt;p&gt;但这样做的结果是将之前“我”的问题转移给了“思维”，而不是真正解决掉，我们不能自欺欺人。而思维的问题开始显露出它的复杂性。&lt;/p&gt;
&lt;p&gt;要想弄清思维是什么，我们先需要清楚什么是模拟。&lt;/p&gt;
&lt;p&gt;我们如果学过一些物理定律，就知道从高空掉落的铁球是以怎样的速度掉落的。我们可以在电脑内模拟铁球下落的过程，因为设定好了物理定律，知道了诸如铁球质量、地球质量、空气阻力等参数，我们就可以计算出铁球下落的速度。如果足够精确的话，我们模拟的铁球下落过程，可能和真实世界的没有差别。但是，我们会认为铁球内部设运行着这样的一个程序，来计算它的下落速度吗？显然不是这样，铁球不需要知道任何东西。不仅铁球内部，如果我们认为我们的世界是真实的，而不是另一个世界模拟出来的，就不会相信有任何一个系统会根据物理定律和参数来计算铁球运动轨迹，从而指挥它运动。也就是说，真实世界的铁球下落不需要任何计算，它和电脑模拟的是有本质区别的。&lt;/p&gt;
&lt;p&gt;类似地，思维也是一个模拟器，它所做的就是对我们所认识到的世界做某种重现，或者说解释。为了能解释通，思维创造了很多实体，比如“我”、“时间”、“外部世界”，也创造了很多关系，比如因果关系。这些东西就像之前电脑中的物理定律一样，真实世界不需要物理定律就可以运转，同样地，真实世界不需要思维创造的这些实体和关系也可以正常运转。&lt;/p&gt;
&lt;p&gt;但我们有什么理由认为思维所描绘的世界并不是真实世界呢？&lt;/p&gt;
&lt;p&gt;我们先看因果关系。我们在描述一个事情时，往往需要使用因果关系，因果关系是一种思维语言，它在思维中运行地很好，但在描述外部世界上，完全经不起推敲。&lt;/p&gt;
&lt;p&gt;比如起风了，树在动。我们容易认为起风是原因，树动是结果。但实际是并不是先起风，树才动，二者是同时发生的。换个例子，两个球以相同的速率相反的方向相撞后，弹飞了。那么这个过程中谁是因谁是果呢？风和树的作用也是类似。我们划分因果只是对事情的一种解释，所有同时发生的事情，相互的因果关系是不存在的。那么有时间顺序的呢，如果A在B之前发生，A可以作为B的因吗？比如还是刚才风吹树的例子，我们知道风是有速度的，那么我们是否可以认为风抵达树的过程是风最后吹动树的结果呢？实际上这就和树没关系了，我们可换一个例子。一个小球在没有外界作用力的情况下，它会保持运动状态。那么最初小球是匀速直线运动的，它就会一直持续这个运动。那么我们可以说小球下一个时刻的运动是果，前一个时刻的运动是因吗？如果小球是静止的的，它就一直是静止的。那么我们说它下一个时刻的静止是果，上一个时刻的静止是因吗？因果只是我们认识事情发生过程的一种方式，真实世界中没有因也没有果，更没有一个程序根据因计算果。&lt;/p&gt;
&lt;p&gt;我们看看在思维世界中的因果关系。因为A，所以B。但如果A可以退出B，那么A实际上就是包含B的。也就是说，因为A，所以B，没有得到任何新东西。而外部世界不是这样的，你不能说前一个时刻发生的事情，包含着后一个时刻所发生事情的所有信息，除非你认为所有的都是确定的。但如果所有的都是确定的，因果关系也就失去了意义。&lt;/p&gt;
&lt;p&gt;也许我们对思维为什么会创造出“我”的概念感到疑惑，但这就是思维的运作方式。思维中的所有东西都是它创造出来的，“我”也并不例外。但我们无法真正知道，因为在思维中，思维本身也是这样一个被模拟出来的实体，思维无法真正认识到思维本身。&lt;/p&gt;</content></entry><entry><title>我想写点什么，但不知道会写出什么</title><link href="/wo-xiang-xie-dian-shi-yao-dan-bu-zhi-dao-hui-xie-chu-shi-yao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-xiang-xie-dian-shi-yao-dan-bu-zhi-dao-hui-xie-chu-shi-yao.html</id><summary type="html">&lt;p&gt;有时我会想为什么时常会写一些可能不会有人看的文字。也许以前我是想写给某个人或者某些人看，但慢慢地我发现没有这样的人了。&lt;/p&gt;</summary><content type="html">&lt;p&gt;有时我会想为什么时常会写一些可能不会有人看的文字。也许以前我是想写给某个人或者某些人看，但慢慢地我发现没有这样的人了。&lt;/p&gt;</content></entry><entry><title>下行因果的思考</title><link href="/xia-xing-yin-guo-de-si-kao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/xia-xing-yin-guo-de-si-kao.html</id><summary type="html">&lt;p&gt;“下行因果”一词来自《意识宇宙：心灵现象中的科学真相》一书的15章，文中提到一种“双向因果”关系。&lt;/p&gt;
&lt;p&gt;首先我们来看正常的因果关系。比如路上有一个箱子，本来很平稳的放在那里，但突然起风了，于是箱子滑动了5米。我们可以说因为风在吹动这个箱子，所以箱子会滑动。而风的产生的原因是地球的转动、地球表面受太阳加热程度不同等等。看起来由一个单一的因果链就可以导致箱子滑动这个结果。&lt;/p&gt;
&lt;p&gt;然后我们看看另一种情况，有人推动这个箱子滑动了5米。箱子移动的原因是有人在推，他推箱子的原因是什么？这样就会有分歧。一种观点是把人当作机器人来分析，也就是人内部有一个程序，它接收输入，同时对外输出。他推动箱子是因为当时的外部如此满足了他推箱子的输出，这样的话还是单一的因果链就可以解释。但这样解释的前提是任务人没有自由意志，这是还原论的观点，这里我们不展开说还原论的缺陷。很多人接受不了人是没有自由意志这一观点，如果在人是有自由意志这一前提来分析，情况就要复杂很多。&lt;/p&gt;</summary><content type="html">&lt;p&gt;“下行因果”一词来自《意识宇宙：心灵现象中的科学真相》一书的15章，文中提到一种“双向因果”关系。&lt;/p&gt;
&lt;p&gt;首先我们来看正常的因果关系。比如路上有一个箱子，本来很平稳的放在那里，但突然起风了，于是箱子滑动了5米。我们可以说因为风在吹动这个箱子，所以箱子会滑动。而风的产生的原因是地球的转动、地球表面受太阳加热程度不同等等。看起来由一个单一的因果链就可以导致箱子滑动这个结果。&lt;/p&gt;
&lt;p&gt;然后我们看看另一种情况，有人推动这个箱子滑动了5米。箱子移动的原因是有人在推，他推箱子的原因是什么？这样就会有分歧。一种观点是把人当作机器人来分析，也就是人内部有一个程序，它接收输入，同时对外输出。他推动箱子是因为当时的外部如此满足了他推箱子的输出，这样的话还是单一的因果链就可以解释。但这样解释的前提是任务人没有自由意志，这是还原论的观点，这里我们不展开说还原论的缺陷。很多人接受不了人是没有自由意志这一观点，如果在人是有自由意志这一前提来分析，情况就要复杂很多。&lt;/p&gt;</content></entry><entry><title>《相约星期二》读书笔记</title><link href="/xiang-yue-xing-qi-er-du-shu-bi-ji.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/xiang-yue-xing-qi-er-du-shu-bi-ji.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这本书的内容比较独特，讲的是一个重病在身临终的老教授，给他曾经的一个学生上的最后“一门课”，这门课不属于具体的某个学科，而是涉及人生的几个重要方面，这些内容是教授用一生的经历总结而来的，非常珍贵。&lt;/p&gt;
&lt;p&gt;需要特别注意的是这本书最前边余秋雨的序不建议最开始就阅读，如果真的想读也最好读完了其他内容后最后再看，原因读过自然就清楚了。&lt;/p&gt;
&lt;h2&gt;目标读者&lt;/h2&gt;
&lt;p&gt;对于每个人，这本书都是值得一读的，比较易懂，内容也相对丰富，但不是很深入。还是那句话，重要的思考，而不是阅读本身，不然很容易一无所获，但这本书比较难激发出真正有价值的观点。&lt;/p&gt;
&lt;h2&gt;课程简介&lt;/h2&gt;
&lt;p&gt;这是作者的老教授（莫里）一生中最后的一门课，时间在每周的星期二，地点在他家里，内容是讨论生活的意义。课堂不需要书本，但讨论的题目很多，涉及到爱情、工作、社会、年龄、原谅已经死亡。最后一节课很简短，只有几句话。毕业典礼由葬礼代替了。而这本书就是毕业论文。作者是这本课唯一的学生。&lt;/p&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;作者回想到当初毕业的时候，作者找到最喜欢的莫里教授，把他介绍给了自己的父母。莫里身体比较瘦弱，眼睛却炯炯有神，他告诉作者的父母课上的表现，并说 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这本书的内容比较独特，讲的是一个重病在身临终的老教授，给他曾经的一个学生上的最后“一门课”，这门课不属于具体的某个学科，而是涉及人生的几个重要方面，这些内容是教授用一生的经历总结而来的，非常珍贵。&lt;/p&gt;
&lt;p&gt;需要特别注意的是这本书最前边余秋雨的序不建议最开始就阅读，如果真的想读也最好读完了其他内容后最后再看，原因读过自然就清楚了。&lt;/p&gt;
&lt;h2&gt;目标读者&lt;/h2&gt;
&lt;p&gt;对于每个人，这本书都是值得一读的，比较易懂，内容也相对丰富，但不是很深入。还是那句话，重要的思考，而不是阅读本身，不然很容易一无所获，但这本书比较难激发出真正有价值的观点。&lt;/p&gt;
&lt;h2&gt;课程简介&lt;/h2&gt;
&lt;p&gt;这是作者的老教授（莫里）一生中最后的一门课，时间在每周的星期二，地点在他家里，内容是讨论生活的意义。课堂不需要书本，但讨论的题目很多，涉及到爱情、工作、社会、年龄、原谅已经死亡。最后一节课很简短，只有几句话。毕业典礼由葬礼代替了。而这本书就是毕业论文。作者是这本课唯一的学生。&lt;/p&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;作者回想到当初毕业的时候，作者找到最喜欢的莫里教授，把他介绍给了自己的父母。莫里身体比较瘦弱，眼睛却炯炯有神，他告诉作者的父母课上的表现，并说“你们有一个不同寻常的儿子”。&lt;/p&gt;
&lt;p&gt;“‘米奇，你是最优秀的’，他欣赏着皮包说。然后他拥抱了我。我感觉到他搂在我背上的细细的臂膀。我个子比他高，当他抱住我时，我感到很不自在，感到自己大了许多，似乎我是家长，他是孩子。他问我会不会和他保持联系。我毫不迟疑地回答说，‘当然会。’他往后退去时，我看见他哭了。”&lt;/p&gt;
&lt;p&gt;毕业15年后，莫里被下达了死亡审批，他也很早就有所预感。但即使这样他还是坚持教授的岗位上，直到身体不再允许他这样。&lt;/p&gt;
&lt;p&gt;“我的朋友们，我想你们来这儿是为了上社会心理课的。这门课我已经教了二十年，这是我第一次想说，修这门课有点冒风险，因为我得了绝症。我也许活不到这个学期的结束。如果你们觉得这是个麻烦而想放弃这门课，我完全能够理解。”&lt;/p&gt;
&lt;p&gt;作者并没有履行毕业时的诺言，实际上他不再与莫里联系，虽然十几年间发生了太多事情。直到关于莫里的“教授的最后一门课：他的死亡”的报道（莫里在生命的最后时日把自己的思想记录下来，最后辗转到一个记者手中）被作者看到。作者去看莫里，并答应上这最后一门课。&lt;/p&gt;
&lt;p&gt;之后我直接选取这门课的部分内容，而不再叙事，虽然全程都是非常感人的。&lt;/p&gt;
&lt;h2&gt;第一个星期二--谈论世界&lt;/h2&gt;
&lt;p&gt;莫里还会看关心时事，因为他自己正在遭受痛苦，就更容易想到那些更痛苦的人，并且因为同情而流泪。&lt;/p&gt;
&lt;p&gt;“人生最重要的是学会如何施爱于人，并去接受爱。”
“爱是唯一理性的行为。”&lt;/p&gt;
&lt;p&gt;关于爱，说句题外话，我一直认为爱是人的本能，或者说如果一个人如果抛弃了所有不必要的欲望，那么他所做的每一件事情都是出于爱的。反之我们就很容易得出什么不是爱了。&lt;/p&gt;
&lt;h2&gt;第二个星期二--谈论自怜&lt;/h2&gt;
&lt;p&gt;“那是我悲哀的时刻。我触摸自己的身体，移动手和手指--一切还能动弹的部位--然后为自己失去的感到悲哀。我悲哀这种缓慢、不知不觉的死法，但随后我便停止了哀叹。”&lt;/p&gt;
&lt;p&gt;“只有当你觉得它可怕时，它才可怕，看着自己的躯体慢慢地萎谢的确很可怕，但它也有幸运的一面，因为我可以有时间跟人说再见。不是每个人都这么幸运的。”&lt;/p&gt;
&lt;h2&gt;第三个星期二--谈论遗憾&lt;/h2&gt;
&lt;p&gt;“这是每个人都要担心的，不是吗？如果今天是我的死期，我会怎么样？我们的文化不鼓励你去思考这类问题，所以你只有在临死前才会去想它。 我们所关注的是一些很自私的事情：事业，家庭，赚钱，偿还抵押贷款，买新车，修取暖器--陷在永无止境的琐事里，就为了活下去。因此，我们不习惯退后一步，审视一下自己的生活问，就这些？这就是我需要的一切？是不是还缺点什么？”&lt;/p&gt;
&lt;h2&gt;第四个星期二--谈论死亡&lt;/h2&gt;
&lt;p&gt;“每个人都知道自己要死，可没人愿意相信这一事实。如果我们相信这一事实的话，我们就会作出不同的反应。”&lt;/p&gt;
&lt;p&gt;“意识到自己会死，并时刻作好准备。这样做会更有帮助。你活着的时候就会更珍惜生活。”&lt;/p&gt;
&lt;p&gt;“每天，放一只小鸟在你的肩膀上问，‘是今天吗？我准备好了吗？能生而无悔，死而无憾了？’”&lt;/p&gt;
&lt;p&gt;“一旦你学会了怎样去死，你也就学会了怎样去活。”&lt;/p&gt;
&lt;p&gt;“我们大多数人都生活在梦里。我们并没有真正地在体验世界，我们处于一种浑浑噩噩的状态，做着自以为该做的事。”&lt;/p&gt;
&lt;p&gt;“去外表的尘埃，你便看到了生活的真谛。当你意识到自己快要死去时，你看问题的眼光也就大不一样了。”&lt;/p&gt;
&lt;p&gt;“事实上，如果你真的在听小鸟的说话，如果你能接受随时都会死去的事实--你就不会像现在这样耽于抱负了。”&lt;/p&gt;
&lt;p&gt;“你为此而付出时间和精力的事--你所做的工作--也许就不再显得那么重要了。你也许会让出空间来满足精神上的需求。”&lt;/p&gt;
&lt;p&gt;“我们过多地追求物质需要，可它们并不能使我们满足。我们忽视了人与人之间互相爱护的关系，我们忽视了周围的世界。”&lt;/p&gt;
&lt;h2&gt;第五个星期二--谈论家庭&lt;/h2&gt;
&lt;p&gt;“事实上，如果没有家庭，人们便失去了可以支撑的根基。我得病后对这一点更有体会。如果你得不到来自家庭的支持。爱抚。照顾和关心，你拥有的东西便少得可怜，爱是至高无上的，正如我们的大诗人奥登说的那样，‘相爱或者死亡’。”&lt;/p&gt;
&lt;p&gt;“假设我离了婚，或一个人生活，或没有孩子。这疾病--我所经受的这种疾病--就会更加难以忍受。我不敢肯定我是否应付得了它。当然，会有人来探望的，朋友，同事。但他们和不会离去的家人是不一样的。这跟有一个始终关心着你、和你形影不离的人不是一回事。这就是家庭的部分涵义不仅仅是爱，而且还告诉别人有人守护着你。这是我母亲去世时我最想得到的--我称它为‘心理安全’--知道有一个家在守护着你。只有。家庭能给予你这种感觉。金钱办不到。名望办不到。”&lt;/p&gt;
&lt;h2&gt;第六个星期二--谈论感情&lt;/h2&gt;
&lt;p&gt;“是的， 超脱自我。这非常重要--不仅对我这个快要死的人是这样，对像你这样完全健康的人也如此。要学会超脱。”&lt;/p&gt;
&lt;p&gt;“但超脱并不是说不投入到生活中去。相反，你应该完完全全地投入进去。然后你才走得出来。”&lt;/p&gt;
&lt;p&gt;“接受所有的感情--对女人的爱恋，对亲人的悲伤，或像我所经历的：由致命的疾病而引起的恐惧和痛苦。如果你逃避这些感情--不让自己去感受。经历--你就永远超脱不了，因为你始终心存恐惧。你害怕痛苦，害怕悲伤，害怕爱必须承受的感情伤害。可你一旦投入进去，沉浸在感情的汪洋里，你就能充分地体验它，知道什么是痛苦，什么是悲伤。只有到那时你才能说，‘好吧，我已经经历了这份感情，我已经认识了这份感情，现在我需要超脱它。’”&lt;/p&gt;
&lt;p&gt;作者在想，“日常生活中是多么地需要这样的感情处理。我们常感到孤独，有时孤独得想哭，但我们却不让泪水淌下来，因为我们觉得不该哭泣。有时我们从心里对伴侣涌起一股爱的激流，但我们却不去表达，因为我们害怕那些话语可能会带来的伤害。”&lt;/p&gt;
&lt;p&gt;莫里的态度截然相反：“打开水龙头，用感情来冲洗。它不会伤害你。它只会帮助你。如果你不拒绝恐惧的进入，如果你把它当作一件常穿的衬衫穿上，那么你就能对自己说，‘好吧，这仅仅是恐惧，我不必受它的支配。我能直面它。’对孤独也一样：体会它的感受，让泪水流淌下来，细细地品味--但最后要能说，‘好吧，这是我的孤独一刻，我不怕感到孤独，现在我要把它弃之一旁，因为世界上还有其它的感情让我去体验。’”&lt;/p&gt;
&lt;h2&gt;第七个星期二--谈论对衰老的恐惧&lt;/h2&gt;
&lt;p&gt;“随着年龄的增加，你的阅历也更加丰富。如果你停留在二十二岁的年龄阶段，你就永远是二十二岁的那般浅薄。要知道，
衰老并不就是衰败。它是成熟。接近死亡并不一定是坏事，当你意识到这个事实后，它也有十分积极的一面，你会因此而活得更好。”&lt;/p&gt;
&lt;p&gt;“你从来没有听人这么说过，‘但愿我已经六十五岁了。’你知道这反映了什么？生活的不满足，生活的不充实，生活的无意义。因为你一旦找到了生活的意义，你就不会想回到从前去。你想往前走。你想看得更多，做得更多。你想体验六十五岁的那
份经历。”&lt;/p&gt;
&lt;p&gt;“如果你一直不愿意变老，那你就永远不会幸福，因为你终究是要变老的。”&lt;/p&gt;
&lt;p&gt;“老年人不可能不羡慕年轻人，但问题是你得接受现状并能自得其乐。这是你三十几岁的好时光。我也有过三十几岁的岁月，
而我现在是七十八岁。你应该发现你现在生活中的一切美好。真实的东西，回首过去会使你产生竞争的意识，而年龄是无法竞争的。我不会羡慕你的人生阶段--因为我也有过这个人生阶段。”&lt;/p&gt;
&lt;h2&gt;第八个星期二--谈论金钱&lt;/h2&gt;
&lt;p&gt;“我们国家提倡灌输的教育形式，你知道他们是怎样灌输的吗，他们对你一遍又一遍地重复，这就是我们国家的做法。拥有得越多越好。钱越多越好。财富越多越好。商业行为也是越多越好。越多越好。越多越好。我们反复地对别人这么说--别人又反复地对我们这么说--一遍又一遍，直到人人都认为这是真理。大多数人会受它迷惑而失去自己的判断能力。”&lt;/p&gt;
&lt;p&gt;“无论我生活在哪里，我都会遇到一些对新的东西充满了占有欲的人，想拥有新的汽车，想拥有新的财产，想拥有新的玩具。然后沾沾自喜地向你炫耀：‘猜我得到了什么？猜我得到了什么？’”&lt;/p&gt;
&lt;p&gt;“你知道我对此是怎么解释的？这些人都渴望得到爱，但又得不到，于是就接受了这些替代品。他们乐于接受物质的东西，期望能得到类似于拥抱的感情回报，但这是行不通的。你无法用物质的东西去替代爱，善良、温柔或朋友间的亲情。钱无法替代温情，权力也无法替代温情，我能告诉你，当我坐在这儿等待死亡时，当你最需要这份温情时，金钱或权力都无法给予你这份感情，不管你拥有多少财富或权势。”&lt;/p&gt;
&lt;p&gt;“这个社会在想要什么和需要什么这个问题上是很感困惑的，你需要的是食物，而你想要的却是巧克力圣代。你得对自己诚实。你并不需要最新的跑车，你并不需要最大的房子。实际上，它们不能使你感到满足。”&lt;/p&gt;
&lt;p&gt;“你知不知道真正使你感到满足的是什么吗？给予他人你应该给予的东西。我不是指金钱，我是指你的时间，你的关心，你的闲谈。这并不难。你给予了别人，于是你开始赢得别人的尊敬。你不需要有非凡的才能，就会发现新的生活价值，因为人们需要你。”&lt;/p&gt;
&lt;p&gt;作者：“还记得我说过的关于寻求有意义的生活的话吗？我曾经把它写了下来；但现在我已经能背了：把自己奉献给爱，把自己奉献给社区，把自己奉献给能给予你目标和意义的创造。”&lt;/p&gt;
&lt;p&gt;“如果你想对社会的上层炫耀自己，那就打消这个念头，他们照样看不起你，如果你想对社会的底层炫耀自己，也请打消这个念头，他们只会忌妒你。身份和地位往往使你感到无所适从。唯有一颗坦诚的心方能使你悠然地面对整个社会。”&lt;/p&gt;
&lt;p&gt;“我当然在受罪。但给予他人能使我感到自己还活着。汽车和房子不能给你这种感觉，镜子里照出的模样也不能给你这种感觉。只有当我奉献出了时间，当我使刀"些悲伤的人重又露出笑颜，我才感到我仍像以前一样的健康。只要你做的是发自内心的，你过后就不会感到失望，不会感到妒忌，也不会计较别人的回报。否则，你就要患得患失。”&lt;/p&gt;
&lt;h2&gt;第九个星期二--谈论爱的永恒&lt;/h2&gt;
&lt;p&gt;“我决定了我的碑文怎么写。我想这么写：一个终生的教师。”&lt;/p&gt;
&lt;p&gt;“我在和你说话。我想的只有你。”&lt;/p&gt;
&lt;p&gt;“问题的部分症结，在于他们活得太匆忙了，他们没有找到生活的意义所在，所以忙着在寻找。他们想到了新的车子，新的房子，新的工作。但过后他们发现这些东西同样是空的，于是他们重又奔忙起来。”&lt;/p&gt;
&lt;p&gt;“有人想超我的车时--那还是在我能开车的时候--我就举起手，似乎要作出不太友善的手势，但随后我挥挥手，一笑了之。你不对他举起手指，而是让他过去，你就能一笑了之。实际上，我不必那么急着开我的车。我情愿把精力放在与人的交流上。”&lt;/p&gt;
&lt;h2&gt;第十个星期二--谈论婚姻&lt;/h2&gt;
&lt;p&gt;“婚姻。几乎所有我认识的人都对婚姻感到困惑。有的不知怎样走进去，有的不知怎样走出来。我们这一代人似乎想挣脱某种义务的束缚，把婚姻视作泥潭中的鳄鱼。我常常出席别人的婚礼，向新婚夫妇贺喜祝福。然而几年以后，当那位新郎与另一位他称作朋友的年轻女子同坐在饭店里时，我只会稍感惊讶而已。‘你知道，我已经和某某分居了……’他会对你如是说。”&lt;/p&gt;
&lt;p&gt;“在这个社会，人与人之间产生一种爱的关系是十分重要的， 因为我们文化中的很大一部分并没有给予你这种东西。可是现在这些可怜的年轻人，要么过于自私而无法和别人建立真诚的恋爱关系，要么轻率地走进婚姻殿堂，然后六个月后又匆匆地逃了出来。 他们并不清楚要从伴侣那儿得到什么。他们连自己也无法认清--又如何去认识他们要嫁娶的人呢？这很令人悲哀，因为一个爱人对你的生活是非常重要的。你会意识到这一点，尤其当你处于我的境地时。朋友对你也很重要，但当你咳得无法入睡，得有人整夜坐着陪伴你、安慰你、帮助你时，朋友就无能为力了。”&lt;/p&gt;
&lt;p&gt;“我对婚姻有这样一个体会，你通过婚姻可以得到检验。你认识了自己，也认识了对方，知道了你们彼此是否合得来。”&lt;/p&gt;
&lt;p&gt;“爱情和婚姻还是有章可循的：如果你不尊重对方，你们的关系就会有麻烦；如果你不懂怎样妥协，你们的关系就会有麻烦； 如果你们彼此不能开诚布公地交流，你们的关系就会有麻烦；如果你们没有共同的价值观，你们同样会有麻烦。你们必须有相同的价值观。这一价值观里最重要的，是你们对婚姻的重要性的信念。”&lt;/p&gt;
&lt;p&gt;“我个人认为，婚姻是一件很重要的事情，如果你没去尝试，你就会失去很多很多。”&lt;/p&gt;
&lt;p&gt;“相爱或者死亡。”&lt;/p&gt;
&lt;h2&gt;第十一个星期二--谈论我们的文化&lt;/h2&gt;
&lt;p&gt;“人只有在受到威胁时才变坏，而这一威胁正是来自我们的文明社会，来自我们的经济制度。即使有工作的人也会受到威胁，因为他会担心失去它。当你受到威胁时，你就会只为自己的利益考虑，你就会视金钱为上帝。这就是我们文化的一部分。这就是为什么我不能接受它。”&lt;/p&gt;
&lt;p&gt;“这就是我说的你应该建立一个自己的小文化，我并不是让你去忽视这个社会的每一条准则。比方说，我不会光着身子去外面转悠；我也不会去闯红灯。在这类小事情上我能遵纪守法。但在大问题上--如何思想，如何评判--你必须自己选择。你不能让任何一个人--或任何一个社会--来替你作出决定。”&lt;/p&gt;
&lt;p&gt;“女人拼命想苗条，男人拼命想富有，也是同样的道理。这都是我们的文化要你相信的。别去相信它。”&lt;/p&gt;
&lt;p&gt;“每个社会都有它自己的问题，我认为逃避并不是解决的方法。你应该为建立自己的文化而努力。”&lt;/p&gt;
&lt;p&gt;“不管你生活在哪儿，人类最大的弱点就是缺乏远见。我们看不到自己的将来。其实，我们应该看到自己的潜能，让自己尽量去适应各种发展和变化。但如果你的周围尽是那些利欲熏心的人，那么结局便是一小部分的人暴富起来，军队的任务是防止贫穷的人起来造反，抢夺他们的财富。”&lt;/p&gt;
&lt;p&gt;“问题是，我们不相信我们都是同样的人。白人和黑人。天主教徒和新教徒。男人和女人。如果我们彼此不觉得有差异，我们
就会乐意加入人类的大家庭， 就会像照顾自己的小家一样去关心那个大家庭。”&lt;/p&gt;
&lt;p&gt;“相信我，当你快要死的时候，你会认识到这是对的。我们都有同样的开始--诞生--我们也有同样的结局--死亡。因此，我们怎么会有大的区别呢？”&lt;/p&gt;
&lt;p&gt;“投入到人类的大家庭里去。投入到人的感情世界里去。建立一个由你爱的人和爱你的人组成的小社会。”&lt;/p&gt;
&lt;p&gt;“在生命的起点，当我们还是婴儿时，我们需要别人活着，对不对？在生命的终点，当你像我现在这样时，你也需要别人活着， 是吗？可还有个秘密：在生命的中途，我们同样需要别人活着。”&lt;/p&gt;
&lt;h2&gt;第十二个星期二--谈论原谅&lt;/h2&gt;
&lt;p&gt;“临死前先原谅自己，然后原谅别人。”&lt;/p&gt;
&lt;p&gt;“恨和固执都是毫无意义的。这种情绪--他叹了口气--这种情绪让我抱憾终身。自负。虚荣。我们为什么要这么做呢？”&lt;/p&gt;
&lt;p&gt;“我们不仅需要原谅别人，我们也需要原谅自己。原谅自己应该做而没有做的事。你不应该陷在遗憾的情绪中无法自拔，这对你是没有益处的，尤其是处在我这个阶段。我一直希望自己工作得更出色些，希望能多写几本书。我常常为此而自责。现在我发现这毫无帮助。跟它和解。跟自己和解。跟你周围的人和解。”&lt;/p&gt;
&lt;h2&gt;第十三个星期二--谈论完美的一天&lt;/h2&gt;
&lt;p&gt;“千万别把我烧过了头。”&lt;/p&gt;
&lt;p&gt;“我们很害怕看见死亡，我那天看了一本书。里面说有个人在医院里死去时，他们立即用被单盖住他的头，把尸体推人了倾卸槽。他们迫不及待地要让它从面前消失，好像死亡会传染开似的。它不会传染的，这你知道。死亡跟生命一样自然。它是我们生活的一部分。”&lt;/p&gt;
&lt;p&gt;“那是一种最不可思议的感觉。一种既无奈又平静的感觉。我想到了上个星期做过的一个梦：我走过一座桥，进入了一个陌生的地方。我已准备好去任何一个地方。我没有去。但我感觉到我已经能够去了。这就是我们都在寻求的：平静地面对死亡。如果我们知道我们可以这样去面对死亡的话，那么我们就能应付最困难的事情了。”&lt;/p&gt;
&lt;p&gt;“最困难的是与生活讲和。”&lt;/p&gt;
&lt;p&gt;“死是很自然的，我们之所以对死亡大惊小怪，是因为我们没有把自己视作自然的一部分。我们觉得既然是人就得高于自然，我们并不高于自然。有生就有死。”&lt;/p&gt;
&lt;p&gt;“要我们彼此相爱，并把它珍藏在心里，我们即使死了也不会真正地消亡。你创造的爱依然存在着。所有的记忆依然存在着。你仍然活着--活在每一个你触摸过爱抚过的人的心中。死亡终结了生命，但没有终结感情的联系。”&lt;/p&gt;
&lt;p&gt;“你一旦涉足这些重大的问题，你就没法抽身离开了。在我看来，它们离不开爱。责任，精神，意识等范畴。今天我如果是个健康人，这些还将是我要去思考的问题。它们将伴我一生。”&lt;/p&gt;
&lt;p&gt;“如果我有完全健康的一天，我会早晨起床，进行晨练，吃一顿可口的。有甜面包卷和茶的早餐。然后去游泳，请朋友们共进午餐，我一次只请一两个，于是我们可以谈他们的家庭，谈他们的问题，谈彼此的友情。然后我会去公园散步，看看自然的色彩，看看美丽的小鸟，尽情地享受久违的大自然。晚上，我们一起去饭店享用上好的意大利面食，也可能是鸭子--我喜欢吃鸭子--剩下的时间就用来跳舞。我会跟所有的人跳，直到跳得精疲力竭。然后回家，美美地睡上一个好觉。就这些。”&lt;/p&gt;
&lt;p&gt;“我知道不能和你爱的人在一起是痛苦的。但你应该平静地看待他的愿望。也许他是不想烦扰你的生活。也许他是承受不了那份压力。我要每一个我所认识的人继续他们自己的生活--不要由于我的死而毁了它。你有过和弟弟在一起的美好时光，但你不再拥有这份感情了。你想把它要回来。你从未想让它结束。可这就是生活的一部分。结束，重新开始，结束，重新开始。”&lt;/p&gt;
&lt;p&gt;“在商业上，人们通过谈判去获胜。他们通过谈判去得到他们要的东西，但爱却不同。爱是让你像关心自己一样去关心别人。”&lt;/p&gt;
&lt;h2&gt;第十四个星期二--道别&lt;/h2&gt;
&lt;p&gt;“我今天……不太好……”&lt;/p&gt;
&lt;p&gt;摘录原文：&lt;/p&gt;
&lt;p&gt;他无力地拍拍我的手，仍把它按在胸口。“这……就是在说……再见……”他的呼吸很微弱，吸进，呼出，我能感觉到他的胸腔在上下起伏。他这时正眼望着我。“爱……你，”他说。我也爱你，教练。&lt;/p&gt;
&lt;p&gt;我眨眨眼睛忍住了泪水，他看见后咂了咂嘴唇，扬起了眉毛。我希望这是老教授心满意足的开心一刻：他最终还是叫我哭了。
“行了，”他低声说。&lt;/p&gt;
&lt;h2&gt;毕业&lt;/h2&gt;
&lt;p&gt;摘录原文：&lt;/p&gt;
&lt;p&gt;他不想有凄惨的时刻，不想让人看见他断气的情形从而抹不去这可怕的记忆，就像他无法抹去那份宣告母亲死亡的电报和陈尸所里父亲的尸体留给他的可怕记忆一样。&lt;/p&gt;
&lt;p&gt;我相信他知道他是在自己的床上；他的书，他的笔记，他的小木槿都在他的身边，他想安宁地离去，他确实走得很安宁。&lt;/p&gt;
&lt;h2&gt;结尾&lt;/h2&gt;
&lt;p&gt;摘录原文：&lt;/p&gt;
&lt;p&gt;我有时回头看看以前的那个我，那个还没有重新找到莫里时的我。我想跟他交谈。我想告诉他生活中应该追求什么，应该避免什么样的错误。我想让他感情更开放些，不要受商业价值观的诱惑，去倾听你所爱的人的话语，就像你是在最后一次倾听他们的说话那样。我们没有一个人能擦掉生活过的痕迹，同样也不能重新再生活一次。然而，如果说莫里·施瓦茨教授教会了我什么的话，那便是：生活中没有“来不及”这个词。他直到说再见的那一天还在改变着自己。&lt;/p&gt;
&lt;p&gt;莫里逝世后不久，我在西班牙见到了我弟弟。我们进行了一次长谈。我对他说我尊重他的距离感，我所希望的是能和他保持联系--不仅是过去，还有现在--让我的生活中尽量拥有他。“你是我唯一的弟弟，"我说。"我不想失去你。我爱你。”我以前从来没有对他说过这样的话。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;我把莫里说的大部分话摘录在上边的每一个星期二。我不想再对这些话作任何评价，这是对生命的负责，对与错都不再重要。我们应该知道一个人临终更关注的是什么，这也是每天需要关注的事情。&lt;/p&gt;</content></entry><entry><title>写在辞职一周年的只言片语</title><link href="/xie-zai-ci-zhi-yi-zhou-nian-de-zhi-yan-pian-yu.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/xie-zai-ci-zhi-yi-zhou-nian-de-zhi-yan-pian-yu.html</id><summary type="html">&lt;p&gt;转眼间已经来到九月。我记得去年的这个时候我在做什么，我在笔记里用表格做了一个日历，然后每过一天划一天，算着离最后工作日还有几天。上一次使用手工倒计还是在小学临近毕业的时候，因为按部就班地生活终于要发生变化了，不再是一年级升到二年级，或者五年级升到六年级，我不知道以后的日子会怎么样，算是一种期待吧。但在那之后，中考、高考、大学毕业，我都不再对这种倒计时感兴趣，也没感觉事情发生了多少变化，我也想着日子是不是就这样平淡地过下去了。&lt;/p&gt;
&lt;p&gt;我算是比较优柔寡断的人，在断断续续考虑了一年之后，我才最终告别这份工作。至于原因，我和不同的人，说了多个版本，比如工作压力太大，比如对工作内容没兴趣，比如感觉体现不出自己的价值，比如不喜欢北京这座城市等等。但这些都不是主要原因，甚至不是原因。真正的原因只有一个，就是所有的同事，都没有过着我所向往的生活，我必须得走，而且走得越晚我需要付出的代价就越大。但当时我也并不知道自己想要什么样的生活，这样风险就比较大，这样是我一直犹豫的一个原因。另一个原因是因为最后的一年多，我心思一直不在工作上，很多事情也就穷于应付，出了不少问题，心态就变得很差，这又反过来影响我理性的思考。最后我终于把心态调整过来了，这其实算是比较困难的事情，然后辞职也就顺理成章了。&lt;/p&gt;
&lt;p&gt;但并不是辞职后，一切问题都解决了。我可以很容易地将自己的生活描绘得很好 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;转眼间已经来到九月。我记得去年的这个时候我在做什么，我在笔记里用表格做了一个日历，然后每过一天划一天，算着离最后工作日还有几天。上一次使用手工倒计还是在小学临近毕业的时候，因为按部就班地生活终于要发生变化了，不再是一年级升到二年级，或者五年级升到六年级，我不知道以后的日子会怎么样，算是一种期待吧。但在那之后，中考、高考、大学毕业，我都不再对这种倒计时感兴趣，也没感觉事情发生了多少变化，我也想着日子是不是就这样平淡地过下去了。&lt;/p&gt;
&lt;p&gt;我算是比较优柔寡断的人，在断断续续考虑了一年之后，我才最终告别这份工作。至于原因，我和不同的人，说了多个版本，比如工作压力太大，比如对工作内容没兴趣，比如感觉体现不出自己的价值，比如不喜欢北京这座城市等等。但这些都不是主要原因，甚至不是原因。真正的原因只有一个，就是所有的同事，都没有过着我所向往的生活，我必须得走，而且走得越晚我需要付出的代价就越大。但当时我也并不知道自己想要什么样的生活，这样风险就比较大，这样是我一直犹豫的一个原因。另一个原因是因为最后的一年多，我心思一直不在工作上，很多事情也就穷于应付，出了不少问题，心态就变得很差，这又反过来影响我理性的思考。最后我终于把心态调整过来了，这其实算是比较困难的事情，然后辞职也就顺理成章了。&lt;/p&gt;
&lt;p&gt;但并不是辞职后，一切问题都解决了。我可以很容易地将自己的生活描绘得很好，看起来不存在任何问题，但事实显然不是这样的，这也是我一直想说的事情。我一个人来到威海时，还是不清楚自己想要什么样的生活，并且面临着其他种种问题，和度假是完全不同的。最开始的几个月确实很好，因为我喜欢海，几乎天天出去玩，或者听着歌在海边走，或者在草坪上荡秋千。然后我开始喜欢看一部书，再然后听一部有声小说，再然后看游戏视频，再然后做视频和写软件，再然后混迹于贴吧和 QQ 群，只要有想做的事情，就总会感觉不错。甚至我不担心收入的问题，至少不用那么早就开始考虑。&lt;/p&gt;
&lt;p&gt;直到我发现再难找到想做的事情了。每天白天感觉非常无聊，一会看看手机，一会看看电脑，偶尔出去走走，也没什么意思。到了晚上都想明天做什么呢，好像没什么想做的了，那么下个月呢，明年呢。我开始绞尽脑汁地想自己还有什么想做的事情是可以排到日程的，我用各种方式想，比如把事情根据感官分成几类，然后想自己还有什么想看的，想听的，想吃的，想喝的等等。但想来想去，都没找到那么一件事，能让我感觉如果这件事不做就死了一定会遗憾。当然因为我还活着，所以我不可能什么事情都不做，但我知道那些事情都不是我认为值得做的，或者说都是些打发时间的事情。&lt;/p&gt;
&lt;p&gt;然后又回到了那些棘手的问题，比如人生的目的是什么。在之前我认为的答案是每个人的目的各有不同，但总结起来就是体验自己想体验的东西。但这问题就来了，如果我认为自己没有更多东西想体验了，但人生依然继续，那如何是好。这里边必然有问题，想必我又错了。不过这个问题能浮现出来，也是非常难得的。&lt;/p&gt;
&lt;p&gt;今年的六月发生了一件非同寻常的事情。我很难用通俗的语言讲述发生了什么，但这件事对我的影响还是比较大的。在当时我认为这解决了我的所有问题，实际上并没有，但至少解决了一部分。简单说，一般的噪音、疼痛等外在的干扰不能影响我的心情了，或者说我真切地感受到我的心情是由我自己决定的，而不是由外在的事物决定的，这算是一个突破。&lt;/p&gt;
&lt;p&gt;但不久之后，我发现当时自己的一个信念是有问题的，然后这个信念瓦解掉后，一些问题又复现了。最主要的问题还是之前的那个，无事可做很无聊。当时我反复思考后，认为这是执着的问题，我对生死的执着，导致了这样的问题。但随后我就发现执着这个问题是很难解决的，就像死胡同一样。这个问题过了稍长的事情才再次有了松动，那是因为我对人生的目的这个问题有了新的答案。这个答案一点也不新鲜，我以前也看到过，就是人生是为了学习爱。以前我因为这个答案过于宗教化而不接受，但后来我思来想去，再综合若干信息，发现是有道理的。当我认同了这个答案时，一些问题出现了转机，比如我知道我还活着是因为我还没有学到该学的，事实也是如此。最简单地，再几乎完全自由的情况，我依然没能做到让自己幸福，在爱自己这方面，我依然有不少路要走，而爱别人依然建立在爱自己的基础上。同时我又发现之前我认为的执着并不是问题，我忘了这是第几次进入那个圈套。&lt;/p&gt;
&lt;p&gt;那么现在问题就可以具体化了，如何能在自己找不到想做的事情的情况下，让自己过得幸福。看起来一种方式是不断地找想做的事情，但之前我已经自己验证了这种方式不靠谱，至少对我来说确实没有那么多事情可找。另一种方式，就是如何能让自己在不依赖所做事情的前提下，过得幸福。这个问题虽然具体，但也不是那么好解决，我现在依然在尝试解决。值得高兴的是，我发现自己已经有了一些突破。但这个问题能否解决掉，目前还是未知数。&lt;/p&gt;
&lt;p&gt;因为这个问题已经足够具体化，不像之前执着那个问题那么难以下手，我感觉不应该再横生枝节。那么如果这个问题解决了，之后会怎样呢？这个问题比较吸引我，但现在我还不是完全确定会发生什么，但不管是哪一种，都不会太差。&lt;/p&gt;
&lt;p&gt;总体来说，这一年能披荆斩棘走到这里，我是非常满意的。我现在的生活距离我认为的幸福生活还是有一些差距的，但至少我已经不迷茫了，并且能感觉到自己的生活是越来越好的。以后的生活也许不会一帆风顺，但我感觉真正棘手的问题已经解决了大半了。&lt;/p&gt;</content></entry><entry><title>写在辞职一周年的只言片语——简略版</title><link href="/xie-zai-ci-zhi-yi-zhou-nian-de-zhi-yan-pian-yu-jian-lue-ban.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/xie-zai-ci-zhi-yi-zhou-nian-de-zhi-yan-pian-yu-jian-lue-ban.html</id><summary type="html">&lt;p&gt;还有几天时间就到了辞职一周年纪念日了，我一直想仔细总结些什么，但每次想写时都会感觉有些词穷。这一年是我有生以来过得最自由的一年，我可以用无数的词语来描绘它的美好。但也并非那么美好，我不是来度假的，而是抱着一种决绝的心态来解决问题的。这一年似乎没有发生什么值得一提的大事，但我知道我改变了很多。我依然没有过着自己认为理想的生活，但已经非常接近了。&lt;/p&gt;</summary><content type="html">&lt;p&gt;还有几天时间就到了辞职一周年纪念日了，我一直想仔细总结些什么，但每次想写时都会感觉有些词穷。这一年是我有生以来过得最自由的一年，我可以用无数的词语来描绘它的美好。但也并非那么美好，我不是来度假的，而是抱着一种决绝的心态来解决问题的。这一年似乎没有发生什么值得一提的大事，但我知道我改变了很多。我依然没有过着自己认为理想的生活，但已经非常接近了。&lt;/p&gt;</content></entry><entry><title>欣赏文学作品的一个误区——欣赏不是推理</title><link href="/xin-shang-wen-xue-zuo-pin-de-yi-ge-wu-qu-xin-shang-bu-shi-tui-li.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/xin-shang-wen-xue-zuo-pin-de-yi-ge-wu-qu-xin-shang-bu-shi-tui-li.html</id><summary type="html">&lt;p&gt;近日喜读《红楼梦》，偶有不懂之处也到处查找资料，也看了些周边书籍。越来越感觉在文学作品的欣赏上普遍存在着一个误区。也并非只在文字作品上，音乐、绘画等艺术作品皆是如此。&lt;/p&gt;
&lt;p&gt;通常人们认为欣赏的前提是了解，了解越深越有助于欣赏，我倒不这么看。基本的了解自然是必要的，不理解歌词，很难欣赏一首歌曲，不识得画中之物，也很难欣赏一幅画。但真正懂得欣赏音乐的人，往往不是音乐家，真正懂得欣赏绘画的人，也往往不是画家。&lt;/p&gt;
&lt;p&gt;当我心情惆怅的时候，恰好听到一首缠绵悱恻的曲子，我不需要清楚它是什么曲调、什么节拍，甚至不需要了解它是什么乐器演奏的，但我知道自己在欣赏它，甚至将它作为了自己的一部分。如果一个作曲家也听到了这首曲子，这曲子的细节瞬间转化成了技术性的信息，反而影响欣赏本身。当然作曲家和常人相比，在欣赏音乐上会有天赋，也会注意到那些常人关注不到的细节，但就像美食家经常去品尝各路美食，最后品出来的又有多少滋味呢。&lt;/p&gt;
&lt;p&gt;但音乐作品又和文学作品有所不同。我们更能容忍不同人对同一首歌不同的感受和评价，也很少争论某一句歌词到底表达了怎样的含义。但到文学作品上，经常有人问这样的问题：“作者这句话是想表达什么？”尤其是像《红楼梦》这样的古典巨作，经常有人揣度作者每一句话的含义，并因为意见有分歧而吵闹。&lt;/p&gt;
&lt;p&gt;我想起语文试卷的阅读题经常有类似的问题：“这篇文章的中心思想是什么？作者这句话为什么这么写？这句话表达了作者怎样的心情 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;近日喜读《红楼梦》，偶有不懂之处也到处查找资料，也看了些周边书籍。越来越感觉在文学作品的欣赏上普遍存在着一个误区。也并非只在文字作品上，音乐、绘画等艺术作品皆是如此。&lt;/p&gt;
&lt;p&gt;通常人们认为欣赏的前提是了解，了解越深越有助于欣赏，我倒不这么看。基本的了解自然是必要的，不理解歌词，很难欣赏一首歌曲，不识得画中之物，也很难欣赏一幅画。但真正懂得欣赏音乐的人，往往不是音乐家，真正懂得欣赏绘画的人，也往往不是画家。&lt;/p&gt;
&lt;p&gt;当我心情惆怅的时候，恰好听到一首缠绵悱恻的曲子，我不需要清楚它是什么曲调、什么节拍，甚至不需要了解它是什么乐器演奏的，但我知道自己在欣赏它，甚至将它作为了自己的一部分。如果一个作曲家也听到了这首曲子，这曲子的细节瞬间转化成了技术性的信息，反而影响欣赏本身。当然作曲家和常人相比，在欣赏音乐上会有天赋，也会注意到那些常人关注不到的细节，但就像美食家经常去品尝各路美食，最后品出来的又有多少滋味呢。&lt;/p&gt;
&lt;p&gt;但音乐作品又和文学作品有所不同。我们更能容忍不同人对同一首歌不同的感受和评价，也很少争论某一句歌词到底表达了怎样的含义。但到文学作品上，经常有人问这样的问题：“作者这句话是想表达什么？”尤其是像《红楼梦》这样的古典巨作，经常有人揣度作者每一句话的含义，并因为意见有分歧而吵闹。&lt;/p&gt;
&lt;p&gt;我想起语文试卷的阅读题经常有类似的问题：“这篇文章的中心思想是什么？作者这句话为什么这么写？这句话表达了作者怎样的心情？”将几乎所有的焦点集中在文章或者作者本人身上，而不是读者身上。难道我们更应该关注的不是：“你是怎么理解文中这句话的？你对这段话有怎样的感受？你为什么喜欢或者不喜欢这篇文章？”但一旦如此，问题的答案就不唯一了，这会给阅卷带来很大的困难，不可取。当然我的重点不再这里，我想说的是，做语文试卷的阅读题，甚至读语文课本的文章，基本都算不得欣赏，而是推理。欣赏和推理的区别，主要在于前者没有固定的模式或者答案，而后者有。&lt;/p&gt;
&lt;p&gt;我并不是说推理不可取，很多文学作品恰是用来推理的，比如悬疑小说。《红楼梦》自然也可以用来推理，其乐无穷，但欣赏却是另外的一个过程。我喜欢欣赏《红楼梦》，却不喜欢推理。我对作者为什么写某句话不甚感兴趣，因为对任何一句话，我都可以有自己的理解。我的理解可能和作者的原意有出入，但这也正是欣赏的美妙，欣赏是没有对错之分的。&lt;/p&gt;
&lt;p&gt;我又想起曾经出现在语文试卷上的一篇文章。文中的父亲听了几十年的《送别》，一直听成“长城外，古道边”，因为自己曾经住在长城外，每次听时都感慨颇深，直到某天儿子指歌词给他说是“长亭外”。但这里是“长城”还是“长亭”真的重要吗，听作“长城”时感慨万千，知是“长亭”后顿感无味。不知将这篇文章选入考题的老师，是否也为对错和欣赏无关而感慨呢。&lt;/p&gt;
&lt;p&gt;有时我读一篇文章时，开始时按自己的理解感觉美妙无比，看到后边才发现原来是误解了作者而顿感无味。但我想真正会欣赏文章的人，仍然不会放弃自己之前的想法，即使它并不是作者的意图，尽管是“错”的。甚至可以只取文章的前一部分，自己续后半部分，只因为不喜欢作者安排的那个结局。这才是欣赏文学作品，而不是推理文学作品。&lt;/p&gt;
&lt;p&gt;对《红楼梦》，我的态度也是一样的。《红楼梦》之美除了在已流传下来的文字，还在于它恰好是不完整的。也正是因为它的不完整，更多人对它感兴趣，很多人为红楼不全遗憾，我却为此高兴。一个已完成的文学作品是死的，即使它很精彩，但很少有人会狗尾续貂，或者砍掉一截然后替换成自己的文字。但可以想到，即使是百年之后，依然会有人续《红楼梦》。只有这样一部残缺的作品，才可能在几百年甚至更长的时间持续地保持活力，这活力是对它理解不同的人所注入的。&lt;/p&gt;
&lt;p&gt;我不希望《红楼梦》的谜团全部被破解，幸运的是现在看这也是不可能的。因为可以料到，一旦人们公认《红楼梦》再无秘密，对结局也再无分歧，《红楼梦》也就死了。人们依然会认为它是一部伟大的名著，但更多的是将其束之高阁，偶尔读之，却很难迷之。借《红楼梦》我们可以看到多数人对欣赏文学作品的态度，对是重于美的。很多人乐于争论一句话是这个含义还是那个含义，或逻辑推理，或寻找证据，却无法真的静下心来欣赏这句话。&lt;/p&gt;
&lt;p&gt;昨天晚上我出去散步时不理解《红楼梦》中某个情节，上网查了几篇文章也还感觉逻辑不通，正漫无目的地走着，突然想起《红楼梦》中的一句诗而潸然泪下，我竟说不出是因为什么。今天我再回想之前的疑问，便觉柳暗花明。作者的思路很难猜测清楚，文字也有遗失，但又何必被其束缚。即使我的理解显然不是作者的本意，又有什么关系呢？我看着“长亭外”的歌词，却硬要听作“长城外”，有何不可？&lt;/p&gt;</content></entry><entry><title>“选择”和“创造”的区别和联系</title><link href="/xuan-ze-he-chuang-zao-de-qu-bie-he-lian-xi.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/xuan-ze-he-chuang-zao-de-qu-bie-he-lian-xi.html</id><summary type="html">&lt;p&gt;在思考时间相关问题时，我发现了一对很有意思的概念：“选择”和“创造”。&lt;/p&gt;
&lt;p&gt;我们是在选择未来，还是在创造未来？在这两种观点中，我们对时间的认识似乎完全不同。简单说，在日常生活中对时间的认识中，我们认为自己在创造未来；而平行宇宙的观点中，我们是在选择未来。然而我反复思考二者的区别后，发现并无区别。&lt;/p&gt;
&lt;p&gt;我们来看什么情况我们会使用“选择”二字。当走到一个分叉路口时，面前有两条路，我会说我“选择”了其中一条，而不会说我“创造”了一条。因为很显然，路本来就在那里，并非说由我创造的。当面前的两条路变成十条后，并没有本质的不同，我依然说从十条路中选择一条。当十条路变成十亿条呢？且慢，我们换一种场景。&lt;/p&gt;
&lt;p&gt;我们想象面前有一个1x1像素的画布，我们要在上边作画，只可以使用一种颜色。那么我们只有两种选择，涂或者不涂，恐怕没有人会称这是创作。当画布变大为2x2像素后，我们的选择变多了，但仍然屈指可数。但当画布变大为10000x10000像素后，可供我们选择的数量变成了天文数字。画家在上边作画，我们称其“创作 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;在思考时间相关问题时，我发现了一对很有意思的概念：“选择”和“创造”。&lt;/p&gt;
&lt;p&gt;我们是在选择未来，还是在创造未来？在这两种观点中，我们对时间的认识似乎完全不同。简单说，在日常生活中对时间的认识中，我们认为自己在创造未来；而平行宇宙的观点中，我们是在选择未来。然而我反复思考二者的区别后，发现并无区别。&lt;/p&gt;
&lt;p&gt;我们来看什么情况我们会使用“选择”二字。当走到一个分叉路口时，面前有两条路，我会说我“选择”了其中一条，而不会说我“创造”了一条。因为很显然，路本来就在那里，并非说由我创造的。当面前的两条路变成十条后，并没有本质的不同，我依然说从十条路中选择一条。当十条路变成十亿条呢？且慢，我们换一种场景。&lt;/p&gt;
&lt;p&gt;我们想象面前有一个1x1像素的画布，我们要在上边作画，只可以使用一种颜色。那么我们只有两种选择，涂或者不涂，恐怕没有人会称这是创作。当画布变大为2x2像素后，我们的选择变多了，但仍然屈指可数。但当画布变大为10000x10000像素后，可供我们选择的数量变成了天文数字。画家在上边作画，我们称其“创作”一幅画，而不是“选择”出一幅画。&lt;/p&gt;
&lt;p&gt;同样地，当我们面前出现了十亿条路后，我们选择其中的一条，就不再是“选择”，而是“创造”一条。&lt;/p&gt;
&lt;p&gt;“选择”和“创造”是一回事，只是可供选择的数量少时，我们称其为“选择”，而数量多时，我们称其为“创造”。&lt;/p&gt;
&lt;p&gt;我们再看时间的问题，在每一个被称作“现在”的时刻，我们都有很多选择，我们可以做很多事情，所以即使在平行宇宙的观点中，我们也是在创造未来，而不是选择未来，就像我们在10000x10000像素的画布作画时，是在创作一幅画，而不是选择出一幅画。事实上二者并无实际区别，区别仅仅在于我们使用语言的习惯上。&lt;/p&gt;
&lt;p&gt;识别了该问题后，我们便可以对时间的本质问题做更为深入的思考了。&lt;/p&gt;</content></entry><entry><title>[译] 11 个用而有趣的 Linux 终端彩蛋</title><link href="/yi-11-ge-yong-er-you-qu-de-linux-zhong-duan-cai-dan.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-11-ge-yong-er-you-qu-de-linux-zhong-duan-cai-dan.html</id><summary type="html">&lt;p&gt;这里有一些很酷的Linux终端彩蛋，其中的每一个看上去并没有实际用途，但很有趣。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_01-100587352-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;只工作不玩耍……&lt;/h3&gt;
&lt;p&gt;当我们使用命令行工作时，Linux是功能和实用性最好的操作系统之一。想要执行一个特殊任务？可能一个程序或者脚本就可以帮你搞定。但就像一本书中说到的，只工作不玩耍聪明的孩子也会变傻。下边是我最喜欢的可以在终端做的没有实际用途的、傻傻的、恼人的、可笑的事情。&lt;/p&gt;
&lt;h3&gt;让终端成为一个有态度的人&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第一步）敲入&lt;code&gt;sudo visudo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第二步）在“Defaults”末尾（文件的前半部分）添加一行“Defaults insults”。&lt;/li&gt;
&lt;li&gt;第三步）保存文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“我刚才对电脑做了什么？”你可能这样问自己。一定是美妙的事情吧。现在，在sudo命令提示提示下输出错误的口令，你的电脑就会呼唤你的名字。我最喜欢的一句：“听好了，煎饼一样的脑子，我没有时间听你胡说八道了。”&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_02-100587353-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;apt-get moo&lt;/h3&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_03-100587354-orig.png"&gt;&lt;/p&gt;
&lt;p&gt;你看过这张截图？那就是运行&lt;code&gt;apt-get moo&lt;/code&gt;（在基于Debian的系统）的结果。对，就是它了。不要对它抱太多幻想 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;这里有一些很酷的Linux终端彩蛋，其中的每一个看上去并没有实际用途，但很有趣。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_01-100587352-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;只工作不玩耍……&lt;/h3&gt;
&lt;p&gt;当我们使用命令行工作时，Linux是功能和实用性最好的操作系统之一。想要执行一个特殊任务？可能一个程序或者脚本就可以帮你搞定。但就像一本书中说到的，只工作不玩耍聪明的孩子也会变傻。下边是我最喜欢的可以在终端做的没有实际用途的、傻傻的、恼人的、可笑的事情。&lt;/p&gt;
&lt;h3&gt;让终端成为一个有态度的人&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第一步）敲入&lt;code&gt;sudo visudo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第二步）在“Defaults”末尾（文件的前半部分）添加一行“Defaults insults”。&lt;/li&gt;
&lt;li&gt;第三步）保存文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“我刚才对电脑做了什么？”你可能这样问自己。一定是美妙的事情吧。现在，在sudo命令提示提示下输出错误的口令，你的电脑就会呼唤你的名字。我最喜欢的一句：“听好了，煎饼一样的脑子，我没有时间听你胡说八道了。”&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_02-100587353-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;apt-get moo&lt;/h3&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_03-100587354-orig.png"&gt;&lt;/p&gt;
&lt;p&gt;你看过这张截图？那就是运行&lt;code&gt;apt-get moo&lt;/code&gt;（在基于Debian的系统）的结果。对，就是它了。不要对它抱太多幻想，你会失望的，我不骗你。但是这是Linux世界最被人熟知的彩蛋之一。所以我把它包含进来，并且放在前排，然后我也就不会收到5千封邮件，指责我把它遗漏了。&lt;/p&gt;
&lt;h3&gt;aptitude moo&lt;/h3&gt;
&lt;p&gt;更有趣的是将moo应用到aptitude上。敲入&lt;code&gt;aptitude moo&lt;/code&gt;（在Ubuntu及其衍生版），你对&lt;code&gt;moo&lt;/code&gt;可以做什么事情的看法会有所变化。你还还会知道更多事情，尝试重新输入这条命令，但这次添加一个&lt;code&gt;-v&lt;/code&gt;参数。这还没有结束，试着添加更多&lt;code&gt;v&lt;/code&gt;，一次添加一个，直到抓狂的aptitude给了你想要的东西。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_04-100587355-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;Arch: 将吃豆人放入pacman&lt;/h3&gt;
&lt;p&gt;这里有一个只为Arch爱好者准备的彩蛋。Pacman包管理工具已经很棒了，但我们可以让它变得更棒。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步）打开“/etc/pacman.conf”文件。&lt;/li&gt;
&lt;li&gt;第二步）在“# Misc options”部分，去掉“Color”前的“#”。&lt;/li&gt;
&lt;li&gt;第三步）添加“ILoveCandy”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在我们使用pacman安装新软件包时，进度条里会出现一个小吃豆人。真应该默认就这样的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_05-100587356-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;Cowsay!&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;aptitude moo&lt;/code&gt;的输出格式很漂亮，但我想你苦于不能自由自在地使用。输入&lt;code&gt;cowsay&lt;/code&gt;，它会做到你想做的事情。你可以让牛说任何你喜欢的东西。而且不只可以用牛，还可以用Calvin、Beavis和Ghostbusters logo的ASCII的艺术，输入&lt;code&gt;cowsay -l&lt;/code&gt;可以得到所有可用的参数。它是Linux世界的强大工具。像很多其他命令一样，你可以使用管道把其他程序的输出输送给它，比如&lt;code&gt;fortune | cowsay&lt;/code&gt;，让这头牛变成哲学家。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_06-100587358-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;变成3l33t h@x0r&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nmap&lt;/code&gt;并不是我们平时经常使用的基本命令。但如果你想蹂躏&lt;code&gt;nmap&lt;/code&gt;的话，比如像人一样看起来像l33t。在任何&lt;code&gt;nmap&lt;/code&gt;命令后添加&lt;code&gt;-oS&lt;/code&gt;（比如&lt;code&gt;nmap -oS - google.com&lt;/code&gt;）。现在你的&lt;code&gt;nmap&lt;/code&gt;已经处于标准叫法是“&lt;a href="http://nmap.org/book/output-formats-script-kiddie.html"&gt;脚本玩具模式&lt;/a&gt;”的模式了。Angelina Jolie和Keanu Reeves会为此骄傲的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_07-100587359-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;获得所有的Discordian日期&lt;/h3&gt;
&lt;p&gt;如果你们曾经坐在一起思考，“嗨！我想使用无用但异想天开的方式来书写今天的日期……”试试运行&lt;code&gt;ddate&lt;/code&gt;。结果类似于“Today is Setting Orange, the 72nd day of Discord in the YOLD 3181”，这会让你的服务树日志平添不少趣味。&lt;/p&gt;
&lt;p&gt;注意：在技术层面，确实有一个&lt;a href="http://en.wikipedia.org/wiki/Discordian_calendar"&gt;Discordian Calendar&lt;/a&gt;，理论上被&lt;a href="http://en.wikipedia.org/wiki/Discordianism"&gt;Discordianism&lt;/a&gt;追随者所使用。这意味着我可能得罪某些人。或者不会，我不确定。不管怎样，&lt;code&gt;ddate&lt;/code&gt;是一个方便的工具。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_08-100587360-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;我可以在任何地方看到颜色！&lt;/h3&gt;
&lt;p&gt;厌倦了老旧的文本？想向世界展示出自己的个性？使用&lt;code&gt;lolcat&lt;/code&gt;。安装它，然后在任何地方使用。它可以接收任何文本，然后将其转换成美轮美奂的彩虹效果。可以使用&lt;code&gt;fortune | lolcat&lt;/code&gt;体验。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_09-100587361-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;蒸汽机车&lt;/h3&gt;
&lt;p&gt;在你的终端显示蒸汽机车的ASCII图形。如果你需要它，安装并运行&lt;code&gt;sl&lt;/code&gt;命令。&lt;code&gt;sl -l&lt;/code&gt;可以看到一个袖珍版本的。或者，如果你真想在上边花费更多时间，运行&lt;code&gt;sl -h&lt;/code&gt;。这会显示一个完整的或者，还包括乘客车厢。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_10-100587362-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;将任何文本逆序输出&lt;/h3&gt;
&lt;p&gt;将任何文本使用管道输送给&lt;code&gt;rev&lt;/code&gt;命令，它就会将文本内容逆序输出。&lt;code&gt;fortune | rev&lt;/code&gt;会给你好运。当然，这不意味着rev会将幸运（fortune）转换成不幸。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_11-100587364-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;Matrix依然很酷，不是吗？&lt;/h3&gt;
&lt;p&gt;想让你的终端显示滚动的文字、l33t和Matrix电影中的坠落数码？&lt;code&gt;cmatrix&lt;/code&gt;是你的朋友。你甚至可以用它输出不同的颜色，非常华丽。使用&lt;code&gt;man cmatrix&lt;/code&gt;学习使用方法。或者使用更好的方法，“man cmatrix | lolcat”。这确实是你在Linux终端可以做的最没实际用途却又精彩的事情了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_12-100587366-orig.png"&gt;&lt;/p&gt;
&lt;p&gt;以上就是全部内容了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://www.networkworld.com/article/2926630/linux/11-pointless-but-awesome-linux-terminal-tricks.html&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://www.networkworld.com/author/Bryan-Lunduke/"&gt;Bryan Lunduke&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="https://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 20 个为桌面用户准备的令人惊叹的 Docker 容器</title><link href="/yi-20-ge-wei-zhuo-mian-yong-hu-zhun-bei-de-ling-ren-liang-tan-de-docker-rong-qi.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-20-ge-wei-zhuo-mian-yong-hu-zhun-bei-de-ling-ren-liang-tan-de-docker-rong-qi.html</id><summary type="html">&lt;p&gt;大家好，今天我们会列出一些运行在Docker容器中的很棒的桌面软件，我们可以在自己的桌面系统中运行它们。Docker 是一个开源项目，提供了一个可以打包、装载和运行任何应用的轻量级容器的开放平台。它没有语言支持、框架和打包系统的限制，从小型的家用电脑到高端服务器，在何时何地都可以运行。它可以使部署和扩展web应用程序、数据库和后端服务像搭积木一样容易，而不依赖特定技术栈或提供商。它主要是由开发、运维工程师使用的，因为它简单、快速和方便，可以用来测试和辅助开发他们产品，但是我们也可以在桌面环境使用Docker，这样一些桌面程序可以开箱即用。&lt;/p&gt;
&lt;p&gt;下边是20个非常棒的桌面软件docker镜像，我们可以使用Docker来运行。&lt;/p&gt;
&lt;h3&gt;1. Lynx&lt;/h3&gt;
&lt;p&gt;Lynx是一个一直以来最受欢迎的文本界面网页浏览器，很多Linux用户都很熟悉它。它应该是现在还在日常和开发环境中被使用的最古老的网页浏览器了。可以使用如下命令运行Lync。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
--name lynx &lt;span class="se"&gt;\&lt;/span&gt;
jess/lynx
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. Irssi&lt;/h3&gt;
&lt;p&gt;Irssi是一个非常棒的文本界面IRC客户端。可以使用如下命令运行Irssi。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker run -it --name my-irssi -e TERM -u $(id -u …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;大家好，今天我们会列出一些运行在Docker容器中的很棒的桌面软件，我们可以在自己的桌面系统中运行它们。Docker 是一个开源项目，提供了一个可以打包、装载和运行任何应用的轻量级容器的开放平台。它没有语言支持、框架和打包系统的限制，从小型的家用电脑到高端服务器，在何时何地都可以运行。它可以使部署和扩展web应用程序、数据库和后端服务像搭积木一样容易，而不依赖特定技术栈或提供商。它主要是由开发、运维工程师使用的，因为它简单、快速和方便，可以用来测试和辅助开发他们产品，但是我们也可以在桌面环境使用Docker，这样一些桌面程序可以开箱即用。&lt;/p&gt;
&lt;p&gt;下边是20个非常棒的桌面软件docker镜像，我们可以使用Docker来运行。&lt;/p&gt;
&lt;h3&gt;1. Lynx&lt;/h3&gt;
&lt;p&gt;Lynx是一个一直以来最受欢迎的文本界面网页浏览器，很多Linux用户都很熟悉它。它应该是现在还在日常和开发环境中被使用的最古老的网页浏览器了。可以使用如下命令运行Lync。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
--name lynx &lt;span class="se"&gt;\&lt;/span&gt;
jess/lynx
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. Irssi&lt;/h3&gt;
&lt;p&gt;Irssi是一个非常棒的文本界面IRC客户端。可以使用如下命令运行Irssi。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker run -it --name my-irssi -e TERM -u $(id -u):$(id -g) \
-v $HOME/.irssi:/home/user/.irssi:ro \
-v /etc/localtime:/etc/localtime:ro \
irssi
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3. Chrome&lt;/h3&gt;
&lt;p&gt;Chrome是一个令人惊叹的图形界面网页浏览器，由Google开发，它基于开源的Chromium项目。Google Chrome是一个被广泛使用的、快速安全的网页浏览器，经常上网的人会非常熟悉它。我们可以使用如下命令在Docker中运行Chrome。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
--net host &lt;span class="se"&gt;\&lt;/span&gt;
--cpuset &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
--memory 512mb &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;unix&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/Downloads:/root/Downloads &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/.config/google-chrome/:/data &lt;span class="se"&gt;\&lt;/span&gt;
-v /dev/snd:/dev/snd --privileged &lt;span class="se"&gt;\&lt;/span&gt;
--name chrome &lt;span class="se"&gt;\&lt;/span&gt;
jess/chrome
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;4. Tor浏览器&lt;/h3&gt;
&lt;p&gt;Tor浏览器是一个支持匿名访问的网页浏览器。它让我们可以自由地在网络世界遨游，或者浏览被特定组织或者网络服务提供商封锁的网站。它会阻止别人通过监视我们的网络连接来窃取我们在网络上的一举一动以及我们的确切位置。运行如下命令运行Tor浏览器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;unix&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-v /dev/snd:/dev/snd --privileged &lt;span class="se"&gt;\&lt;/span&gt;
--name tor-browser &lt;span class="se"&gt;\&lt;/span&gt;
jess/tor-browser
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;5. Firefox浏览器&lt;/h3&gt;
&lt;p&gt;Firefox浏览器是一个自由开源的网页浏览器，它由Mozilla基金会开发。它使用Gecko和SpiderMonkey引擎。Firefox浏览器有很多新特性，并且它以性能和安全性著称。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -d &lt;span class="se"&gt;\&lt;/span&gt;
--name firefox &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
kennethkl/firefox
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;6. Rainbow Stream&lt;/h3&gt;
&lt;p&gt;Rainbow Stream是一个文本界面的Twitter客户端，有实时显示tweetstream、搜索、喜欢和更多其他特性，可以直接在终端使用。使用如下命令运行Rainbow Stream。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /etc/localtime:/etc/localtime &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/.rainbow_oauth:/root/.rainbow_oauth &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/.rainbow_config.json:/root/.rainbow_config.json &lt;span class="se"&gt;\&lt;/span&gt;
--name rainbowstream &lt;span class="se"&gt;\&lt;/span&gt;
jess/rainbowstream
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;7. Gparted&lt;/h3&gt;
&lt;p&gt;Gparted是一个用来给磁盘分区的开源软件。现在可以在Docker容器里享受分区的乐趣了。可以使用如下命令运行gparted。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;unix&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
--device /dev/sda:/dev/sda &lt;span class="se"&gt;\ &lt;/span&gt;&lt;span class="c1"&gt;# 将设备挂载为分区&lt;/span&gt;
--name gparted &lt;span class="se"&gt;\&lt;/span&gt;
jess/gparted
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;8. GIMP图片编辑器&lt;/h3&gt;
&lt;p&gt;GIMP（Gnu Image Manipulation Program）是一个令人惊叹的Linux图片编辑软件。它是一个可以自由分发的可以处理照片修正、图像合成和图像创作等任务的工具。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
--rm -e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
jarfil/gimp-git
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;9. Thunderbird&lt;/h3&gt;
&lt;p&gt;Thunderbird是一个自由开源的电子邮件软件，它由Mozilla基金会开发和维护。它有众多一个电子邮件软件应该具有的功能。Thunderbird非常易于安装和定制。使用如下命令在Docker中运行Thunderbird。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -d &lt;span class="se"&gt;\&lt;/span&gt;
-e DISPLAY &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix:ro &lt;span class="se"&gt;\&lt;/span&gt;
-u docker &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/docker-data/thunderbird:/home/docker/.thunderbird/ &lt;span class="se"&gt;\&lt;/span&gt;
yantis/thunderbird thunderbird
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;10. Mutt&lt;/h3&gt;
&lt;p&gt;Mutt是一个文本界面的电子邮件客户端，有很多很酷的功能，如彩色支持，IMAP、POP3、SMTP支持，邮件存储支持等。 使用如下命令运行Mutt。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /etc/localtime:/etc/localtime &lt;span class="se"&gt;\&lt;/span&gt;
-e GMAIL -e GMAIL_NAME &lt;span class="se"&gt;\&lt;/span&gt;
-e GMAIL_PASS -e GMAIL_FROM &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/.gnupg:/home/user/.gnupg &lt;span class="se"&gt;\&lt;/span&gt;
--name mutt &lt;span class="se"&gt;\&lt;/span&gt;
jess/mutt
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;11. Skype&lt;/h3&gt;
&lt;p&gt;Skype是一个支持文字、语音和视频的即时通讯软件，它不是开源的，但在Linux下可以运行的很好。我们同样可以在Docker中运行Skype，使用如下命令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix:ro &lt;span class="se"&gt;\&lt;/span&gt;
-v /dev/snd:/dev/snd --privileged &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;unix&lt;/span&gt;&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
tianon/skype
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;12. Cathode&lt;/h3&gt;
&lt;p&gt;Cathode是一个漂亮并且高度可定制的终端模拟器，灵感来自古典计算机。使用如下命令运行Cathode。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;unix&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
--name cathode &lt;span class="se"&gt;\&lt;/span&gt;
jess/1995
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;13. LibreOffice&lt;/h3&gt;
&lt;p&gt;LibreOffice是一个功能强大的办公套件，它是自由开源的，现在由The Document基金会维护。它有干净的界面和强大的功能，让我们释放创造力和提升生产力。LibreOffice将数个应用程序集成在一起，是市面上最强大的自由并且开源的办公套件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$docker run \
-v $HOME/Documents:/home/libreoffice/Documents:rw \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e uid=$(id -u) -e gid=$(id -g) \
-e DISPLAY=unix$DISPLAY --name libreoffice \
chrisdaish/libreoffice
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;14. Spotify&lt;/h3&gt;
&lt;p&gt;Spotify可以即时访问数百万的歌曲，从经典老歌到最新单曲。可以使用如下命令在Docker中听我们最喜欢的歌曲。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;unix&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-v /dev/snd:/dev/snd --privileged &lt;span class="se"&gt;\&lt;/span&gt;
--name spotify &lt;span class="se"&gt;\&lt;/span&gt;
jess/spotify
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;15. Audacity&lt;/h3&gt;
&lt;p&gt;Audacity是一个自由开源的跨平台软件，用来录制和编辑音频。Audacity可以用来做所有类型音频（例如podcast）的后期处理，如归一化、调整、淡入淡出。使用如下命令来运行Audacity。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run --rm &lt;span class="se"&gt;\&lt;/span&gt;
-u &lt;span class="k"&gt;$(&lt;/span&gt;id -u&lt;span class="k"&gt;)&lt;/span&gt;:&lt;span class="k"&gt;$(&lt;/span&gt;id -g&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix:ro &lt;span class="se"&gt;\&lt;/span&gt;
-v /dev/snd:/dev/snd &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;:&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-w &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;unix&lt;/span&gt;&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-e HOME &lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="k"&gt;$(&lt;/span&gt;find /dev/snd/ -type c &lt;span class="p"&gt;|&lt;/span&gt; sed &lt;span class="s1"&gt;&amp;#39;s/^/--device /&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
knickers/audacity
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;16. Eclipse&lt;/h3&gt;
&lt;p&gt;Eclipse是一个集成开发环境。它包含基本的工作区和用来定制环境的可扩展插件系统。它在Java开发者中很流行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -v ~/workspace/:/home/eclipse/workspace/ &lt;span class="se"&gt;\&lt;/span&gt;
-e DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix:ro &lt;span class="se"&gt;\&lt;/span&gt;
-d leesah/eclipse
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;17. VLC媒体播放器&lt;/h3&gt;
&lt;p&gt;VLC是一个自由开源的跨平台多媒体播放器，可以播放本地文件、DVD、CD、VCD和各种流媒体。VLC由VideoLAN组织开发和维护。使用如下命令运行VLC。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -v&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="nv"&gt;$HOME&lt;/span&gt;/Documents:/home/vlc/Documents:rw &lt;span class="se"&gt;\&lt;/span&gt;
-v /dev/snd:/dev/snd --privileged &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;uid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;id -u&lt;span class="k"&gt;)&lt;/span&gt; -e &lt;span class="nv"&gt;gid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;id -g&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;unix&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; --name vlc &lt;span class="se"&gt;\&lt;/span&gt;
chrisdaish/vlc
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;18. Vim编辑器&lt;/h3&gt;
&lt;p&gt;Vim是一个高度可配置的文本界面文字编辑器，为高效的文本编辑而生。它是预装在多数UNIX系统中的vi编辑器的改进版本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -i -t --name my-vim -v ~/:/home/dev/src haron/vim
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;19. Inkscape&lt;/h3&gt;
&lt;p&gt;Inkscape是一个自由开源的矢量图形编辑器。它可以创建、编辑矢量图形，如插图、图示、线条艺术、图表、徽标以及更复杂的绘画。Inkscape使用的主要矢量图形格式是SVG 1.1版本。它也可以导入和导出一些其他的格式，但实际编辑使用的还是SVG格式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$docker build -t rasch/inkscape --rm .
$ docker run --rm -e DISPLAY \
-u inkscaper
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v $HOME/.Xauthority:/home/inkscaper/.Xauthority \
--net=host rasch/inkscape
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;20. Filezilla&lt;/h3&gt;
&lt;p&gt;Filezilla是一个免费的FTP解决方案，支持FTP、SFTP、FTPS协议。它的客户端是一个功能强大的文件管理工具。它是一个很棒的高度可靠和易用的开源FTP解决方案。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ xhost +si:localuser:&lt;span class="k"&gt;$(&lt;/span&gt;whoami&lt;span class="k"&gt;)&lt;/span&gt;
$ docker run &lt;span class="se"&gt;\&lt;/span&gt;
-d &lt;span class="se"&gt;\&lt;/span&gt;
-e DISPLAY &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix:ro &lt;span class="se"&gt;\&lt;/span&gt;
-u docker &lt;span class="se"&gt;\&lt;/span&gt;
-v /:/host &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/docker-data/filezilla:/home/docker/.config/filezilla/ &lt;span class="se"&gt;\&lt;/span&gt;
yantis/filezilla filezilla
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;使用Docker运行桌面软件真的是很棒的体验。Docker是一个快速、简单的开发平台，适合从家里、办公室到生产环境里传送和开发软件的场景。使用Docker运行桌面软件是试用而不将其安装到自己实体机文件系统中的很酷的方法。如果你有任何问题、评论或者反馈，清写在下方的评论框中，让我们知道哪些是需要增加或者改进的。谢谢！享受Docker吧 :-)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://linoxide.com/how-tos/20-docker-containers-desktop-user/&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://linoxide.com/author/arunp/"&gt;Arun Pyasi&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 4 个可以发送完整电子邮件的命令行工具</title><link href="/yi-4-ge-ke-yi-fa-song-wan-zheng-dian-zi-you-jian-de-ming-ling-xing-gong-ju.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-4-ge-ke-yi-fa-song-wan-zheng-dian-zi-you-jian-de-ming-ling-xing-gong-ju.html</id><summary type="html">&lt;p&gt;今天的文章里我们会讲到一些使用Linux命令行工具来发送带附件的电子邮件的方法。它有很多用处，比如在应用程序所在服务器上，使用电子邮件发送一个文件过来，或者你可以在脚本中使用这些命令来做一些自动化操作。在本文的例子中，我们会使用foo.tar.gz文件作为附件。&lt;/p&gt;
&lt;p&gt;有不同的命令行工具可以发送邮件，这里我分享几个多数用户会使用的工具，如&lt;code&gt;mailx&lt;/code&gt;、&lt;code&gt;mutt&lt;/code&gt;和&lt;code&gt;swaks&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们即将呈现的这些工具都是非常有名的，并且存在于多数Linux发行版默认的软件仓库中，你可以使用如下命令安装：&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Debian / Ubuntu&lt;/strong&gt; 系统&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get install mutt
apt-get install swaks
apt-get install mailx
apt-get install sharutils
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在基于Red Hat的系统，如 &lt;strong&gt;CentOS&lt;/strong&gt; 或者 &lt;strong&gt;Fedora&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install mutt
yum install swaks
yum install mailx …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;今天的文章里我们会讲到一些使用Linux命令行工具来发送带附件的电子邮件的方法。它有很多用处，比如在应用程序所在服务器上，使用电子邮件发送一个文件过来，或者你可以在脚本中使用这些命令来做一些自动化操作。在本文的例子中，我们会使用foo.tar.gz文件作为附件。&lt;/p&gt;
&lt;p&gt;有不同的命令行工具可以发送邮件，这里我分享几个多数用户会使用的工具，如&lt;code&gt;mailx&lt;/code&gt;、&lt;code&gt;mutt&lt;/code&gt;和&lt;code&gt;swaks&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们即将呈现的这些工具都是非常有名的，并且存在于多数Linux发行版默认的软件仓库中，你可以使用如下命令安装：&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Debian / Ubuntu&lt;/strong&gt; 系统&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get install mutt
apt-get install swaks
apt-get install mailx
apt-get install sharutils
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在基于Red Hat的系统，如 &lt;strong&gt;CentOS&lt;/strong&gt; 或者 &lt;strong&gt;Fedora&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install mutt
yum install swaks
yum install mailx
yum install sharutils
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;1) 使用 mail / mailx&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;mailx&lt;/code&gt;工具在多数Linux发行版中是默认的邮件程序，现在已经支持发送附件了。如果它不在你的系统中，你可以使用上边的命令安装。有一点需要注意，老版本的mailx可能不支持发送附件，运行如下命令查看是否支持。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ man mail
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一行看起来是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mailx [-BDdEFintv~] [-s subject] [-a attachment ] [-c cc-addr] [-b bcc-addr] [-r from-addr] [-h hops] [-A account] [-S variable[=value]] to-addr . . .
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你看到它支持&lt;code&gt;-a&lt;/code&gt;的选项（-a 文件名，将文件作为附件添加到邮件）和&lt;code&gt;-s&lt;/code&gt;选项（-s 主题，指定邮件的主题），那就是支持的。可以使用如下的几个例子发送邮件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a) 简单的邮件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运行&lt;code&gt;mail&lt;/code&gt;命令，然后&lt;code&gt;mailx&lt;/code&gt;会等待你输入邮件内容。你可以按回车来换行。当输入完成后，按Ctrl + D，&lt;code&gt;mailx&lt;/code&gt;会显示EOT表示结束。&lt;/p&gt;
&lt;p&gt;然后&lt;code&gt;mailx&lt;/code&gt;会自动将邮件发送给收件人。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mail user@example.com

HI,
Good Morning
How are you
EOT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;b) 发送有主题的邮件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Email text&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; mail -s &lt;span class="s2"&gt;&amp;quot;Test Subject&amp;quot;&lt;/span&gt; user@example.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;-s&lt;/code&gt;的用处是指定邮件的主题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c) 从文件中读取邮件内容并发送&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mail -s &lt;span class="s2"&gt;&amp;quot;message send from file&amp;quot;&lt;/span&gt; user@example.com &amp;lt; /path/to/file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;d) 将从管道获取到的&lt;code&gt;echo&lt;/code&gt;命令输出作为邮件内容发送&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;This is message body&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; mail -s &lt;span class="s2"&gt;&amp;quot;This is Subject&amp;quot;&lt;/span&gt; user@example.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;e) 发送带附件的邮件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; “Body with attachment &lt;span class="s2"&gt;&amp;quot;| mail -a foo.tar.gz -s &amp;quot;&lt;/span&gt;attached file&lt;span class="s2"&gt;&amp;quot; user@example.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;-a&lt;/code&gt;选项用于指定附件。&lt;/p&gt;
&lt;h3&gt;2) mutt&lt;/h3&gt;
&lt;p&gt;Mutt是类Unix系统上的一个文本界面邮件客户端。它有20多年的历史，在Linux历史中也是一个很重要的部分，它是最早支持进程打分和多线程处理的客户端程序之一。按照如下的例子来发送邮件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a) 带有主题，从文件中读取邮件的正文，并发送&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mutt -s &lt;span class="s2"&gt;&amp;quot;Testing from mutt&amp;quot;&lt;/span&gt; user@example.com &amp;lt; /tmp/message.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;b) 通过管道获取&lt;code&gt;echo&lt;/code&gt;命令输出作为邮件内容发送&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;This is the body&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; mutt -s &lt;span class="s2"&gt;&amp;quot;Testing mutt&amp;quot;&lt;/span&gt; user@example.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;c) 发送带附件的邮件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;This is the body&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; mutt -s &lt;span class="s2"&gt;&amp;quot;Testing mutt&amp;quot;&lt;/span&gt; user@example.com -a /tmp/foo.tar.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;d) 发送带有多个附件的邮件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;This is the body&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; mutt -s &lt;span class="s2"&gt;&amp;quot;Testing&amp;quot;&lt;/span&gt; user@example.com -a foo.tar.gz –a bar.tar.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3) swaks&lt;/h3&gt;
&lt;p&gt;Swaks（Swiss Army Knife，瑞士军刀）是SMTP服务上的瑞士军刀，它是一个功能强大、灵活、可编程、面向事务的SMTP测试工具，由John Jetmore开发和维护。你可以使用如下语法发送带附件的邮件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ swaks -t &lt;span class="s2"&gt;&amp;quot;foo@bar.com&amp;quot;&lt;/span&gt; --header &lt;span class="s2"&gt;&amp;quot;Subject: Subject&amp;quot;&lt;/span&gt; --body &lt;span class="s2"&gt;&amp;quot;Email Text&amp;quot;&lt;/span&gt; --attach foo.tar.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于Swaks一个重要的地方是，它会为你显示整个邮件发送过程，所以如果你想调试邮件发送过程，它是一个非常有用的工具。&lt;/p&gt;
&lt;p&gt;它会给你提供了邮件发送过程的所有细节，包括邮件接收服务器的功能支持、两个服务器之间的每一步交互。&lt;/p&gt;
&lt;h3&gt;4) uuencode&lt;/h3&gt;
&lt;p&gt;邮件传输系统最初是被设计来传送7位编码（类似ASCII）的内容的。这就意味这它是用来发送文本内容，而不能发会使用8位的二进制内容（如程序文件或者图片）。&lt;code&gt;uuencode&lt;/code&gt;（“UNIX to UNIX encoding”，UNIX之间使用的编码方式）程序用来解决这个限制。使用&lt;code&gt;uuencode&lt;/code&gt;，发送端将二进制格式的转换成文本格式来传输，接收端再转换回去。&lt;/p&gt;
&lt;p&gt;我们可以简单地使用&lt;code&gt;uuencode&lt;/code&gt;和&lt;code&gt;mailx&lt;/code&gt;或者&lt;code&gt;mutt&lt;/code&gt;配合，来发送二进制内容，类似这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ uuencode example.jpeg example.jpeg &lt;span class="p"&gt;|&lt;/span&gt; mail user@example.com
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Shell脚本：解释如何发送邮件&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nv"&gt;FROM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;SUBJECT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;ATTACHMENTS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;TO&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;BODY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;# 检查文件名对应的文件是否存在&lt;/span&gt;
&lt;span class="k"&gt;function&lt;/span&gt; check_files&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="nv"&gt;output_files&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; file in &lt;span class="nv"&gt;$1&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -s &lt;span class="nv"&gt;$file&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nv"&gt;output_files&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;output_files&lt;/span&gt;&lt;span class="si"&gt;}${&lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt; &amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$output_files&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;*********************&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;E-mail sending script.&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;*********************&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;

&lt;span class="c1"&gt;# 读取用户输入的邮件地址&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; ! &lt;span class="nv"&gt;$FROM&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; -n -e &lt;span class="s2"&gt;&amp;quot;Enter the e-mail address you wish to send mail from:\n[Enter] &amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; -n -e &lt;span class="s2"&gt;&amp;quot;The address you provided is not valid:\n[Enter] &amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="nb"&gt;read&lt;/span&gt; FROM
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$FROM&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep -E &lt;span class="s1"&gt;&amp;#39;^.+@.+$&amp;#39;&lt;/span&gt; &amp;gt; /dev/null
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -eq &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nb"&gt;break&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt;

&lt;span class="c1"&gt;# 读取用户输入的收件人地址&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; ! &lt;span class="nv"&gt;$TO&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; -n -e &lt;span class="s2"&gt;&amp;quot;Enter the e-mail address you wish to send mail to:\n[Enter] &amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; -n -e &lt;span class="s2"&gt;&amp;quot;The address you provided is not valid:\n[Enter] &amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="nb"&gt;read&lt;/span&gt; TO
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$TO&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep -E &lt;span class="s1"&gt;&amp;#39;^.+@.+$&amp;#39;&lt;/span&gt; &amp;gt; /dev/null
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -eq &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nb"&gt;break&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt;

&lt;span class="c1"&gt;# 读取用户输入的邮件主题&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; -n -e &lt;span class="s2"&gt;&amp;quot;Enter e-mail subject:\n[Enter] &amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;read&lt;/span&gt; SUBJECT

&lt;span class="nb"&gt;echo&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$SUBJECT&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Proceeding without the subject...&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="c1"&gt;# 读取作为附件的文件名&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; -e &lt;span class="s2"&gt;&amp;quot;Provide the list of attachments. Separate names by space.&lt;/span&gt;
&lt;span class="s2"&gt;If there are spaces in file name, quote file name with \&amp;quot;.&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;read&lt;/span&gt; att

&lt;span class="nb"&gt;echo&lt;/span&gt;

&lt;span class="c1"&gt;# 确保文件名指向真实文件&lt;/span&gt;
&lt;span class="nv"&gt;attachments&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;check_files &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$att&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Attachments: &lt;/span&gt;&lt;span class="nv"&gt;$attachments&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; attachment in &lt;span class="nv"&gt;$attachments&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="nv"&gt;ATTACHMENTS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$ATTACHMENTS&lt;/span&gt;&lt;span class="s2"&gt;-a &lt;/span&gt;&lt;span class="nv"&gt;$attachment&lt;/span&gt;&lt;span class="s2"&gt; &amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt;

&lt;span class="c1"&gt;# 读取完整的邮件正文&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Enter message. To mark the end of message type ;; in new line.&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;read&lt;/span&gt; line

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$line&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; !&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;;;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="nv"&gt;BODY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$BODY$line&lt;/span&gt;&lt;span class="s2"&gt;\n&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;read&lt;/span&gt; line
&lt;span class="k"&gt;done&lt;/span&gt;

&lt;span class="nv"&gt;SENDMAILCMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;mutt -e \&amp;quot;set from=&lt;/span&gt;&lt;span class="nv"&gt;$FROM&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot; -s \&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$SUBJECT&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot; \&lt;/span&gt;
&lt;span class="nv"&gt;$ATTACHMENTS&lt;/span&gt;&lt;span class="s2"&gt; -- \&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$TO&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot; &amp;lt;&amp;lt;&amp;lt; \&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$BODY&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$SENDMAILCMD&lt;/span&gt;

mutt -e &lt;span class="s2"&gt;&amp;quot;set from=&lt;/span&gt;&lt;span class="nv"&gt;$FROM&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; -s &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$SUBJECT&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$ATTACHMENTS&lt;/span&gt; -- &lt;span class="nv"&gt;$TO&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;$BODY&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt; 脚本输出 &lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ bash send_mail.sh
*********************
E-mail sending script.
*********************

Enter the e-mail address you wish to send mail from:
&lt;span class="o"&gt;[&lt;/span&gt;Enter&lt;span class="o"&gt;]&lt;/span&gt; test@gmail.com

Enter the e-mail address you wish to send mail to:
&lt;span class="o"&gt;[&lt;/span&gt;Enter&lt;span class="o"&gt;]&lt;/span&gt; test@gmail.com

Enter e-mail subject:
&lt;span class="o"&gt;[&lt;/span&gt;Enter&lt;span class="o"&gt;]&lt;/span&gt; Message subject

Provide the list of attachments. Separate names by space.
If there are spaces in file name, quote file name with &lt;span class="s2"&gt;&amp;quot;.&lt;/span&gt;
&lt;span class="s2"&gt;send_mail.sh&lt;/span&gt;

&lt;span class="s2"&gt;Attachments: send_mail.sh&lt;/span&gt;

&lt;span class="s2"&gt;Enter message. To mark the end of message type ;; in new line.&lt;/span&gt;
&lt;span class="s2"&gt;This is a message&lt;/span&gt;
&lt;span class="s2"&gt;text&lt;/span&gt;
&lt;span class="s2"&gt;;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;有很多方法可以使用命令行/Shell脚本来发送邮件，这里我们只分享了其中4个类Unix系统可用的工具。希望你喜欢我们的文章，并且提供您的宝贵意见，让我们知道您想了解哪些新工具。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://linoxide.com/linux-shell-script/send-email-subject-body-attachment-linux/&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://linoxide.com/author/bobbin/"&gt;Bobbin Zachariah&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 5 个有趣的 Linux 命令行技巧</title><link href="/yi-5-ge-you-qu-de-linux-ming-ling-xing-ji-qiao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-5-ge-you-qu-de-linux-ming-ling-xing-ji-qiao.html</id><summary type="html">&lt;p&gt;你有将Linux物尽其用吗？对很多Linux用户来说，有很多看起来是技巧的有用特性。有些时候你会需要这些技巧。本文会帮助你更好得使用一些命令，发挥其更强大的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="5个命令行技巧" src="http://www.tecmint.com/wp-content/uploads/2015/03/5-Command-Line-Tips.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图1：5个命令行技巧&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们开始一个新的系列，在这里我们还会写一些技巧，并且用尽量小的篇幅写清楚。&lt;/p&gt;
&lt;h3&gt;1. 我们可以使用&lt;a href="https://linux.cn/article-1143-1.html"&gt;&lt;code&gt;history&lt;/code&gt;命令&lt;/a&gt;来查看曾经运行过的命令。&lt;/h3&gt;
&lt;p&gt;这里是一个&lt;code&gt;history&lt;/code&gt;命令的示例输出。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# history
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="history命令例子" src="http://www.tecmint.com/wp-content/uploads/2015/03/history-command.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图2：history命令例子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;history&lt;/code&gt;命令输出看，很明显，命令的执行时间没有被打出来。有解决方法吗？有的！运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# HISTTIMEFORMAT=&amp;quot;%d/%m/%y %T &amp;quot;
# history
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你想让这个修改永久生效，添加如下的一行内容到&lt;code&gt;~/.bashrc&lt;/code&gt;文件中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;export HISTTIMEFORMAT=&amp;quot;%d/%m/%y %T &amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，在终端中运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# source ~/.bashrc …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;你有将Linux物尽其用吗？对很多Linux用户来说，有很多看起来是技巧的有用特性。有些时候你会需要这些技巧。本文会帮助你更好得使用一些命令，发挥其更强大的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="5个命令行技巧" src="http://www.tecmint.com/wp-content/uploads/2015/03/5-Command-Line-Tips.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图1：5个命令行技巧&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们开始一个新的系列，在这里我们还会写一些技巧，并且用尽量小的篇幅写清楚。&lt;/p&gt;
&lt;h3&gt;1. 我们可以使用&lt;a href="https://linux.cn/article-1143-1.html"&gt;&lt;code&gt;history&lt;/code&gt;命令&lt;/a&gt;来查看曾经运行过的命令。&lt;/h3&gt;
&lt;p&gt;这里是一个&lt;code&gt;history&lt;/code&gt;命令的示例输出。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# history
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="history命令例子" src="http://www.tecmint.com/wp-content/uploads/2015/03/history-command.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图2：history命令例子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;history&lt;/code&gt;命令输出看，很明显，命令的执行时间没有被打出来。有解决方法吗？有的！运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# HISTTIMEFORMAT=&amp;quot;%d/%m/%y %T &amp;quot;
# history
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你想让这个修改永久生效，添加如下的一行内容到&lt;code&gt;~/.bashrc&lt;/code&gt;文件中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;export HISTTIMEFORMAT=&amp;quot;%d/%m/%y %T &amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，在终端中运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# source ~/.bashrc
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;命令和选项的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;history – 查看运行过的命令&lt;/li&gt;
&lt;li&gt;HISTIMEFORMAT – 设置时间格式的环境变量&lt;/li&gt;
&lt;li&gt;%d – 天&lt;/li&gt;
&lt;li&gt;%m – 月&lt;/li&gt;
&lt;li&gt;%y – 年&lt;/li&gt;
&lt;li&gt;%T – 时间戳&lt;/li&gt;
&lt;li&gt;source – 简而言之就是将文件内容发送给shell来执行&lt;/li&gt;
&lt;li&gt;.bashrc – BASH以交互方式启动时运行的脚本文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="history命令输出的日志" src="http://www.tecmint.com/wp-content/uploads/2015/03/History-Command-Logs.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图3：&lt;code&gt;history&lt;/code&gt;命令输出的日志&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;2. 如何测试磁盘写入速度？&lt;/h3&gt;
&lt;p&gt;一行&lt;code&gt;dd&lt;/code&gt;命令脚本就可以实现。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# dd if=/dev/zero of=/tmp/output.img bs=8k count=256k conv=fdatasync; rm -rf /tmp/output.img
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="dd命令例子" src="http://www.tecmint.com/wp-content/uploads/2015/03/dd-Command-Example.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图4：&lt;code&gt;dd&lt;/code&gt;命令例子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;命令和选项的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dd – 转换和复制文件&lt;/li&gt;
&lt;li&gt;if=/dev/zero – 指定输入文件，默认为stdin（标准输入）&lt;/li&gt;
&lt;li&gt;of=/tmp/output.img – 指定输出文件，默认为stdout（标准输出）&lt;/li&gt;
&lt;li&gt;bs – 一次读和写的块大小，最大可以以MB为单位&lt;/li&gt;
&lt;li&gt;count – 复制次数&lt;/li&gt;
&lt;li&gt;conv – 使用逗号分隔的策略来转换文件（LCTT 译注：比如将大写字母转换成小写，echo AA | dd conv=lcase）&lt;/li&gt;
&lt;li&gt;rm – 删除文件和目录&lt;/li&gt;
&lt;li&gt;-rf – （-r） 递归地删除目录和其中的内容，（-f）强行删除而不输出确认信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. 你如何获取吃掉你磁盘空间的最大的6个文件？&lt;/h3&gt;
&lt;p&gt;一个使用&lt;a href="http://www.tecmint.com/check-linux-disk-usage-of-files-and-directories/"&gt;&lt;code&gt;du&lt;/code&gt;命令&lt;/a&gt;的简单单行脚本即可实现，&lt;code&gt;du&lt;/code&gt;命令主要用于获取文件的空间使用情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# du -hsx * | sort -rh | head -6
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="获取磁盘空间使用情况的方法" src="http://www.tecmint.com/wp-content/uploads/2015/03/check-disk-space-usage.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图5：获取磁盘空间使用情况的方法&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;命令和选项的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;du – 估计文件的空间使用情况&lt;/li&gt;
&lt;li&gt;-hsx – （-h）更易读的格式，（-s）汇总输出，（-x）跳过其他文件系统的文件&lt;/li&gt;
&lt;li&gt;sort – 对文本文件按行排序&lt;/li&gt;
&lt;li&gt;-rf – （-r）将比较的结果逆序输出，（-f）忽略大小写&lt;/li&gt;
&lt;li&gt;head – 输出文件的头几行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4. 获取一个文件的详细状态信息&lt;/h3&gt;
&lt;p&gt;可以使用&lt;code&gt;stat&lt;/code&gt;命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# stat filename_ext  （例如：stat abc.pdf）
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="获取文件的详细信息" src="http://www.tecmint.com/wp-content/uploads/2015/03/Check-File-Statistics.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图6：获取文件的详细信息&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;5. 显示帮助&lt;/h3&gt;
&lt;p&gt;最后一个技巧是为那些入门者准备的，如果你是有经验的用户，可能不需要它，除非你想从中寻找乐趣。入门者可能有Linux命令行恐惧症，下面的命令会随机显示一个man手册页。对入门者来说，好处是总会学到新的东西，而且不会厌倦。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# man $(ls /bin | shuf | head -1)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="查看随机的man手册页" src="http://www.tecmint.com/wp-content/uploads/2015/03/Generate-Random-Man-Pages.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图7：查看随机的man手册页&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;命令和选项的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;man – Linux man手册&lt;/li&gt;
&lt;li&gt;ls – 列出文件&lt;/li&gt;
&lt;li&gt;/bin – 系统可执行文件的路径&lt;/li&gt;
&lt;li&gt;shuf – 把输入内容按行随机打乱并输出&lt;/li&gt;
&lt;li&gt;head – 输出文件的头几行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是所有的内容了。如果你知道任何类似的技巧，可以分享给我们，我们会用你的语言在网站上发表出来。&lt;/p&gt;
&lt;p&gt;不要忘记在下边评论框中留下有价值的反馈。保持联系。可以点赞或者将本文分享来帮助我们更好地传播内容。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://www.tecmint.com/5-linux-command-line-tricks/&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://www.tecmint.com/author/avishek/"&gt;Avishek Kumar&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 存储时间序列数据（“Time Series Databases”第三章）</title><link href="/yi-cun-chu-shi-jian-xu-lie-shu-ju-time-series-databasesdi-san-zhang.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-cun-chu-shi-jian-xu-lie-shu-ju-time-series-databasesdi-san-zhang.html</id><summary type="html">&lt;p&gt;就像我们在前一章提到的，一个时间序列是一系列数值，每个数值都伴随着一个时间值，代表数据被记录时的时间。时间序列数据存入后就很少再需要修改了，查询时经常是查询一个连续时间段的数据，也可能查询汇总或者聚合后的数据。时间序列数据库是一种储存多个时间序列的方式，在其中检索一个或几个时间序列的某一个特定时间段的数据是特别高效的。同样地，主要用来查询一个时间段数据的应用程序也适合使用时间序列数据库来实现。像之前所解释的，本书的主题是存储和处理大规模时间序列数据，为了实现这个目标，首选技术是非关系型NoSQL数据库，比如Apache HBase或MapR-DB。&lt;/p&gt;
&lt;p&gt;为大规模时间序列数据库的实际实现提供务实的建议，是本书的目标，所以我们需要聚焦于一些可以简化和增强真实世界中应用程序发展进程的一些基本步骤。我们会简单看看适用于中小型数据集的方法，然后深入探究我们主要关注的问题：如何实现大规模TSDB。&lt;/p&gt;
&lt;p&gt;为了得到一个扎实的实现，有几种可供选择的设计方法。如何选择取决于数据的属性。有多少种不同的时间序列？获得的数据是什么类型的？使用怎样的速度采集数据？需要存储多久的数据？这些问题的答案有助于我们确定最优的实现策略。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;这一章中的主要思想路线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽管我们已经提到处理时间序列数据的一些主要方面，这一章会比之前更深入地探讨存储和访问时间序列数据的基本方法。第四章会提供如何使用现有开源软件来最好地实现这些概念的建议。这两章有比较多的内容需要理解。然后你就可以记住如果将这些关键的想法集中到一起而不是迷失在细节中，这里是一个本章内容的一个简单路线图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平面文件&lt;ul&gt;
&lt;li&gt;对时间序列数据来说是受限的工具，不适合快速增长的数据，查询起来也会效率低下&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;真正的数据库：关系型数据库&lt;ul&gt;
&lt;li&gt;扩展性不好，常见的星型模式（star schema）不适合处理时间序列数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;真正的数据库 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;就像我们在前一章提到的，一个时间序列是一系列数值，每个数值都伴随着一个时间值，代表数据被记录时的时间。时间序列数据存入后就很少再需要修改了，查询时经常是查询一个连续时间段的数据，也可能查询汇总或者聚合后的数据。时间序列数据库是一种储存多个时间序列的方式，在其中检索一个或几个时间序列的某一个特定时间段的数据是特别高效的。同样地，主要用来查询一个时间段数据的应用程序也适合使用时间序列数据库来实现。像之前所解释的，本书的主题是存储和处理大规模时间序列数据，为了实现这个目标，首选技术是非关系型NoSQL数据库，比如Apache HBase或MapR-DB。&lt;/p&gt;
&lt;p&gt;为大规模时间序列数据库的实际实现提供务实的建议，是本书的目标，所以我们需要聚焦于一些可以简化和增强真实世界中应用程序发展进程的一些基本步骤。我们会简单看看适用于中小型数据集的方法，然后深入探究我们主要关注的问题：如何实现大规模TSDB。&lt;/p&gt;
&lt;p&gt;为了得到一个扎实的实现，有几种可供选择的设计方法。如何选择取决于数据的属性。有多少种不同的时间序列？获得的数据是什么类型的？使用怎样的速度采集数据？需要存储多久的数据？这些问题的答案有助于我们确定最优的实现策略。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;这一章中的主要思想路线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽管我们已经提到处理时间序列数据的一些主要方面，这一章会比之前更深入地探讨存储和访问时间序列数据的基本方法。第四章会提供如何使用现有开源软件来最好地实现这些概念的建议。这两章有比较多的内容需要理解。然后你就可以记住如果将这些关键的想法集中到一起而不是迷失在细节中，这里是一个本章内容的一个简单路线图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平面文件&lt;ul&gt;
&lt;li&gt;对时间序列数据来说是受限的工具，不适合快速增长的数据，查询起来也会效率低下&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;真正的数据库：关系型数据库&lt;ul&gt;
&lt;li&gt;扩展性不好，常见的星型模式（star schema）不适合处理时间序列数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;真正的数据库：非关系型NoSQL数据库&lt;ul&gt;
&lt;li&gt;首选方案，因为它可扩展型好、高效、能快速响应基于时间段的查询&lt;/li&gt;
&lt;li&gt;基本设计&lt;ul&gt;
&lt;li&gt;使用包含时间序列ID的唯一row key，列是不同时间偏移的数值&lt;/li&gt;
&lt;li&gt;存储多于一个时间序列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可选设计&lt;ul&gt;
&lt;li&gt;使用宽表逐点存储数据&lt;/li&gt;
&lt;li&gt;混合宽表和blob类型的设计&lt;/li&gt;
&lt;li&gt;将数据缓存到内存，然后blob直写&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;我们已经回顾了主要思想，现在我们更详细地重温一下并且解释它们的重要性。&lt;/p&gt;
&lt;h2&gt;最简单的数据存储：平面文件&lt;/h2&gt;
&lt;p&gt;你可以扩展非常简单的设计（比如简单的二维表），使用更聪明的文件格式来使其更先进，比如列存储的Parquet格式。Parquet是一个有效并且简单的现代化格式，可以存储时间和一些可选值。图3-1展示了两种记录时间序列数据的Parquet schema。左图中的schema适合你已经知道怎么合理使用时间序列数据的情况，它是一个特定场景的存储方案。例子中，只存了明确指定的4个时间序列的数据（一个存放时间的t和一个存放数据的tempIn组合起来，为一个时间序列。t和它对应的tempIn、pressureIn、tempOut、pressureOut即4个时间序列），如果需要增加新的，就需要修改schema。右图中的Parguet schema抽象程度更高，对你想要往文件里嵌入更多元数据的场景更适合。并且这种格式没有事先对时间序列的数量做任何限制。如果你想要构建一个给其他人使用的时间序列库，右边的格式会更合适一些。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/009.png"&gt;&lt;/p&gt;
&lt;p&gt;图3-1。使用Parquet格式来存储时间序列数据的两种可能的schema。左边的schema使用固定的类型名称将问题域确定了。在不改变schema的情况下，只可以存储4个时间序列。相反地，右边的schema更加灵活，你可以增加新的时间序列。另外它的抽象层次也更高，把几个单一的时间序列（一对time、value）按照tags分组，然后放到一个单独的block中。&lt;/p&gt;
&lt;p&gt;这样的一种时间序列数据（特别是使用类似Parquet格式的情况）是非常有用的，但前提是你需要分析的时间序列数量相对较小，并且所感兴趣的时间范围相对于单个文件所存储数据的时间跨度很大（比如每个文件存放一个月的数据，你查的时候也应该每次查一个月的数据，而不是每次查一天的）。&lt;/p&gt;
&lt;p&gt;系统最初使用平面文件来实现是一种非常普遍的情况，而且不久之后这种简单的实现不再适应快速增长的数据的情况也是很普遍的。基本问题是单一文件中的时间序列数量增加了，任何特定的查询中，真正有用的数据占所读取数据的比例就下降了，因为多数读取到的数据其实是属于其他时间序列的。&lt;/p&gt;
&lt;p&gt;同样地，在文件中的时间跨度比平均查询的时间范围已经长很多的情况，真正有用的数据占所被读取数据的比例又下降了，因为文件中的大部分数据已经在你感兴趣的时间范围之外了（比如数据记录了1个月的数据，而查询时一般只查某一天的，那为了定位到这一天，需要先读大量前边的实际不需要的数据）。努力解决这些问题的同时一般又会引入其他的问题。使用大量的文件来确保每个文件中只有较少的时间序列，会使文件数量大幅增长。同样地，减少每个文件所存储数据的时间范围会使得文件数量翻倍增长。当在一个类似Apache Hadoop中HDFS的文件系统存储数据时，大量的文件会导致严重的稳定性问题。基于Hadoop的上层系统，如MapR可以轻松处理大量的文件，但检索和管理大量的小文件也是很低效的，因为需要增加很多搜索时间。&lt;/p&gt;
&lt;p&gt;为了避免这些问题，很自然的一步是转而使用某些形式的真正的数据库来存储这些数据。选择合适的数据库的方法并不是显而易见的，但基于数据库的类型和它的设计方案，你有几个选项。我们会研究这些问题来帮助你作选择。&lt;/p&gt;
&lt;h2&gt;改用真正的数据库：RDBMS怎么样？&lt;/h2&gt;
&lt;p&gt;即使是经过良好分区的平面文件，在处理大规模时间序列数据时也会力不从心，所以你也行会考虑使用某些类型的真正的数据库。当第一次在数据库中存储时间序列数据时，使用所谓的星型模式（star schema）设计，并且将数据存放到RDBMS是个很诱人的选择。在这样一种数据库设计中，核心数据存放在事实表（fact table），就像图3-2展示的那样。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/010.png"&gt;&lt;/p&gt;
&lt;p&gt;图3-2。将时间序列数据存放到RDBMS的一个事实表的设计。其中存放了时间（TIme列）、序列ID（Time series ID列）和数值（Value列）三列。序列的细节存放在维表（dimension table）中（这一对Time、Value是一个时间序列，但这个时间序列的细节，比如Value的含义是什么，存放在另一张表中，可以使用Time series ID去那个表查）。&lt;/p&gt;
&lt;p&gt;在星型模式中，一个表存储主要的数据，并且会引用其他表（维表）。该设计一个核心假定是维表要相对小巧，而且不常变动。图3-2中的时间序列事实表里，唯一被引用的维表，就是存放这个时间序列详细信息的维表，它的内容是表中数据（Value列）的含义。比如，如果我们的时间序列数据是从一个工厂的泵或者其他设备从采集的，我们会希望在获取这个泵的多个维度的数据，如入口和出口的压强和温度、泵在不同频段的震动和泵自身的温度等。这其中的每个泵的每一个维度，都是一个单独的时间序列，每个时间序列会有类似泵的序列号、位置、商标、型号等信息，这些信息都存放在维表中。&lt;/p&gt;
&lt;p&gt;实际上一些应用程序已经使用像这样的星型模式来存放时间序列数据了。我们在多数NoSQL数据库中也可以使用这样的设计。星型模式解决了有大量不同时间序列的问题，在数据点的规模达到数亿甚至数十亿的情况下也可以工作得很好。然而就像我们在第一章中看到的，即使是19世纪的航运数据也会产生上十亿的数据点。在2014年，纳斯达克证券交易所在过去三个月就会处理十亿规模的交易量。记录一个中型计算机集群的运行环境的话，一天会产生五亿的数据点。&lt;/p&gt;
&lt;p&gt;并且简单地将这些数据存储起来是一回事，对其检索和处理就是另一回事了。现代的应用程序如机器学习系统甚至状态显示系统都需要每秒检索和处理上百万的数据点。&lt;/p&gt;
&lt;p&gt;虽然RDBMS可以扩展到这些大小、速度需求的下限，但带来的消耗和引入的复杂性会急剧上升。随着数据规模的继续增长，基于RDBMS的应用程序越来越不适合处理这样规模的时间序列数据了。使用星型模式但转而使用NoSQL数据库的话，也没有特别的帮助，因为这个问题的核心是星型模式带来的，而不只是数据量。&lt;/p&gt;
&lt;h2&gt;使用宽表（wide table）的NoSQL数据库&lt;/h2&gt;
&lt;p&gt;星型模式所触及的核心问题是每次测量都要使用一行。一个增加时间序列数据库中数据检索速度的技术是在每一行存储很多数值。在一些像Apache HBase或者MapR-DB的NoSQL数据库中，列的数量几乎是不受限制的，只要任何特定一行中有数据的列的数量在几十万之内。这种能力可以被用来在每行存放多个数值。这样做的话，数据点就可以被更高速地检索，因为扫描数据的最大速度部分取决于需要扫描的行的数量，部分取决于待检索数据点的总数，部分取决于待检索数据的总量。减少行的数量，就大幅减少了一部分检索开销，检索速度就提升了。图3-3展示了使用宽表来减少时间序列数据行数量的一种方式。这个技术和OpenTSDB（一个开源的数据库，我们会在第四章详细讲到）之中使用的默认表结构很相似。需要注意这样的表设计，和那些需要提前定义详细schema的系统的表设计是很不一样的。有一件事情，如果你想把schema写下来，那将异常庞大。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/011.png"&gt;&lt;/p&gt;
&lt;p&gt;图3-3，在NoSQL时间序列数据库中一个宽表的使用。关键的结构是直观的，在真正的应用程序中，使用的会是一个二进制的格式，但这样顺序的属性是一样的。&lt;/p&gt;
&lt;p&gt;因为HBase和MapR-DB都是按照主键的顺序来存储数据，图3-3中的键设计会导致每行包含一小段时间的数据在磁盘上是连续存储的（因为Row key是按时间顺序增长，HBase和MapR-DB是按列族存放数据的，Data values中的数据就会全部按照时间顺序存放在磁盘上）。这个设计意味着检索一个特定时间段的数据，涉及的主要是顺序磁盘操作，就会比数据按行分散开的情况快很多。为了从这个表结构获得性能优势，每个时间窗口的采样点要足够富裕，这样就可以减少行的数量，从而提升检索速度。典型情况，时间窗口会被调整成每一行包括100-1000采样点的样子。&lt;/p&gt;
&lt;h2&gt;混合模式设计的NoSQL数据库&lt;/h2&gt;
&lt;p&gt;图3-3中的表设计可以继续改进，通过将一行中的所有数据压缩成一个单一的被称作blob的数据结构。Blob可以高度压缩，所以需要从磁盘读取的数据量就更少了。并且，如果使用HBase来存储时间序列数据，每行只有一列的情况会减少了每列数据在HBase所使用的磁盘文件格式上的开销，这样又进一步提高了性能。图3-4的混合式表结构中，一些行的数据已经被压缩，另一些行没有。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/012.png"&gt;&lt;/p&gt;
&lt;p&gt;图3-4。在混合模式设计中，行中的数据可以被存储成一个单一的数据结构（blob）。注意实际压缩的数据更可能是二进制的格式。这里使用JSON格式显示是为了更容易理解。&lt;/p&gt;
&lt;p&gt;图3-3中的宽表格式可以进化成图3-4的压缩格式（blob样式），只要确保那些被压缩的行对应的时间窗口不会或者很少再有新增的数据。一般地，一旦时间窗口结束后，新的数据就不属于这个时间窗口了，然后对这个时间窗口中数据的压缩就可以开始了。因为在同一行中，已压缩和未压缩的数据可以共存，如果在对行压缩之后，又有新数据过来了，可以再简单地重新压缩这一行，将新数据合并进来。&lt;/p&gt;
&lt;p&gt;图3-5展示的是概念上的混合式时间序列数据库的数据流。&lt;/p&gt;
&lt;p&gt;在后台将数据从旧格式转换成blob格式，会让renderer（图3-5中所显示的）检索数据并绘制出来的速度有质的提升。例如，在4个节点的MapR集群中，数据以压缩格式存放的话，3千万的数据点可以在大概20秒内被检索、聚合、绘制出来。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/013.png"&gt;&lt;/p&gt;
&lt;p&gt;图3-5。混合式时间序列数据库的数据流。数据从数据源到达catcher，然后被插入到NoSQL数据库中。之后blob maker在后台定时将数据压缩成blob格式。数据由renderer检索和格式化。&lt;/p&gt;
&lt;h2&gt;再进一步：blob直写设计（The Direct Blob Insertion Design）&lt;/h2&gt;
&lt;p&gt;压缩旧数据依然存在一个性能瓶颈。因为数据以未压缩的格式插入进来，每个数据点到来后都需要对行做一个更新来将数值插入到数据库中。对行的更新操作会限制数据的插入速度到每个集群中的每个节点上只有每秒2万个数据点。&lt;/p&gt;
&lt;p&gt;另一方面，图3-6中的blob直写方式的数据流允许插入速度增加了大概1千倍。为什么blob直写方式会带来如此大的性能提升？基本的区别是blob maker被转移到catcher和NoSQL时间序列数据库之间了。使用这种方式，blob maker就可以从内存的数据缓存中直接读取输入的数据，而不是从存储层的宽表中提取之前已经被写入进去的数据。&lt;/p&gt;
&lt;p&gt;基本的思想是数据到达后先被存放在内存中。这些数据同时也被写入到日志文件中。这些日志文件就是图3-6中的restart logs，它们是在Hadoop系统存放的平面文件，不是存储层的一部分。Restart logs允许内存中的数据缓存被重新导入，在数据管道必须被重建的时候。&lt;/p&gt;
&lt;p&gt;在正常操作中，在时间窗口的末尾，新的内存中数据结构会被创建，现在旧的内存中数据结构就可以用来创建压缩的blob然后写入数据库了。一旦blob被写入了，日志文件就被删除了。这样就无需像之前的混合设计中将数据两次写入。在图3-5中的混合设计中，全部的输入数据流都会逐点写入到存储层，然后再被blob maker读取。读的情况和写大致一样。一旦数据被压缩成了blob，它又被写入到数据库中。相反地，在图3-6的blob直写设计的数据流中，完整的数据流只写入到内存中（这样速度很快），而不是写入到数据库中。数据在压缩成blob之前不会被写入到数据库，所以写入速度大幅提升。数据库操作的次数从之前数据点的数量变成了blob的数量，很容易将次数减少到之前几千分之一这样的量级。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/014.png"&gt;&lt;/p&gt;
&lt;p&gt;图3-6。Blob直写方式的数据流。Catcher在内存中暂存数据，并且将其写入到restart logs中。Blob maker周期地从缓存中读取数据，然后将压缩成的blob写入到数据库中。这个设计的性能提升来自于renderer可以同时从内存和数据库中获取数据。&lt;/p&gt;
&lt;p&gt;blob直写方式的优势是什么？一个真实世界的例子展示了它可以做什么。使用了这个架构，仅使用了一个10节点的MapR集群中的4个节点，就可以实现每秒往MapR-DB的表中插入超过一亿的数据点。这些节点都有着很高的性能，其中每个节点有15个CPU核、大量内存和12块高配置磁盘，但你使用多数硬件都可以达到这个性能级别的1/5到1/2。&lt;/p&gt;
&lt;p&gt;这个性能级别听起来是用来处理海量数据的，可能超出了我们所需要的处理能力，但是在第五章我们会展示为什么这样的性能是非常有用的，即使是对那些相对温和的应用程序。&lt;/p&gt;
&lt;h2&gt;为什么关系型数据库不是很合适&lt;/h2&gt;
&lt;p&gt;在这一点，询问为什么一个关系型数据库不能处理和使用混合模式的MapR-DB或者HBase所能承受的插入和分析数据的负载是公平的。当只有blob数据被插入而不使用宽表的情况，这个问题特别有趣，因为现代关系型数据库通常支持blob或者array类型。&lt;/p&gt;
&lt;p&gt;这个问题的答案是，关系型数据库主要解决的问题不是提高插入和检索数据的速度，它现在这样运行是有其合理性的。使用关系型数据库的主要原因也不是因为它有更好的性能。如果使用关系系型数据库的blob格式存储数据，就意味着需要放弃大多数其他好处。此外，SQL没有提供一个好的抽象方法，来隐藏访问blob格式数据中的细节。SQL不能用任何合理的方式来访问这些数据，并且像多行事务等特性也完全派不上用场了。事务在这里还会成为问题，因为即使不使用，它也会成为一种消耗。一个关系型数据库需要满足多行事务的需求，这使它更难被扩展到多个节点上。尽管使用如Oracle的高成本数据库可以在单个节点实现很高的性能。而使用类似Apache Hbase或者MapR-DB的NoSQL数据库，你可以简单地通过加硬件的方式实现更高的性能。&lt;/p&gt;
&lt;p&gt;为自己用不到的特性买单的模式在一些高性能系统中是存在的。为了可扩展而牺牲传统关系型数据库的一些固有特性也是常见的，但即使你这样做了，还是得不到自己想要的扩展性。在这种情况，使用类似HBase或者MapR-DB的替代方案是有实质上的好处的，因为你同时得到了性能和可扩展性。&lt;/p&gt;
&lt;h2&gt;混合模式设计：我可以从哪得到一个？&lt;/h2&gt;
&lt;p&gt;这些宽表、blob混合的表设计是非常诱人的。它们所许诺的巨大性能级别令人兴奋，而且它们能运行在有容错机制、基于Hadoop的系统（比如MapR），从运维的角度看也是很吸引人的。这些新方法都不是空想，它们已经被构建出来，并且被证明有着惊人的结果。然而我们在这里呈现的，很大程度都是概念上的东西。有真正已经实现的吗？下一章我们会讲到如何使用OpenTSDB（一个开源时间序列数据库工具）和几个开源的MapR扩展，来实现这些新的设计。结果是利用本章所描述的概念以达到高性能的时间序列数据库是现代使用场景所需要的。&lt;/p&gt;</content></entry><entry><title>[译] Inxi：获取 Linux 的系统和硬件信息</title><link href="/yi-inxihuo-qu-linux-de-xi-tong-he-ying-jian-xin-xi.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-inxihuo-qu-linux-de-xi-tong-he-ying-jian-xin-xi.html</id><summary type="html">&lt;p&gt;我们已经展示了一些不同的&lt;a href="https://linux.cn/article-1947-1.html"&gt;应用程序&lt;/a&gt;和方法来获取Linux的系统和硬件信息。在这一系列里，我们将看到如何使用&lt;strong&gt;inxi&lt;/strong&gt;来获取这些详情信息。在论坛技术支持中，它可以作为调试工具，迅速确定用户的系统配置和硬件信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Inxi&lt;/strong&gt;是一个可以获取完整的系统和硬件详情信息的命令行工具，内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件&lt;/li&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;li&gt;磁盘驱动器&lt;/li&gt;
&lt;li&gt;Xorg&lt;/li&gt;
&lt;li&gt;桌面环境&lt;/li&gt;
&lt;li&gt;内核&lt;/li&gt;
&lt;li&gt;GCC版本&lt;/li&gt;
&lt;li&gt;进程&lt;/li&gt;
&lt;li&gt;内存占用&lt;/li&gt;
&lt;li&gt;和其他有用的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;安装方法&lt;/h3&gt;
&lt;p&gt;Inxi在多数现代GNU/Linux操作系统的默认软件仓库中。所以我们可以简单地运行下列命令安装。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在基于Debian的发行版：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;在Fedora：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;在基于RHEL的发行版：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装EPEL软件仓库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install epel-release
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后使用如下命令安装inxi：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;使用方法&lt;/h3&gt;
&lt;p&gt;在终端运行如下命令可以获取系统的概况信息 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;我们已经展示了一些不同的&lt;a href="https://linux.cn/article-1947-1.html"&gt;应用程序&lt;/a&gt;和方法来获取Linux的系统和硬件信息。在这一系列里，我们将看到如何使用&lt;strong&gt;inxi&lt;/strong&gt;来获取这些详情信息。在论坛技术支持中，它可以作为调试工具，迅速确定用户的系统配置和硬件信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Inxi&lt;/strong&gt;是一个可以获取完整的系统和硬件详情信息的命令行工具，内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件&lt;/li&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;li&gt;磁盘驱动器&lt;/li&gt;
&lt;li&gt;Xorg&lt;/li&gt;
&lt;li&gt;桌面环境&lt;/li&gt;
&lt;li&gt;内核&lt;/li&gt;
&lt;li&gt;GCC版本&lt;/li&gt;
&lt;li&gt;进程&lt;/li&gt;
&lt;li&gt;内存占用&lt;/li&gt;
&lt;li&gt;和其他有用的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;安装方法&lt;/h3&gt;
&lt;p&gt;Inxi在多数现代GNU/Linux操作系统的默认软件仓库中。所以我们可以简单地运行下列命令安装。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在基于Debian的发行版：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;在Fedora：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;在基于RHEL的发行版：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装EPEL软件仓库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install epel-release
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后使用如下命令安装inxi：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;使用方法&lt;/h3&gt;
&lt;p&gt;在终端运行如下命令可以获取系统的概况信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CPU~Dual core Intel Core i3-2350M CPU (-HT-MCP-) clocked at Min:800.000Mhz Max:1200.000Mhz Kernel~3.13.0-45-generic x86_64 Up~6:41 Mem~1537.7/3861.3MB HDD~500.1GB(52.5% used) Procs~183 Client~Shell inxi~1.9.17
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，我们可以获取一个特定硬件的详情信息。比如获取&lt;strong&gt;声音/音频硬件详情信息&lt;/strong&gt;，可以运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -A
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Audio&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="n"&gt;Card&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;Series&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;C200&lt;/span&gt; &lt;span class="n"&gt;Series&lt;/span&gt; &lt;span class="n"&gt;Family&lt;/span&gt; &lt;span class="n"&gt;High&lt;/span&gt; &lt;span class="n"&gt;Definition&lt;/span&gt; &lt;span class="n"&gt;Audio&lt;/span&gt; &lt;span class="n"&gt;Controller&lt;/span&gt; &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;snd_hda_intel&lt;/span&gt; 
           &lt;span class="n"&gt;Sound&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Advanced&lt;/span&gt; &lt;span class="n"&gt;Linux&lt;/span&gt; &lt;span class="n"&gt;Sound&lt;/span&gt; &lt;span class="n"&gt;Architecture&lt;/span&gt; &lt;span class="n"&gt;ver&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;k3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mf"&gt;13.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;generic&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;很酷是吧？&lt;/p&gt;
&lt;p&gt;同样的，你可以获取&lt;strong&gt;显卡&lt;/strong&gt;的详情信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -G
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;Graphics&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="nl"&gt;Card&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt; &lt;span class="n"&gt;Generation&lt;/span&gt; &lt;span class="n"&gt;Core&lt;/span&gt; &lt;span class="n"&gt;Processor&lt;/span&gt; &lt;span class="n"&gt;Family&lt;/span&gt; &lt;span class="n"&gt;Integrated&lt;/span&gt; &lt;span class="n"&gt;Graphics&lt;/span&gt; &lt;span class="n"&gt;Controller&lt;/span&gt; 
           &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nl"&gt;Org&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;1.15.1&lt;/span&gt; &lt;span class="nl"&gt;drivers&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;intel&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;unloaded&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fbdev&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;vesa&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;Resolution&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1366&lt;/span&gt;&lt;span class="n"&gt;x768&lt;/span&gt;&lt;span class="mf"&gt;@60.0&lt;/span&gt;&lt;span class="n"&gt;hz&lt;/span&gt; 
           &lt;span class="n"&gt;GLX&lt;/span&gt; &lt;span class="nl"&gt;Renderer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="n"&gt;DRI&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="n"&gt;Sandybridge&lt;/span&gt; &lt;span class="n"&gt;Mobile&lt;/span&gt; &lt;span class="n"&gt;GLX&lt;/span&gt; &lt;span class="nl"&gt;Version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;3.0&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="mf"&gt;10.3.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;硬盘信息呢？也是可以的。运行如下命令来获取完整的&lt;strong&gt;硬盘&lt;/strong&gt;信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -D
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Drives&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;HDD&lt;/span&gt; &lt;span class="n"&gt;Total&lt;/span&gt; &lt;span class="n"&gt;Size&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;500.1&lt;/span&gt;&lt;span class="n"&gt;GB&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;52.5&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="sr"&gt;/dev/s&lt;/span&gt;&lt;span class="n"&gt;da&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ST9601325BD&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;500.1&lt;/span&gt;&lt;span class="n"&gt;GB&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;显示Bios和主板详情信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -M
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Machine&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Dell&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;portable&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;product&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Inspiron&lt;/span&gt; &lt;span class="n"&gt;N5050&lt;/span&gt;
           &lt;span class="n"&gt;Mobo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Dell&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;01&lt;/span&gt;&lt;span class="n"&gt;HXXJ&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A05&lt;/span&gt; &lt;span class="n"&gt;Bios&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Dell&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A05&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;&lt;span class="sr"&gt;/03/&lt;/span&gt;&lt;span class="mi"&gt;2012&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不仅是硬性详情信息，它也可以显示我们系统中的&lt;strong&gt;可用软件仓库列表&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -r
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;Repos:&lt;/span&gt;     &lt;span class="err"&gt;Active&lt;/span&gt; &lt;span class="err"&gt;apt&lt;/span&gt; &lt;span class="err"&gt;sources&lt;/span&gt; &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;file:&lt;/span&gt; &lt;span class="err"&gt;/etc/apt/sources.list&lt;/span&gt;
           &lt;span class="err"&gt;deb&lt;/span&gt; &lt;span class="err"&gt;http://ubuntu.excellmedia.net/archive/&lt;/span&gt; &lt;span class="err"&gt;trusty&lt;/span&gt; &lt;span class="err"&gt;main&lt;/span&gt; &lt;span class="err"&gt;restricted&lt;/span&gt;
           &lt;span class="err"&gt;deb-src&lt;/span&gt; &lt;span class="err"&gt;http://ubuntu.excellmedia.net/archive/&lt;/span&gt; &lt;span class="err"&gt;trusty&lt;/span&gt; &lt;span class="err"&gt;main&lt;/span&gt; &lt;span class="err"&gt;restricted&lt;/span&gt;
           &lt;span class="err"&gt;deb&lt;/span&gt; &lt;span class="err"&gt;http://ubuntu.excellmedia.net/archive/&lt;/span&gt; &lt;span class="err"&gt;trusty-updates&lt;/span&gt; &lt;span class="err"&gt;main&lt;/span&gt; &lt;span class="err"&gt;restricted&lt;/span&gt;
           &lt;span class="err"&gt;deb-src&lt;/span&gt; &lt;span class="err"&gt;http://ubuntu.excellmedia.net/archive/&lt;/span&gt; &lt;span class="err"&gt;trusty-updates&lt;/span&gt; &lt;span class="err"&gt;main&lt;/span&gt; &lt;span class="err"&gt;restricted&lt;/span&gt;
           &lt;span class="err"&gt;deb&lt;/span&gt; &lt;span class="err"&gt;http://ubuntu.excellmedia.net/archive/&lt;/span&gt; &lt;span class="err"&gt;trusty&lt;/span&gt; &lt;span class="err"&gt;universe&lt;/span&gt;
           &lt;span class="err"&gt;.&lt;/span&gt;
           &lt;span class="err"&gt;.&lt;/span&gt;
           &lt;span class="err"&gt;Active&lt;/span&gt; &lt;span class="err"&gt;apt&lt;/span&gt; &lt;span class="err"&gt;sources&lt;/span&gt; &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;file:&lt;/span&gt; &lt;span class="err"&gt;/etc/apt/sources.list.d/intellinuxgraphics.list&lt;/span&gt;
           &lt;span class="err"&gt;deb&lt;/span&gt; &lt;span class="err"&gt;https://download.01.org/gfx/ubuntu/14.04/main&lt;/span&gt; &lt;span class="err"&gt;trusty&lt;/span&gt; &lt;span class="err"&gt;main&lt;/span&gt; &lt;span class="c"&gt;#Intel Graphics drivers&lt;/span&gt;
           &lt;span class="err"&gt;Active&lt;/span&gt; &lt;span class="err"&gt;apt&lt;/span&gt; &lt;span class="err"&gt;sources&lt;/span&gt; &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;file:&lt;/span&gt; &lt;span class="err"&gt;/etc/apt/sources.list.d/linrunner-tlp-trusty.list&lt;/span&gt;
           &lt;span class="err"&gt;Active&lt;/span&gt; &lt;span class="err"&gt;apt&lt;/span&gt; &lt;span class="err"&gt;sources&lt;/span&gt; &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;file:&lt;/span&gt; &lt;span class="err"&gt;/etc/apt/sources.list.d/wseverin-ppa-trusty.list&lt;/span&gt;
           &lt;span class="err"&gt;deb&lt;/span&gt; &lt;span class="err"&gt;http://ppa.launchpad.net/wseverin/ppa/ubuntu&lt;/span&gt; &lt;span class="err"&gt;trusty&lt;/span&gt; &lt;span class="err"&gt;main&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Inxi还可以显示你所在位置的天气信息。感到意外吗？是的，它可以。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -W Erode,Tamilnadu
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里&lt;strong&gt;Erode&lt;/strong&gt;是地区，&lt;strong&gt;Tamilnadu&lt;/strong&gt;是印度的一个邦。&lt;/p&gt;
&lt;p&gt;示例输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Weather&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;Conditions&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;79&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Clear&lt;/span&gt; &lt;span class="n"&gt;Time&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;February&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt; &lt;span class="n"&gt;PM&lt;/span&gt; &lt;span class="n"&gt;IST&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;查看完整的硬件详情信息&lt;/h3&gt;
&lt;p&gt;厌倦了逐一获取每种硬件的信息？你可以使用如下命令将所有信息一次列出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -F
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;System&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;    &lt;span class="nl"&gt;Host&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;sk&lt;/span&gt; &lt;span class="nl"&gt;Kernel&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;3.13.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;generic&lt;/span&gt; &lt;span class="n"&gt;x86_64&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt; &lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;Desktop&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;LXDE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Openbox&lt;/span&gt; &lt;span class="mf"&gt;3.5.2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;Distro&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Ubuntu&lt;/span&gt; &lt;span class="mf"&gt;14.04&lt;/span&gt; &lt;span class="n"&gt;trusty&lt;/span&gt;
&lt;span class="nl"&gt;Machine&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;   &lt;span class="nl"&gt;System&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Dell&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;portable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;product&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Inspiron&lt;/span&gt; &lt;span class="n"&gt;N5050&lt;/span&gt;
           &lt;span class="nl"&gt;Mobo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Dell&lt;/span&gt; &lt;span class="nl"&gt;model&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;01&lt;/span&gt;&lt;span class="n"&gt;HXXJ&lt;/span&gt; &lt;span class="nl"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A05&lt;/span&gt; &lt;span class="nl"&gt;Bios&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Dell&lt;/span&gt; &lt;span class="nl"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A05&lt;/span&gt; &lt;span class="nl"&gt;date&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mo"&gt;03&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2012&lt;/span&gt;
&lt;span class="nl"&gt;CPU&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="n"&gt;Dual&lt;/span&gt; &lt;span class="n"&gt;core&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="n"&gt;Core&lt;/span&gt; &lt;span class="n"&gt;i3&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2350&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="n"&gt;CPU&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;HT&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;MCP&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;cache&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3072&lt;/span&gt; &lt;span class="n"&gt;KB&lt;/span&gt; &lt;span class="nl"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lm&lt;/span&gt; &lt;span class="n"&gt;nx&lt;/span&gt; &lt;span class="n"&gt;sse&lt;/span&gt; &lt;span class="n"&gt;sse2&lt;/span&gt; &lt;span class="n"&gt;sse3&lt;/span&gt; &lt;span class="n"&gt;sse4_1&lt;/span&gt; &lt;span class="n"&gt;sse4_2&lt;/span&gt; &lt;span class="n"&gt;ssse3&lt;/span&gt; &lt;span class="n"&gt;vmx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
           &lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="nl"&gt;Speeds&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;800.00&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;1000.00&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;800.00&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;800.00&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="nl"&gt;Graphics&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="nl"&gt;Card&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt; &lt;span class="n"&gt;Generation&lt;/span&gt; &lt;span class="n"&gt;Core&lt;/span&gt; &lt;span class="n"&gt;Processor&lt;/span&gt; &lt;span class="n"&gt;Family&lt;/span&gt; &lt;span class="n"&gt;Integrated&lt;/span&gt; &lt;span class="n"&gt;Graphics&lt;/span&gt; &lt;span class="n"&gt;Controller&lt;/span&gt; 
           &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nl"&gt;Org&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;1.15.1&lt;/span&gt; &lt;span class="nl"&gt;drivers&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;intel&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;unloaded&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fbdev&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;vesa&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;Resolution&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1366&lt;/span&gt;&lt;span class="n"&gt;x768&lt;/span&gt;&lt;span class="mf"&gt;@60.0&lt;/span&gt;&lt;span class="n"&gt;hz&lt;/span&gt; 
           &lt;span class="n"&gt;GLX&lt;/span&gt; &lt;span class="nl"&gt;Renderer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="n"&gt;DRI&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="n"&gt;Sandybridge&lt;/span&gt; &lt;span class="n"&gt;Mobile&lt;/span&gt; &lt;span class="n"&gt;GLX&lt;/span&gt; &lt;span class="nl"&gt;Version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;3.0&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="mf"&gt;10.3.0&lt;/span&gt;
&lt;span class="nl"&gt;Audio&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;     &lt;span class="nl"&gt;Card&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;Series&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;C200&lt;/span&gt; &lt;span class="n"&gt;Series&lt;/span&gt; &lt;span class="n"&gt;Family&lt;/span&gt; &lt;span class="n"&gt;High&lt;/span&gt; &lt;span class="n"&gt;Definition&lt;/span&gt; &lt;span class="n"&gt;Audio&lt;/span&gt; &lt;span class="n"&gt;Controller&lt;/span&gt; &lt;span class="nl"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;snd_hda_intel&lt;/span&gt; 
           &lt;span class="nl"&gt;Sound&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Advanced&lt;/span&gt; &lt;span class="n"&gt;Linux&lt;/span&gt; &lt;span class="n"&gt;Sound&lt;/span&gt; &lt;span class="n"&gt;Architecture&lt;/span&gt; &lt;span class="nl"&gt;ver&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;k3&lt;/span&gt;&lt;span class="mf"&gt;.13.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;generic&lt;/span&gt;
&lt;span class="nl"&gt;Network&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;Card&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Qualcomm&lt;/span&gt; &lt;span class="n"&gt;Atheros&lt;/span&gt; &lt;span class="n"&gt;AR9285&lt;/span&gt; &lt;span class="n"&gt;Wireless&lt;/span&gt; &lt;span class="n"&gt;Network&lt;/span&gt; &lt;span class="n"&gt;Adapter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PCI&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Express&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ath9k&lt;/span&gt; 
           &lt;span class="nl"&gt;IF&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;wlan0&lt;/span&gt; &lt;span class="nl"&gt;state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;up&lt;/span&gt; &lt;span class="nl"&gt;mac&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
           &lt;span class="n"&gt;Card&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Realtek&lt;/span&gt; &lt;span class="n"&gt;RTL8101E&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;RTL8102E&lt;/span&gt; &lt;span class="n"&gt;PCI&lt;/span&gt; &lt;span class="n"&gt;Express&lt;/span&gt; &lt;span class="n"&gt;Fast&lt;/span&gt; &lt;span class="n"&gt;Ethernet&lt;/span&gt; &lt;span class="n"&gt;controller&lt;/span&gt; &lt;span class="nl"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;r8169&lt;/span&gt; 
           &lt;span class="nl"&gt;IF&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;eth0&lt;/span&gt; &lt;span class="nl"&gt;state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;down&lt;/span&gt; &lt;span class="nl"&gt;mac&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;Drives&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;HDD&lt;/span&gt; &lt;span class="n"&gt;Total&lt;/span&gt; &lt;span class="nl"&gt;Size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;500.1&lt;/span&gt;&lt;span class="n"&gt;GB&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;52.5&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sda&lt;/span&gt; &lt;span class="nl"&gt;model&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ST9500325AS&lt;/span&gt; &lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;500.1&lt;/span&gt;&lt;span class="n"&gt;GB&lt;/span&gt; 
&lt;span class="nl"&gt;Partition&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;ID&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;455&lt;/span&gt;&lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="nl"&gt;used&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;245&lt;/span&gt;&lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;57&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ext4&lt;/span&gt; &lt;span class="nl"&gt;ID&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;boot&lt;/span&gt; &lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;236&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="nl"&gt;used&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;159&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;72&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ext2&lt;/span&gt; 
           &lt;span class="nl"&gt;ID&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;4.19&lt;/span&gt;&lt;span class="n"&gt;GB&lt;/span&gt; &lt;span class="nl"&gt;used&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.00&lt;/span&gt;&lt;span class="n"&gt;GB&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt; 
&lt;span class="nl"&gt;RAID&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;      &lt;span class="n"&gt;No&lt;/span&gt; &lt;span class="n"&gt;RAID&lt;/span&gt; &lt;span class="n"&gt;devices&lt;/span&gt; &lt;span class="n"&gt;detected&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;proc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mdstat&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;md_mod&lt;/span&gt; &lt;span class="n"&gt;kernel&lt;/span&gt; &lt;span class="n"&gt;raid&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="n"&gt;present&lt;/span&gt;
&lt;span class="nl"&gt;Sensors&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;System&lt;/span&gt; &lt;span class="nl"&gt;Temperatures&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;64.5&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="nl"&gt;mobo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; 
           &lt;span class="n"&gt;Fan&lt;/span&gt; &lt;span class="n"&gt;Speeds&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;rpm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; 
&lt;span class="nl"&gt;Info&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;      &lt;span class="nl"&gt;Processes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;186&lt;/span&gt; &lt;span class="nl"&gt;Uptime&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;52&lt;/span&gt; &lt;span class="nl"&gt;Memory&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;1547.2&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;3861.3&lt;/span&gt;&lt;span class="n"&gt;MB&lt;/span&gt; &lt;span class="nl"&gt;Client&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Shell&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;inxi&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;1.9.17&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就像上面你看到的那样，inxi显示出了完整的硬件详情信息。&lt;/p&gt;
&lt;p&gt;更多的细节可以参考man手册。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;man inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;结论&lt;/h3&gt;
&lt;p&gt;你在寻找一个可以显示完整的系统和硬件详情信息的简单工具吗？那么不用再找了，inxi会提供你所需要的。并且，它还是在你系统默认的软件仓库中的轻量级工具。你还想要更多东西吗？试一试它，你不会失望。&lt;/p&gt;
&lt;p&gt;欢呼吧！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://www.unixmen.com/inxi-find-system-hardware-information-linux/&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://www.unixmen.com/author/sk/"&gt;SK&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] Linux 用户的 3 个命令行小技巧</title><link href="/yi-linux-yong-hu-de-3-ge-ming-ling-xing-xiao-ji-qiao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-linux-yong-hu-de-3-ge-ming-ling-xing-xiao-ji-qiao.html</id><summary type="html">&lt;p&gt;Linux世界充满了乐趣，我们越深入进去，就会发现越多有趣的事物。我们会努力给你提供一些小技巧，让你和其他人有所不同，下面就是我们准备的3个小技巧。&lt;/p&gt;
&lt;h3&gt;1. 如何在不使用Cron的情况调度Linux下的任务&lt;/h3&gt;
&lt;p&gt;在Linux下，调度一个任务/命令称之为Cron。当我们需要调度一个任务时，我们会使用Cron，但你知道我们在不使用Cron的情况也可以调度一个在将来时间运行的任务吗？你可以按照如下建议操作……&lt;/p&gt;
&lt;p&gt;每5秒钟运行一个命令（date）然后将结果写入到一个文件（data.txt）。为了实现这一点，我们可以直接在命令提示符运行如下单行脚本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="k"&gt;while&lt;/span&gt; true&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; date &amp;gt;&amp;gt; date.txt &lt;span class="p"&gt;;&lt;/span&gt; sleep &lt;span class="m"&gt;5&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述脚本的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while true&lt;/code&gt; ：让脚本进入一个条件总为真的循环中，也就是制造一个死循环，将里边的命令一遍遍地重复运行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;do&lt;/code&gt; ：&lt;code&gt;do&lt;/code&gt;是&lt;code&gt;while&lt;/code&gt;语句中的关键字，它之后的命令会被执行，在它后边可以放置一个或一系列命令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;date &amp;gt;&amp;gt; date.txt&lt;/code&gt; ：运行date命令，并将其输出写入到data.txt文件中 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Linux世界充满了乐趣，我们越深入进去，就会发现越多有趣的事物。我们会努力给你提供一些小技巧，让你和其他人有所不同，下面就是我们准备的3个小技巧。&lt;/p&gt;
&lt;h3&gt;1. 如何在不使用Cron的情况调度Linux下的任务&lt;/h3&gt;
&lt;p&gt;在Linux下，调度一个任务/命令称之为Cron。当我们需要调度一个任务时，我们会使用Cron，但你知道我们在不使用Cron的情况也可以调度一个在将来时间运行的任务吗？你可以按照如下建议操作……&lt;/p&gt;
&lt;p&gt;每5秒钟运行一个命令（date）然后将结果写入到一个文件（data.txt）。为了实现这一点，我们可以直接在命令提示符运行如下单行脚本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="k"&gt;while&lt;/span&gt; true&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; date &amp;gt;&amp;gt; date.txt &lt;span class="p"&gt;;&lt;/span&gt; sleep &lt;span class="m"&gt;5&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述脚本的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while true&lt;/code&gt; ：让脚本进入一个条件总为真的循环中，也就是制造一个死循环，将里边的命令一遍遍地重复运行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;do&lt;/code&gt; ：&lt;code&gt;do&lt;/code&gt;是&lt;code&gt;while&lt;/code&gt;语句中的关键字，它之后的命令会被执行，在它后边可以放置一个或一系列命令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;date &amp;gt;&amp;gt; date.txt&lt;/code&gt; ：运行date命令，并将其输出写入到data.txt文件中。注意我们使用&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;，而不是&lt;code&gt;&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ：对文件（date.txt）进行追加写的操作，这样每次运行命令后，输出内容会被追加到文件中。如果使用&lt;code&gt;&amp;gt;&lt;/code&gt;的话，则会一遍遍地覆盖之前的内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sleep 5&lt;/code&gt; ：让脚本处于5秒睡眠状态，然后再运行之后的命令。注意这里的时间单位只能用秒。也就是说如果你想让命令每6分钟运行一次，你应该使用&lt;code&gt;sleep 360&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;done&lt;/code&gt; ：&lt;code&gt;while&lt;/code&gt;循环语句块结束的标记。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; ：将整个进程放到后台运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似地，我们可以这样运行任何脚本。下边的例子是每100秒运行一个名为&lt;code&gt;script_name.sh&lt;/code&gt;的脚本。&lt;/p&gt;
&lt;p&gt;另外值得一提的是上面提到的脚本文件必须处于当前目录中，否则需要使用完整路径（&lt;code&gt;/home/$USER/…/script_name.sh&lt;/code&gt;）。实现如上功能的单行脚本如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="k"&gt;while&lt;/span&gt; true&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; /bin/sh script_name.sh &lt;span class="p"&gt;;&lt;/span&gt; sleep &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：上述的单行脚本并不是Cron的替代品，因为Cron工具支持众多选项，更加灵活，可定制性也更高。然而如果我们想运行某些测试，比如I/O评测，上述的单行脚本也管用。&lt;/p&gt;
&lt;p&gt;还可以参考：&lt;a href="http://www.tecmint.com/11-cron-scheduling-task-examples-in-linux/"&gt;Linux 下 11 个定时调度任务例子&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2. 如何不使用clear命令清空终端的内容&lt;/h3&gt;
&lt;p&gt;你如何清空终端的内容？你可能会认为这是一个傻问题。好吧，大家都清楚可以使用&lt;code&gt;clear&lt;/code&gt;命令。如果养成使用&lt;code&gt;ctrl + l&lt;/code&gt;快捷键的习惯，我们会节省大量时间。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ctrl + l&lt;/code&gt;快捷键的效果和&lt;code&gt;clear&lt;/code&gt;命令一样。所以下一次你就可以使用&lt;code&gt;ctrl + l&lt;/code&gt;来清空终端的内容了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：因为&lt;code&gt;ctrl + l&lt;/code&gt;是一个快捷键，我们不可以在脚本中使用。所以如果我们需要在脚本中清空屏幕内容，还是需要使用&lt;code&gt;clear&lt;/code&gt;命令。但我能想到的所有其他情况，&lt;code&gt;ctrl + l&lt;/code&gt;都更加有效。&lt;/p&gt;
&lt;h3&gt;3. 在其它目录运行一个命令，然后自动返回当前工作目录&lt;/h3&gt;
&lt;p&gt;这是一个很多人可能不知道的令人吃惊的技巧。你可能想在其它目录运行任何一个命令，然后再回到当前目录。要实现这样的目的，你只需要将命令放在一个圆括号里。&lt;/p&gt;
&lt;p&gt;我们来看一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;avi@deb:~$ (cd /home/avi/Downloads/)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; avi@deb:~
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;它首先会cd到Downloads目录，然后又回到了之前的家目录。也许你认为里边的命令根本没有执行，或者是出了某种错误，因为从命令提示符看不出任何变化。让我们简单修改一下这个命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;avi@deb:~$ (cd /home/avi/Downloads/ &amp;amp;&amp;amp; ls -l)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-rw-r-----  1 avi  avi     54272 May  3 18:37 text1.txt
-rw-r-----  1 avi  avi     54272 May  3 18:37 text2.txt
-rw-r-----  1 avi  avi     54272 May  3 18:37 text3.txt
avi@deb:~$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在上述命令中，它首先进入Downloads目录，然后列出文件内容，最后又回到了当前目录。并且它证明了命令成功执行了。你可以在括号中包含任何命令，执行完都会顺利返回到当前目录。&lt;/p&gt;
&lt;p&gt;这就是全部内容了，如果你知道任何类似的Linux技巧，你可以在文章下面的评论框中分享给我们，不要忘记将本文和朋友分享 :)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://www.tecmint.com/useful-linux-hacks-commands/&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://www.tecmint.com/author/avishek/"&gt;Avishek Kumar&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="https://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 如何使用 Monit 部署服务器监控系统</title><link href="/yi-ru-he-shi-yong-monit-bu-shu-fu-wu-qi-jian-kong-xi-tong.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-ru-he-shi-yong-monit-bu-shu-fu-wu-qi-jian-kong-xi-tong.html</id><summary type="html">&lt;p&gt;很多Linux系统管理员依赖一个集中式的远程监控系统（比如&lt;a href="http://xmodulo.com/monitor-common-services-nagios.html"&gt;Nagios&lt;/a&gt;或者&lt;a href="http://xmodulo.com/monitor-linux-servers-snmp-cacti.html"&gt;Cacti&lt;/a&gt;）来检查他们网络基础设备的健康状况。虽然集中式监控让管理员的生活更简单了，然而处理很多机器和服务时，专用的监控中心显然成为了一个单点故障，如果监控中心挂了或者因为什么原因（比如硬件或者网络故障）不可访问了，你就会失去整个网络基础设备情况的任何信息。&lt;/p&gt;
&lt;p&gt;一个给你的监控系统增加冗余度的方法是安装独立的监控软件（作为后备），至少在网络中的关键/核心服务器上。这样在集中式监控系统挂掉的情况，你还有能力通过后备的监控方式来获取核心服务器的运行状况。&lt;/p&gt;
&lt;h3&gt;Monit是什么？&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://mmonit.com/monit/"&gt;Monit&lt;/a&gt;是一个跨平台的用来监控Unix/linux系统（比如Linux、BSD、OSX、Solaris）的工具。Monit特别易于安装，而且非常轻量级（只有500KB大小），并且不依赖任何第三方程序、插件或者库。然而，Monit可以胜任全面监控、进程状态监控、文件系统变动监控、邮件通知和对核心服务的自定义动作等场景。易于安装、轻量级的实现以及强大的功能，让Monit成为一个理想的后备监控工具。&lt;/p&gt;
&lt;p&gt;我已经在一些机器使用Monit几年了，而且我对它的可靠性非常满意。甚至作为全面的监控系统，对任何Linux系统管理员来说Monit也是非常有用和强大的。在这篇教程中，我会展示如何在一个本地服务器部署Monit（作为后备监控系统）来监控常见的服务。在部署过程中 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;很多Linux系统管理员依赖一个集中式的远程监控系统（比如&lt;a href="http://xmodulo.com/monitor-common-services-nagios.html"&gt;Nagios&lt;/a&gt;或者&lt;a href="http://xmodulo.com/monitor-linux-servers-snmp-cacti.html"&gt;Cacti&lt;/a&gt;）来检查他们网络基础设备的健康状况。虽然集中式监控让管理员的生活更简单了，然而处理很多机器和服务时，专用的监控中心显然成为了一个单点故障，如果监控中心挂了或者因为什么原因（比如硬件或者网络故障）不可访问了，你就会失去整个网络基础设备情况的任何信息。&lt;/p&gt;
&lt;p&gt;一个给你的监控系统增加冗余度的方法是安装独立的监控软件（作为后备），至少在网络中的关键/核心服务器上。这样在集中式监控系统挂掉的情况，你还有能力通过后备的监控方式来获取核心服务器的运行状况。&lt;/p&gt;
&lt;h3&gt;Monit是什么？&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://mmonit.com/monit/"&gt;Monit&lt;/a&gt;是一个跨平台的用来监控Unix/linux系统（比如Linux、BSD、OSX、Solaris）的工具。Monit特别易于安装，而且非常轻量级（只有500KB大小），并且不依赖任何第三方程序、插件或者库。然而，Monit可以胜任全面监控、进程状态监控、文件系统变动监控、邮件通知和对核心服务的自定义动作等场景。易于安装、轻量级的实现以及强大的功能，让Monit成为一个理想的后备监控工具。&lt;/p&gt;
&lt;p&gt;我已经在一些机器使用Monit几年了，而且我对它的可靠性非常满意。甚至作为全面的监控系统，对任何Linux系统管理员来说Monit也是非常有用和强大的。在这篇教程中，我会展示如何在一个本地服务器部署Monit（作为后备监控系统）来监控常见的服务。在部署过程中，我只会展示我们用到的部分。&lt;/p&gt;
&lt;h3&gt;在Linux安装Monit&lt;/h3&gt;
&lt;p&gt;Monit已经被包含在多数Linux发行版的软件仓库中了。&lt;/p&gt;
&lt;p&gt;Debian、Ubuntu或者Linux Mint：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo aptitude install monit
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Fedora或者CentOS/RHEL：&lt;/p&gt;
&lt;p&gt;在CentOS/RHEL中，你必须首先启用&lt;a href="https://linux.cn/article-2324-1.html"&gt;EPEL&lt;/a&gt;或者&lt;a href="http://xmodulo.com/how-to-set-up-rpmforge-repoforge-repository-on-centos.html"&gt;Repoforge&lt;/a&gt;软件仓库.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# yum install monit
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Monit自带一个文档完善的配置文件，其中包含了很多例子。主配置文件在/etc/monit.conf（Fedora/CentOS/RHEL 中），或者/etc/monit/monitrc（Debian/Ubuntu/Mint 中）。Monit配置文件有两部分：“Global”（全局）和“Services”（服务）。&lt;/p&gt;
&lt;h3&gt;Global Configuration: Web Status Page （全局配置：Web状态页面）&lt;/h3&gt;
&lt;p&gt;Monit可以使用邮件服务来发送通知，也可以使用HTTP/HTTPS页面来展示。我们先使用如下配置的web状态页面吧：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Monit监听1966端口。&lt;/li&gt;
&lt;li&gt;对web状态页面的访问是通过SSL加密的。&lt;/li&gt;
&lt;li&gt;使用monituser/romania作为用户名/口令登录。&lt;/li&gt;
&lt;li&gt;只允许通过localhost、myhost.mydomain.ro和在局域网内部（192.168.0.0/16）访问。&lt;/li&gt;
&lt;li&gt;Monit使用pem格式的SSL证书。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后的步骤，我会使用一个基于Red Hat的系统。在基于Debian的系统中的步骤也是类似的。&lt;/p&gt;
&lt;p&gt;首先，在/var/cert生成一个自签名的证书（monit.pem）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# mkdir /var/certs
# cd /etc/pki/tls/certs
# ./make-dummy-cert monit.pem
# cp monit.pem /var/certs
# chmod 0400 /var/certs/monit.pem
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在将下列代码片段放到Monit的主配置文件中。你可以创建一个空配置文件，或者基于自带的配置文件修改。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set httpd port 1966 and
     SSL ENABLE
     PEMFILE  /var/certs/monit.pem
     allow monituser:romania
     allow localhost
     allow 192.168.0.0/16
     allow myhost.mydomain.ro
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Global Configuration: Email Notification （全局配置：邮件通知）&lt;/h3&gt;
&lt;p&gt;然后，我们来设置Monit的邮件通知。我们至少需要一个可用的&lt;a href="http://xmodulo.com/mail-server-ubuntu-debian.html"&gt;SMTP服务器&lt;/a&gt;来让Monit发送邮件。这样就可以（按照你的实际情况修改）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邮件服务器的机器名：smtp.monit.ro&lt;/li&gt;
&lt;li&gt;Monit使用的发件人：monit@monit.ro&lt;/li&gt;
&lt;li&gt;邮件的收件人：guletz@monit.ro&lt;/li&gt;
&lt;li&gt;邮件服务器使用的SMTP端口：587（默认是25）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了以上信息，邮件通知就可以这样配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set mailserver  smtp.monit.ro port 587
set mail-format {
 from: monit@monit.ro
 subject: $SERVICE $EVENT at $DATE on $HOST
 message: Monit $ACTION $SERVICE $EVENT at $DATE on $HOST : $DESCRIPTION.

       Yours sincerely,
          Monit

  }

set alert guletz@monit.ro
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就像你看到的，Monit会提供几个内部变量（&lt;code&gt;$DATE&lt;/code&gt;、&lt;code&gt;$EVENT&lt;/code&gt;、&lt;code&gt;$HOST&lt;/code&gt;等），你可以按照你的需求自定义邮件内容。如果你想要从Monit所在机器发送邮件，就需要一个已经安装的与sendmail兼容的程序（如postfix或者ssmtp）。&lt;/p&gt;
&lt;h3&gt;Global Configuration: Monit Daemon （全局配置：Monit守护进程）&lt;/h3&gt;
&lt;p&gt;接下来就该配置Monit守护进程了。可以将其设置成这样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在120秒后进行第一次检测。&lt;/li&gt;
&lt;li&gt;每3分钟检测一次服务。&lt;/li&gt;
&lt;li&gt;使用syslog来记录日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下代码段可以满足上述需求。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set daemon 120
   with start delay 240
set logfile syslog facility log_daemon
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们必须定义“idfile”，Monit守护进程的一个独一无二的ID文件；以及“eventqueue”，当monit的邮件因为SMTP或者网络故障发不出去，邮件会暂存在这里；以及确保/var/monit路径是存在的。然后使用下边的配置就可以了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set idfile /var/monit/id
set eventqueue
     basedir /var/monit
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;测试全局配置&lt;/h3&gt;
&lt;p&gt;现在“Global”部分就完成了。Monit配置文件看起来像这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#  Global Section

# status webpage and acl&amp;#39;s
set httpd port 1966 and
     SSL ENABLE
     PEMFILE  /var/certs/monit.pem
     allow monituser:romania
     allow localhost
     allow 192.168.0.0/16
     allow myhost.mydomain.ro

# mail-server
set mailserver  smtp.monit.ro port 587
# email-format
set mail-format {
 from: monit@monit.ro
 subject: $SERVICE $EVENT at $DATE on $HOST
 message: Monit $ACTION $SERVICE $EVENT at $DATE on $HOST : $DESCRIPTION.

       Yours sincerely,
          Monit

  }

set alert guletz@monit.ro

# delay checks
set daemon 120
   with start delay 240
set logfile syslog facility log_daemon

# idfile and mail queue path
set idfile /var/monit/id
 set eventqueue
     basedir /var/monit
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在是时候验证我们的工作了，你可以通过运行如下命令来验证存在的配置文件（/etc/monit.conf）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# monit -t

Control file syntax OK
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果monit提示任何错误，请再检查下配置文件。幸运的是，错误/警告信息是可以帮助你发现问题的，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;monit&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Cannot&lt;/span&gt; &lt;span class="n"&gt;stat&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;SSL&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="n"&gt;PEM&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/var/certs/monit.pem&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;No&lt;/span&gt; &lt;span class="n"&gt;such&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;directory&lt;/span&gt;
&lt;span class="sr"&gt;/etc/monit/&lt;/span&gt;&lt;span class="n"&gt;monitrc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Warning&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;hostname&lt;/span&gt; &lt;span class="n"&gt;did&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;resolve&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;smtp.monit.ro&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一旦你确认配置文件没问题了，可以启动monit守护进程，然后等2到3分钟：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# service monit start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你使用的是systemd，运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# systemctl start monit
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在打开一个浏览器窗口，然后访问&lt;code&gt;https://&amp;lt;monit_host&amp;gt;:1966&lt;/code&gt;。将&lt;code&gt;&amp;lt;monit_host&amp;gt;&lt;/code&gt;替换成Monit所在机器的机器名或者IP地址。&lt;/p&gt;
&lt;p&gt;如果你使用的是自签名的SSL证书，你会在浏览器中看到一个警告信息。继续访问即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="https://farm8.staticflickr.com/7596/16737206479_96b9f7dfdb_c.jpg"&gt;&lt;/p&gt;
&lt;p&gt;你完成登录后，就会看到这个页面。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="https://farm8.staticflickr.com/7594/16303369973_6019482dea_c.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在这个教程的其余部分，我们演示监控一个本地服务器和常见服务的方法。你会在&lt;a href="http://mmonit.com/wiki/Monit/ConfigurationExamples"&gt;官方wiki页面&lt;/a&gt;看到很多有用的例子。其中的多数是可以直接复制粘贴的！&lt;/p&gt;
&lt;h3&gt;Service Configuration: CPU/Memory Monitoring （服务配置：CPU、内存监控）&lt;/h3&gt;
&lt;p&gt;我们先来监控本地服务器的CPU、内存占用。复制如下代码段到配置文件中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;check system localhost
    if loadavg (1min) &amp;gt; 10 then alert
    if loadavg (5min) &amp;gt; 6 then alert
    if memory usage &amp;gt; 75% then alert
    if cpu usage (user) &amp;gt; 70% then alert
    if cpu usage (system) &amp;gt; 60% then alert
    if cpu usage (wait) &amp;gt; 75% then alert
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你可以很容易理解上边的配置。最上边的check是指每个监控周期（全局配置里设置的120秒）都对本机进行下面的操作。如果满足了任何条件，monit守护进程就会使用邮件发送一条报警。&lt;/p&gt;
&lt;p&gt;如果某个监控项不需要每个周期都检查，可以使用如下格式，它会每240秒检查一次平均负载。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if loadavg (1min) &amp;gt; 10 for 2 cycles then alert
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Service Configuration: SSH Service Monitoring （服务配置：SSH服务监控）&lt;/h3&gt;
&lt;p&gt;先检查我们的sshd是否安装在/usr/sbin/sshd：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;check file sshd_bin with path /usr/sbin/sshd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们还想检查sshd的启动脚本是否存在：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;check file sshd_init with path /etc/init.d/sshd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后，我们还想检查sshd守护进程是否存活，并且在监听22端口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;check process sshd with pidfile /var/run/sshd.pid
   start program  &amp;quot;/etc/init.d/sshd start&amp;quot;
   stop program  &amp;quot;/etc/init.d/sshd stop&amp;quot;
   if failed port 22 protocol ssh then restart
   if 5 restarts within 5 cycles then timeout
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以这样解释上述配置：我们检查是否存在名为sshd的进程，并且有一个保存其pid的文件存在（/var/run/sshd.pid）。如果任何一个不存在，我们就使用启动脚本重启sshd。我们检查是否有进程在监听22端口，并且使用的是SSH协议。如果没有，我们还是重启sshd。如果在最近的5个监控周期（5x120秒）至少重启5次了，sshd就被认为是不能用的，我们就不再检查了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="https://farm9.staticflickr.com/8685/16735725998_62c26a24bc_c.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;Service Configuration: SMTP Service Monitoring （服务配置：SMTP服务监控）&lt;/h3&gt;
&lt;p&gt;现在我们来设置一个检查远程SMTP服务器（如192.168.111.102）的监控。假定SMTP服务器运行着SMTP、IMAP、SSH服务。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;check host MAIL with address 192.168.111.102
   if failed icmp type echo within 10 cycles then alert
   if failed port 25  protocol smtp then alert
             else if recovered then exec &amp;quot;/scripts/mail-script&amp;quot;
   if failed port 22  protocol ssh  then alert
   if failed port 143 protocol imap then alert
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们检查远程主机是否响应ICMP协议。如果我们在10个周期内没有收到ICMP回应，就发送一条报警。如果监测到25端口上的SMTP协议是异常的，就发送一条报警。如果在一次监测失败后又监测成功了，就运行一个脚本（/scripts/mail-script）。如果检查22端口上的SSH或者143端口上的IMAP协议不正常，同样发送报警。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;在这个教程，我演示了如何在本地服务器设置Monit，当然这只是Monit功能的冰山一角。你可以花些时间阅读Monit的man手册（写得很好）。Monit可以为任何Linux系统管理员做很多事情，并且具有非常优美和易于理解的语法。如果你将一个集中式的远程监控系统和Monit一同使用，你会得到一个更可靠的监控系统。你感觉Monit怎么样？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://xmodulo.com/server-monitoring-system-monit.html&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://xmodulo.com/author/iulian"&gt;Iulian Murgulet&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 如何在 Linux 下创建一个不可变更的文件</title><link href="/yi-ru-he-zai-linux-xia-chuang-jian-yi-ge-bu-ke-bian-geng-de-wen-jian.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-ru-he-zai-linux-xia-chuang-jian-yi-ge-bu-ke-bian-geng-de-wen-jian.html</id><summary type="html">&lt;p&gt;假如你想对Linux中的一些重要文件做写保护，这样它们就不能被删除或者被篡改成之前的版本或者其他东西，或者在其他情况下，你可能想避免某些配置文件被软件自动修改。使用&lt;code&gt;chown&lt;/code&gt;和&lt;code&gt;chmod&lt;/code&gt;命令修改文件的归属关系或者权限位是处理这种情况的一个解决方法，但这并不完美，因为这样无法避免有root权限的操作。这时&lt;code&gt;chattr&lt;/code&gt;就派上用场了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chattr&lt;/code&gt;是一个可以设置或取消文件的标志位的Linux命令，它和标准的文件权限（读、写、执行）是分离的。与此相关的另一个命令是&lt;code&gt;lsattr&lt;/code&gt;，它可以显示文件的哪些标志位被设置上了。最初只有EXT文件系统（EXT2/3/4）支持&lt;code&gt;chattr&lt;/code&gt;和&lt;code&gt;lsattr&lt;/code&gt;所管理的标志位，但现在很多其他的原生的Linux文件系统都支持了，比如XFS、Btrfs、ReiserFS等等。&lt;/p&gt;
&lt;p&gt;在这个教程中，我会示范如果使用&lt;code&gt;chattr&lt;/code&gt;来让Linux中的文件不可变更。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chattr&lt;/code&gt;和&lt;code&gt;lsattr&lt;/code&gt;命令是e2fsprogs包的一部分，它在所有现代Linux发行版都预装了。&lt;/p&gt;
&lt;p&gt;下面是&lt;code&gt;chattr&lt;/code&gt;的基本语法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ chattr …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;假如你想对Linux中的一些重要文件做写保护，这样它们就不能被删除或者被篡改成之前的版本或者其他东西，或者在其他情况下，你可能想避免某些配置文件被软件自动修改。使用&lt;code&gt;chown&lt;/code&gt;和&lt;code&gt;chmod&lt;/code&gt;命令修改文件的归属关系或者权限位是处理这种情况的一个解决方法，但这并不完美，因为这样无法避免有root权限的操作。这时&lt;code&gt;chattr&lt;/code&gt;就派上用场了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chattr&lt;/code&gt;是一个可以设置或取消文件的标志位的Linux命令，它和标准的文件权限（读、写、执行）是分离的。与此相关的另一个命令是&lt;code&gt;lsattr&lt;/code&gt;，它可以显示文件的哪些标志位被设置上了。最初只有EXT文件系统（EXT2/3/4）支持&lt;code&gt;chattr&lt;/code&gt;和&lt;code&gt;lsattr&lt;/code&gt;所管理的标志位，但现在很多其他的原生的Linux文件系统都支持了，比如XFS、Btrfs、ReiserFS等等。&lt;/p&gt;
&lt;p&gt;在这个教程中，我会示范如果使用&lt;code&gt;chattr&lt;/code&gt;来让Linux中的文件不可变更。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chattr&lt;/code&gt;和&lt;code&gt;lsattr&lt;/code&gt;命令是e2fsprogs包的一部分，它在所有现代Linux发行版都预装了。&lt;/p&gt;
&lt;p&gt;下面是&lt;code&gt;chattr&lt;/code&gt;的基本语法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ chattr &lt;span class="o"&gt;[&lt;/span&gt;-RVf&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;操作符&lt;span class="o"&gt;][&lt;/span&gt;标志位&lt;span class="o"&gt;]&lt;/span&gt; 文件...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中操作符可以是“+”（把选定的标志位添加到标志位列表）、“-”（从标志位列表中移除选定的标志位）、或者“=”（强制使用选定的标志位）。&lt;/p&gt;
&lt;p&gt;下面是一些可用的标志位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;a&lt;/strong&gt;: 只能以追加模式打开。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A&lt;/strong&gt;: 不能更新atime（文件访问时间）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;c&lt;/strong&gt;: 当被写入磁盘时被自动压缩。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;: 关掉“写时复制”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;i&lt;/strong&gt;: 不可变更。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s&lt;/strong&gt;: 通过自动归零来安全删除。（LCTT 译注：一般情况文件被删后内容不会被修改，改标志位会使得文件被删后原有内容被“0”取代）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;“不可变更”标志位&lt;/h3&gt;
&lt;p&gt;为了让一个文件不可变更，你需要按照如下方法为这个文件添加“不可变更”标志位。例如，对/etc/passwd文件做写保护：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo chattr +i /etc/passwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意设置或取消一个文件的“不可变更”标志位是需要root用户权限的。现在检查该文件“不可变更”标志位是否被添加上了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsattr /etc/passwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一旦文件被设置为不可变更，任何用户都将无法修改该文件。即使是root用户也不可以修改、删除、覆盖、移动或者重命名这个文件。如果你想再次修改这个文件，需要先把“不可变更”标志位取消了。&lt;/p&gt;
&lt;p&gt;用如下命令取消“不可变更”标志位：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo chattr -i /etc/passwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="image" src="https://farm9.staticflickr.com/8613/16152651317_076a65cf50_b.jpg"&gt;&lt;/p&gt;
&lt;p&gt;如果你想让一个目录（比如/etc）连同它下边的所有内容不可变更，使用“-R”选项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo chattr -R +i /etc
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;“只可追加”标志位&lt;/h3&gt;
&lt;p&gt;另一个有用的的标志位是“只可追加”，它只允许文件内容被追加的方式修改。你不能覆盖或者删除一个设置了“只可追加”标志位的文件。这个标志位在你想避免日志文件被意外清理掉的情况很有用。&lt;/p&gt;
&lt;p&gt;和“不可变更”标志位类似，你可以使用如下命令让文件变成“只可追加”模式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo chattr +a /var/log/syslog
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意当你复制一个“不可变更”或者“只可追加”的文件到其他地方后，新文件不会保留这些标志位！&lt;/p&gt;
&lt;h3&gt;结论&lt;/h3&gt;
&lt;p&gt;在这个教程中，我展示了如何使用&lt;code&gt;chattr&lt;/code&gt;和&lt;code&gt;lsattr&lt;/code&gt;命令来管理额外的文件标志位，来避免文件被篡改（意外或者其他情况）的方法。注意你不能将&lt;code&gt;chattr&lt;/code&gt;作为一个安全措施，因为“不可变更”标志位可以很容易被取消掉。解决这个问题的一个可能的方式是限制&lt;code&gt;chattr&lt;/code&gt;命令自身的可用性，或者去掉CAP_LINUX_IMMUTABLE内核权能标志。关于&lt;code&gt;chattr&lt;/code&gt;以及可用的标志位的更多细节，请参考它的man手册。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://xmodulo.com/make-file-immutable-linux.html&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://xmodulo.com/author/nanni"&gt;Dan Nanni&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 如何在云服务提供商的平台上使用 Docker Machine</title><link href="/yi-ru-he-zai-yun-fu-wu-ti-gong-shang-de-ping-tai-shang-shi-yong-docker-machine.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-ru-he-zai-yun-fu-wu-ti-gong-shang-de-ping-tai-shang-shi-yong-docker-machine.html</id><summary type="html">&lt;p&gt;大家好，今天我们来了解如何使用Docker Machine在各种云服务提供商的平台上部署Docker。Docker Machine是一个可以帮助我们在自己的电脑、云服务提供商的平台以及我们数据中心的机器上创建Docker机器的应用程序。它为创建服务器、在服务器中安装Docker、根据用户需求配置Docker客户端提供了简单的解决方案。驱动API对本地机器、数据中心的虚拟机或者公用云机器都适用。Docker Machine支持Windows、OSX和Linux，并且提供一个独立的二进制文件，可以直接使用。它让我们可以充分利用支持Docker的基础设施的生态环境合作伙伴，并且使用相同的接口进行访问。它让人们可以使用一个命令来简单而迅速地在不同的云平台部署Docker容器。&lt;/p&gt;
&lt;h3&gt;1. 安装Docker Machine&lt;/h3&gt;
&lt;p&gt;Docker Machine可以很好地支持每一种Linux发行版。首先，我们需要从Github网站下载最新版本的。这里我们使用curl来下载目前最新0.2.0版本的Docker Machine。&lt;/p&gt;
&lt;p&gt;在64位操作系统运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# curl -L https://github.com/docker/machine/releases/download/v0.2.0/docker-machine_linux-amd64 &amp;gt; /usr/local/bin/docker-machine
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在32位操作系统运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# curl …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;大家好，今天我们来了解如何使用Docker Machine在各种云服务提供商的平台上部署Docker。Docker Machine是一个可以帮助我们在自己的电脑、云服务提供商的平台以及我们数据中心的机器上创建Docker机器的应用程序。它为创建服务器、在服务器中安装Docker、根据用户需求配置Docker客户端提供了简单的解决方案。驱动API对本地机器、数据中心的虚拟机或者公用云机器都适用。Docker Machine支持Windows、OSX和Linux，并且提供一个独立的二进制文件，可以直接使用。它让我们可以充分利用支持Docker的基础设施的生态环境合作伙伴，并且使用相同的接口进行访问。它让人们可以使用一个命令来简单而迅速地在不同的云平台部署Docker容器。&lt;/p&gt;
&lt;h3&gt;1. 安装Docker Machine&lt;/h3&gt;
&lt;p&gt;Docker Machine可以很好地支持每一种Linux发行版。首先，我们需要从Github网站下载最新版本的。这里我们使用curl来下载目前最新0.2.0版本的Docker Machine。&lt;/p&gt;
&lt;p&gt;在64位操作系统运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# curl -L https://github.com/docker/machine/releases/download/v0.2.0/docker-machine_linux-amd64 &amp;gt; /usr/local/bin/docker-machine
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在32位操作系统运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# curl -L https://github.com/docker/machine/releases/download/v0.2.0/docker-machine_linux-i386 &amp;gt; /usr/local/bin/docker-machine
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下载最新版本的Docker Machine并将docker-machine文件放到了/usr/local/bin/后，添加执行权限：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# chmod +x /usr/local/bin/docker-machine
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;完成如上操作后，我们需要确认已经成功安装docker-machine了。可以运行如下命令检查，它会输出系统中docker-machine的版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine -v
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Installing Docker Machine" src="http://blog.linoxide.com/wp-content/uploads/2015/05/installing-docker-machine.png"&gt;&lt;/p&gt;
&lt;p&gt;要在我们的机器上启用docker命令，需要使用如下命令安装Docker客户端：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    # curl -L https://get.docker.com/builds/linux/x86_64/docker-latest &amp;gt; /usr/local/bin/docker
    # chmod +x /usr/local/bin/docker
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. 创建机器&lt;/h3&gt;
&lt;p&gt;在自己的Linux机器上安装好了Docker Machine之后，我们想要将一个docker虚拟机部署到云服务器上。Docker Machine支持几个流行的云平台，如igital Ocean、Amazon Web Services（AWS）、Microsoft Azure、Google Cloud Computing及其它等等，所以我们可以在不同的平台使用相同的接口来部署Docker。本文中我们会使用digitalocean驱动在Digital Ocean的服务器上部署Docker，--driver选项指定digitalocean驱动，--digitalocean-access-token选项指定&lt;a href="https://cloud.digitalocean.com/settings/applications"&gt;Digital Ocean Control Panel&lt;/a&gt;提供的API Token，命令最后的是我们创建的Docker虚拟机的机器名。运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine create --driver digitalocean --digitalocean-access-token &amp;lt;API-Token&amp;gt; linux-dev

# eval &amp;quot;$(docker-machine env linux-dev)&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Docker Machine Digitalocean Cloud" src="http://blog.linoxide.com/wp-content/uploads/2015/05/docker-machine-digitalocean-cloud.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;： 这里linux-dev是我们将要创建的机器的名称。&lt;code&gt;&amp;lt;API-Token&amp;gt;&lt;/code&gt;是一个安全key，可以在Digtal Ocean Control Panel生成。要找到这个key，我们只需要登录到我们的Digital Ocean Control Panel，然后点击API，再点击 Generate New Token，填写一个名称，选上Read和Write。然后我们就会得到一串十六进制的key，那就是&lt;code&gt;&amp;lt;API-Token&amp;gt;&lt;/code&gt;，简单地替换到上边的命令中即可。&lt;/p&gt;
&lt;p&gt;运行如上命令后，我们可以在Digital Ocean Droplet Panel中看到一个具有默认配置的droplet已经被创建出来了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="DigitalOcean Droplet Panel" src="http://blog.linoxide.com/wp-content/uploads/2015/05/digitalocean-droplet-panel.png"&gt;&lt;/p&gt;
&lt;p&gt;简便起见，docker-machine会使用默认配置来部署Droplet。我们可以通过增加选项来定制我们的Droplet。这里是一些digitalocean相关的选项，我们可以使用它们来覆盖Docker Machine所使用的默认配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;--digitalocean-image "ubuntu-14-04-x64" 用于选择Droplet的镜像&lt;/li&gt;
&lt;li&gt;--digitalocean-ipv6 enable 启用IPv6网络支持&lt;/li&gt;
&lt;li&gt;--digitalocean-private-networking enable 启用专用网络&lt;/li&gt;
&lt;li&gt;--digitalocean-region "nyc3" 选择部署Droplet的区域&lt;/li&gt;
&lt;li&gt;--digitalocean-size "512mb" 选择内存大小和部署的类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你想在其他云服务使用docker-machine，并且想覆盖默认的配置，可以运行如下命令来获取Docker Mackine默认支持的对每种平台适用的参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine create -h
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3. 选择活跃主机&lt;/h3&gt;
&lt;p&gt;部署Droplet后，我们想马上运行一个Docker容器，但在那之前，我们需要检查下活跃主机是否是我们需要的机器。可以运行如下命令查看。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine ls
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Docker Machine List" src="http://blog.linoxide.com/wp-content/uploads/2015/05/docker-machine-ls.png"&gt;&lt;/p&gt;
&lt;p&gt;ACTIVE一列有“*”标记的是活跃主机。&lt;/p&gt;
&lt;p&gt;现在，如果我们想将活跃主机切换到需要的主机，运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine active linux-dev
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里，linux-dev是机器名，我们打算激活这个机器，并且在其上运行Docker容器。&lt;/p&gt;
&lt;h3&gt;4. 运行一个Docker容器&lt;/h3&gt;
&lt;p&gt;现在，我们已经选择了活跃主机，就可以运行Docker容器了。可以测试一下，运行一个busybox容器来执行&lt;code&gt;echo hello word&lt;/code&gt;命令，这样就可以得到输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker run busybox echo hello world
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：如果你试图在一个装有32位操作系统的宿主机部署Docker容器，使用SSH来运行docker是个好办法。这样你就可以简单跳过这一步，直接进入下一步。&lt;/p&gt;
&lt;h3&gt;5. SSH到Docker机器中&lt;/h3&gt;
&lt;p&gt;如果我们想在机器或者Droplet上控制之前部署的Docker机器，可以使用docker-machine ssh命令来SSH到机器上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine ssh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Docker Machine SSH" src="http://blog.linoxide.com/wp-content/uploads/2015/05/docker-machine-ssh.png"&gt;&lt;/p&gt;
&lt;p&gt;SSH到机器上之后，我们可以在上边运行任何Docker容器。这里我们运行一个nginx：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker run -itd -p 80:80 nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;操作完毕后，我们需要运行exit命令来退出Droplet或者服务器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# exit
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;5. 删除主机&lt;/h3&gt;
&lt;p&gt;删除在运行的主机以及它的所有镜像和容器，我们可以使用docker-machine rm命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine rm linux-dev
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Docker Machine Remove All" src="http://blog.linoxide.com/wp-content/uploads/2015/05/docker-machine-remove-machine.png"&gt;&lt;/p&gt;
&lt;p&gt;使用docker-machine ls命令检查是否成功删除了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine ls
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Docker Machine Remove Check" src="http://blog.linoxide.com/wp-content/uploads/2015/05/docker-machine-remove-check.png"&gt;&lt;/p&gt;
&lt;h3&gt;6. 在不使用驱动的情况新增一个主机&lt;/h3&gt;
&lt;p&gt;我们可以在不使用驱动的情况往Docker增加一台主机，只需要一个URL。它可以使用一个已有机器的别名，所以我们就不需要每次在运行docker命令时输入完整的URL了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker-machine create --url&lt;span class="o"&gt;=&lt;/span&gt;tcp://104.131.50.36:2376 custombox
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;7. 管理主机&lt;/h3&gt;
&lt;p&gt;如果你已经让Docker运行起来了，可以使用简单的&lt;strong&gt;docker-machine stop&lt;/strong&gt;命令来停止所有正在运行的主机，如果需要再启动的话可以运行&lt;strong&gt;docker-machine start&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine stop
# docker-machine start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你也可以使用如下命令来使用机器名作为参数来将其停止或启动：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker-machine stop linux-dev
$ docker-machine start linux-dev
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;Docker Machine是一个非常棒的工具，可以使用Docker容器快速地部署服务。文中我们使用Digital Ocean Platform作演示，但Docker Machine还支持其他平台，如Amazon Web Service、Google Cloud Computing。使用Docker Machine，快速、安全地在几种不同平台部署Docker容器变得很简单了。因为Docker Machine还是Beta版本，不建议在生产环境使用。如果你有任何问题、建议、反馈，请在下方的评论框中写下来，我们会改进或者更新我们的内容。谢谢！享受吧 :-)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://linoxide.com/linux-how-to/use-docker-machine-cloud-provider/&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://linoxide.com/author/arunp/"&gt;Arun Pyasi&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="https://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>《意识宇宙：心灵现象的科学解释》读书笔记</title><link href="/yi-shi-yu-zhou-xin-ling-xian-xiang-de-ke-xue-jie-shi-du-shu-bi-ji.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-shi-yu-zhou-xin-ling-xian-xiang-de-ke-xue-jie-shi-du-shu-bi-ji.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这是一本讲心灵相关特异功能的科普书籍。强调科普是因为和心灵或者特异功能相关的书籍非常多，但多数都是罗列很多有趣或者震撼却无法证实的事情，或者谈论似是而非的自创理论，实事求是地谈论这个主题的书籍并不多，显然这是很有代表性的一本。这本书大量使用统计学的方法分析可重复性的实验，得到了许多特异功能存在的证据，同时阐述了一些在科学以及哲学层面的理解，以及更加深入的思考。&lt;/p&gt;
&lt;p&gt;读了这本书，至少有这样几个观点是可以明确的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;心灵相关的特异功能现象是确实存在的，有充足的实验证据，无可辩驳&lt;/li&gt;
&lt;li&gt;这些特异功能和现有的科学理论存在矛盾，并且没有成熟的科学假说可以完美地解释&lt;/li&gt;
&lt;li&gt;因为种种原因，投入到这个领域的科学家并不多，相关的科学研究也进展缓慢&lt;/li&gt;
&lt;li&gt;我们对于自己所处的世界有太多误解&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;序言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在科学上接收一个新观点的过程可以分为四个阶段：
1. 怀疑者们很坚定地声称该观点违背现有理论，根本就不可能。这个阶段可能持续数年乃至数百年，注意看该观点和常识存在多大的对立。
2. 怀疑者们开始迟疑地承认存在可能性，但意义不大，而且效应也不明显。
3. 社会的主流开始认识到这种观点不仅为真，而且其效应也远远超出了当初的预想。
4. 那些之前一直否定对此观点有兴趣的人居然跳出来宣称当初是他们率先提出来的。再后来慢慢不再有人记得该观点曾一度被视为异端邪说。&lt;/p&gt;
&lt;p&gt;本书所讨论的观点目前还正处在最重要但最困难的阶段——正从第一阶段迈入第二阶段。这些观点本身其实非常古老，但花了100多年的时间，才通过符合严格的科学标准的检验得到有说服力的结果。这些验证工作加速了第二阶段的接受过程，甚至已经可以瞄到第三阶段降临的曙光。&lt;/p&gt;
&lt;p&gt;心灵现象，更通俗地说是“特异功能”（psi …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;这是一本讲心灵相关特异功能的科普书籍。强调科普是因为和心灵或者特异功能相关的书籍非常多，但多数都是罗列很多有趣或者震撼却无法证实的事情，或者谈论似是而非的自创理论，实事求是地谈论这个主题的书籍并不多，显然这是很有代表性的一本。这本书大量使用统计学的方法分析可重复性的实验，得到了许多特异功能存在的证据，同时阐述了一些在科学以及哲学层面的理解，以及更加深入的思考。&lt;/p&gt;
&lt;p&gt;读了这本书，至少有这样几个观点是可以明确的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;心灵相关的特异功能现象是确实存在的，有充足的实验证据，无可辩驳&lt;/li&gt;
&lt;li&gt;这些特异功能和现有的科学理论存在矛盾，并且没有成熟的科学假说可以完美地解释&lt;/li&gt;
&lt;li&gt;因为种种原因，投入到这个领域的科学家并不多，相关的科学研究也进展缓慢&lt;/li&gt;
&lt;li&gt;我们对于自己所处的世界有太多误解&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;序言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在科学上接收一个新观点的过程可以分为四个阶段：
1. 怀疑者们很坚定地声称该观点违背现有理论，根本就不可能。这个阶段可能持续数年乃至数百年，注意看该观点和常识存在多大的对立。
2. 怀疑者们开始迟疑地承认存在可能性，但意义不大，而且效应也不明显。
3. 社会的主流开始认识到这种观点不仅为真，而且其效应也远远超出了当初的预想。
4. 那些之前一直否定对此观点有兴趣的人居然跳出来宣称当初是他们率先提出来的。再后来慢慢不再有人记得该观点曾一度被视为异端邪说。&lt;/p&gt;
&lt;p&gt;本书所讨论的观点目前还正处在最重要但最困难的阶段——正从第一阶段迈入第二阶段。这些观点本身其实非常古老，但花了100多年的时间，才通过符合严格的科学标准的检验得到有说服力的结果。这些验证工作加速了第二阶段的接受过程，甚至已经可以瞄到第三阶段降临的曙光。&lt;/p&gt;
&lt;p&gt;心灵现象，更通俗地说是“特异功能”（psi）或“超常现象”（paranormal），共分为两大类：
1. 不用常规感官能力获得外在物体以及事件的信息的能力。
2. 意念活动对外部环境施加影响。
在这两类现象中，意念能起到当代科学认为不可能的作用。&lt;/p&gt;
&lt;p&gt;头脑只是机械地处理信息的一组神经束吗？或者像有些认识科学家和神经科学家所认定的是“肉做的计算机”？还有什么别的？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;专题一：动机&lt;/h2&gt;
&lt;p&gt;这一专题中主要讲了何为特异功能，简单介绍了一些奇异体验，以及如何科学地分析。&lt;/p&gt;
&lt;p&gt;对于科学实验，可重复性是非常重要的。如果在某些实验中，不能保证在前提相同的情况下得到相同的结果，或者根本无法构造相同的前提，进而结果相同无从谈起，那显然从这些实验中很难得到任何有说服力的东西。&lt;/p&gt;
&lt;p&gt;然而特异功能相关的实验就面临着这样的问题，那些最吸引人的现象极难重复，原因多种多样。但这样就真的没有办法进行科学的实验吗？作者提到一个棒球手的事情，对比起来就会发现有参考价值。我们知道即使是最优秀的棒球手也不可能每个球都击中，但击中率一定是比常人高的。如果拿这个棒球手做实验，让他击打不同来源的棒球，那他显然不能保证每个球都可以击中。如果有人说可以控制每次击球的前提条件一致，那就比较困难了，即使用机器控制棒球的速度和方向，人的身体还是在不停变动的，而且人的精神也不会处于一直固定的状态。但这样我们就没有办法区分一个优秀的棒球手和从未碰过棒球的人吗？显然不是，我们可以统计击中率。&lt;/p&gt;
&lt;p&gt;对于特异功能也是如此，而且前提条件比击打棒球要复杂很多，无法进行精确的控制，以在每次实验中得到预期的结果。但统计学方法在这里还是适用的。比如正常情况投骰子，每个面朝上的概率都是1/6。在实验中某人试图用自己的意识对骰子施加作用，经过大量的实验后，统计结果显示该人希望朝上的那一面的概率为1/5。这样的概率差距在单次实验显然是得不到任何东西的，但经过大量实验结果统计后，我们却必须接受这样的影响。作者正是使用这样的方法，通过大量的实验抹掉每次前提不一致造成的不可控影响，仍然能得出科学的结果。作者称这样的方法为“元分析”。&lt;/p&gt;
&lt;h2&gt;专题二：证据&lt;/h2&gt;
&lt;p&gt;这个专题主要讲各种特异功能存在的证据，详细描述了各种实验的步骤，以及“元分析”的统计结果。其中包括了思维传感、超越空间的感知、超越时间的感知、心——物作用、意念对生命体的影响等方面，以及意念场、赌场中的特异功能、开发应用等场景，内容不好概括，便不展开了，结论是很多实验证明了相应的特异功能是存在的，无可辩驳。&lt;/p&gt;
&lt;h2&gt;专题三：理解&lt;/h2&gt;
&lt;p&gt;这一个专题讲的是作者在科学、哲学等层面对那些确凿存在的特异功能的理解。我认为这也是最值得看的一部分。&lt;/p&gt;
&lt;p&gt;面对如此多的实验证据，怀疑论者的使用无视、扭曲事实等方式拒绝承认特异功能的存在，这是在逃避问题，而不是解决问题。然而这也是有原因的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;既有信念效应&lt;/strong&gt;
心理学家布鲁勒和列斯特曼所做的一系列经典实验证明，有时我们见到或以为见到的东西，其实并不存在。比如做这样一副扑克牌，只是反转了某些牌的颜色，比如把方块Q从红色改成黑色。然后给人们一张张展示这些牌，并让其说出每张牌是什么。开始每张牌的展示时间很短，短到看不太清楚，然后逐渐延长时间。令人惊奇的是虽然很肯定地认出了牌，可谁也没有看出牌友什么不对之处。
人们要么把印成黑色红心4看成黑桃4，要么就把它看成正常的红心4。或者说人们期望什么决定了认为看到的是什么。随着时间的延长，人们变得更加疑惑和犹豫。看到的东西和预期的不一致，会造成精神上的不安。
改变自己的观点以接受他人的思想，对持不同观点的人施压，把那些持不同观点的人打扮得和自己截然不同（异端分子、伪科学家等）是减轻认知失措的常见的三个策略。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;期望效应&lt;/strong&gt;
简而言之，支持者和批评者得出的实验结果完全取决于他们各自认为将看到什么期望。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;判断错误&lt;/strong&gt;
简而言之，人们往往根据过去的经验或者自己的直觉对事物做出判断，然而那些经验或者直觉并不总是准确的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;只留意自己所关注的方面&lt;/strong&gt;
比如挑选证据时只挑选能吸引我们的证据，在某种思想已经被广泛接受后说“我早知如此”的马后炮效应，已经轻信媒体等来源的加工过的证据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;超越直觉过滤&lt;/strong&gt;
头脑会通过其他的一些渠道有意无意地拒绝所不愿看到的东西，如压抑、反抗、投射、抑制、分裂、升华和否定等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;认知与信仰&lt;/strong&gt;
人们已有的认知和信仰会直接阻碍他们接受与这些相矛盾的东西。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;专题四：蕴意&lt;/h2&gt;</content></entry><entry><title>[译] 为什么 AHK 没有得到应有的尊重</title><link href="/yi-wei-shi-yao-ahk-mei-you-de-dao-ying-you-de-zun-zhong.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-wei-shi-yao-ahk-mei-you-de-dao-ying-you-de-zun-zhong.html</id><summary type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;注：并非严谨的翻译，部分内容有删改。另外该帖子是三年前的，有关 AHK 的内容可能有些部分已经过时。所有内容都和我的个人观点无关。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;源地址：&lt;a href="https://autohotkey.com/board/topic/90892-why-doesnt-ahk-get-the-respect-it-deserves/"&gt;Why doesn't AHK get the respect it deserves? &lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Cruncher1，2013 年 3 月 2 日&lt;/h2&gt;
&lt;p&gt;在 Google 搜“简单易学的编程语言”或者“创建图形界面的编程语言”之类的时候，你永远不会在结果中看到 AHK。然后，它是创建一个简洁的图形界面来完成日常工作的最容易的方法。它很有趣也易于学习，我想对于每个人而言，它都是一门令人惊叹的编程语言。甚至我 6 岁大的孩子都可以学会足够的代码用来娱乐。我并不是一个“真正”的程序员，所以我请教下。什么事情上 Java、Python 或者 C …&lt;/p&gt;</summary><content type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;注：并非严谨的翻译，部分内容有删改。另外该帖子是三年前的，有关 AHK 的内容可能有些部分已经过时。所有内容都和我的个人观点无关。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;源地址：&lt;a href="https://autohotkey.com/board/topic/90892-why-doesnt-ahk-get-the-respect-it-deserves/"&gt;Why doesn't AHK get the respect it deserves? &lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Cruncher1，2013 年 3 月 2 日&lt;/h2&gt;
&lt;p&gt;在 Google 搜“简单易学的编程语言”或者“创建图形界面的编程语言”之类的时候，你永远不会在结果中看到 AHK。然后，它是创建一个简洁的图形界面来完成日常工作的最容易的方法。它很有趣也易于学习，我想对于每个人而言，它都是一门令人惊叹的编程语言。甚至我 6 岁大的孩子都可以学会足够的代码用来娱乐。我并不是一个“真正”的程序员，所以我请教下。什么事情上 Java、Python 或者 C++ 可以做，而 AHK 做不到的呢？&lt;/p&gt;
&lt;h2&gt;IsNull，2013 年 3 月 2 日&lt;/h2&gt;
&lt;p&gt;脚本语言和更专业的编程语言开始合为一体了，性能不再是关键问题。&lt;/p&gt;
&lt;p&gt;现在一门编程语言的功能特性更重要。开发效率和代码的可维护性是最重要的方面。&lt;/p&gt;
&lt;p&gt;然而，AHK 缺失管理大型项目所需的一些概念。比如类型定义、类型安全（这些特性通常被 IDE 很好地支持，以便提高生产力）。&lt;/p&gt;
&lt;p&gt;缺失对多线程的支持是另一个问题，可能是和其他语言相比 AHK 最大的一个局限。&lt;/p&gt;
&lt;p&gt;更专业的编程语言的严谨让它们对新手不那么友好。有人可能会说，脚本语言通常遵循着“直接使用，无需事先定义”的原则，而专业的编程语言则是“使用前必须先定义”。这真是个悲伤的事情。
 
编程语言只是工具而已，我们应该根据具体事情的特点来选择合适的工具。也许某些人会发现，在某些领域，我们还是需要一些新的定制化工具。&lt;/p&gt;
&lt;h2&gt;Cruncher1，2013 年 3 月 2 日&lt;/h2&gt;
&lt;p&gt;我明白你的意思。对于我做的事情，（不支持）多线程不是问题。并且我只有一个我可以称之为“大代码项目”的东西，也就大概 2000 多行代码的样子。有时我努力纠正一个错误或者修改一些东西时，感受到管理 AHK 代码是一种煎熬。我会去查找那些观念（类型定义，类型安全，……），尽管我对它们还不熟悉。我已经确定学习 Python 了。它看起来是一门适合 AHK 用户接下来使用的编程语言。它相当简单，但很强大，并且比 AHK 更有名气。&lt;/p&gt;
&lt;h2&gt;WhyTYSir，2013 年 3 月 2 日&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;脚本语言和更专业的编程语言开始合为一体了，性能不再是关键问题。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你不是用 C# 写出 Truecrypt 工具的作者吗？它的速度怎么样呢？所以你在之后将它修改成多线程的并且相信结果总是好的。好吧。
Aren't you the one who made a C# Truecrypt brute-force tool? How did the speed turn out on that? So then you multi-threaded it and hoped for the best? Ok [图片上传中。。。（1）]
 &lt;/p&gt;
&lt;p&gt;That whole 'performance is no longer a key point' has been making its rounds since people found out that a game called Doom (that was created way back when) used hardly any ASM and relied heavily on a then-modern compiler for optimization. Could it have benefited from some hand-sewn ASM? It didn't matter, since computers were so much more powerful back then their predecessors!
 
The facade continues because 90% of the apps written today are heavily UI-based and do nothing more than utter BS. Even heavily resource intensive games that could use tweaking don't get it because of this fallacy. Laziness and costs are the driving factors anymore. It's not that computers are now ALL-POWERFUL, it's that people want to save a dollar and are lazy. So, if they can convince some idiots that C# or VB or AHK is as fast as ASM, C or C++, it's a benefit to them. Where the Sheppard goes, the sheep will follow.
 
Please don't take this as an affront. I just see this lie perpetuated with a lot of programs I use and it irks me. Waiting for programs to open, waiting on pages to load, waiting on games to load the next part and FR in general, waiting on hash programs to finish... it drives me crazy when I know they were written with the writer's convenience in mind and not the user's.&lt;/p&gt;</content></entry><entry><title>[译] zBackup：一个多功能的去重备份工具</title><link href="/yi-zbackupyi-ge-duo-gong-neng-de-qu-zhong-bei-fen-gong-ju.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-zbackupyi-ge-duo-gong-neng-de-qu-zhong-bei-fen-gong-ju.html</id><summary type="html">&lt;p&gt;zbackup是一个基于rsync思想的全局去重数据备份工具。给它传入一个大的tar文件后，它会仅存储一次该文件的重复部分，然后对结果进行压缩，并根据参数确定是否对其加密。传入另一个tar文件后，它会从之前的已备份文件中复用重复数据。只有新的改动会被保存，并且只要文件差异不是很大，需要的存储空间非常少。无论何时，之前的已备份文件都可以被完整地读出来。&lt;/p&gt;
&lt;h3&gt;zBackup特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用并行的LZMA或者LZO压缩算法压缩已备份数据&lt;/li&gt;
&lt;li&gt;使用内置的AES加密算法加密已备份数据&lt;/li&gt;
&lt;li&gt;可以删除旧的已备份数据&lt;/li&gt;
&lt;li&gt;使用一个64位滚动哈希，保持软碰撞数量为0&lt;/li&gt;
&lt;li&gt;备份库由不可更改的文件组成，只有库中不存在的文件才能修改&lt;/li&gt;
&lt;li&gt;使用C++语言编写，并且只有适量的依赖库&lt;/li&gt;
&lt;li&gt;可以在生产环境安全使用&lt;/li&gt;
&lt;li&gt;可以在不同备份库中交换数据而无需重新压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;在ubuntu中安装zBackup&lt;/h3&gt;
&lt;p&gt;打开终端并运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install zbackup
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;使用zBackup&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;zbackup init&lt;/code&gt;命令会初始化一个备份库，用来存放待备份的数据。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;zbackup init [--non-encrypted] [--password-file ~/.my_backup_password ] /my/backup/repo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;zbackup backup&lt;/code&gt;命令备份一个由&lt;code&gt;tar c&lt;/code&gt;命令创建的tar文件到刚才使用 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;zbackup是一个基于rsync思想的全局去重数据备份工具。给它传入一个大的tar文件后，它会仅存储一次该文件的重复部分，然后对结果进行压缩，并根据参数确定是否对其加密。传入另一个tar文件后，它会从之前的已备份文件中复用重复数据。只有新的改动会被保存，并且只要文件差异不是很大，需要的存储空间非常少。无论何时，之前的已备份文件都可以被完整地读出来。&lt;/p&gt;
&lt;h3&gt;zBackup特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用并行的LZMA或者LZO压缩算法压缩已备份数据&lt;/li&gt;
&lt;li&gt;使用内置的AES加密算法加密已备份数据&lt;/li&gt;
&lt;li&gt;可以删除旧的已备份数据&lt;/li&gt;
&lt;li&gt;使用一个64位滚动哈希，保持软碰撞数量为0&lt;/li&gt;
&lt;li&gt;备份库由不可更改的文件组成，只有库中不存在的文件才能修改&lt;/li&gt;
&lt;li&gt;使用C++语言编写，并且只有适量的依赖库&lt;/li&gt;
&lt;li&gt;可以在生产环境安全使用&lt;/li&gt;
&lt;li&gt;可以在不同备份库中交换数据而无需重新压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;在ubuntu中安装zBackup&lt;/h3&gt;
&lt;p&gt;打开终端并运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install zbackup
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;使用zBackup&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;zbackup init&lt;/code&gt;命令会初始化一个备份库，用来存放待备份的数据。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;zbackup init [--non-encrypted] [--password-file ~/.my_backup_password ] /my/backup/repo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;zbackup backup&lt;/code&gt;命令备份一个由&lt;code&gt;tar c&lt;/code&gt;命令创建的tar文件到刚才使用&lt;code&gt;zbackup init&lt;/code&gt;初始化的备份库。（LCTT 译注：实际使用时类似这样，tar c files | zbackup ...）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;zbackup [--password-file ~/.my_backup_password ] [--threads number_of_threads ] backup /my/backup/repo/backups/backup-`date ‘+%Y-%m-%d&amp;#39;`
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;zbackup restore&lt;/code&gt;命令从备份库中恢复一个已备份文件到tar文件中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;zbackup [--password-file ~/.my_backup_password ] [--cache-size cache_size_in_mb ] restore /my/backup/repo/backups/backup-`date ‘+%Y-%m-%d&amp;#39;` &amp;gt; /my/precious/backup-restored.tar
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;可用选项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;-non-encrypted -- 不加密备份库。&lt;/li&gt;
&lt;li&gt;--password-file ~/.my_backup_password -- 使用位于~/.my_backup_password的口令文件来加密备份库和待备份文件，以及解密已备份文件。&lt;/li&gt;
&lt;li&gt;--threads number_of_threads -- 限制并行LZMA压缩的线程数为 number_of_threads。建议在32位的系统平台使用。&lt;/li&gt;
&lt;li&gt;--cache-size cache_size_in_mb -- 使用cache_size_in_mb中的缓存大小来加速恢复文件的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;上述命令中 zBackup 相关文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;~/.my_backup_password 用来加密备份库和待备份文件，以及解密已备份文件。更多细节见zbackup。&lt;/li&gt;
&lt;li&gt;/my/backup/repo 存放备份库的目录。&lt;/li&gt;
&lt;li&gt;/my/precious/restored-tar 用来恢复已备份文件的tar文件。&lt;/li&gt;
&lt;li&gt;/my/backup/repo/backups/backup-&lt;code&gt;date ‘+%Y-%m-%d'&lt;/code&gt; 指定的之前已备份文件的文件名。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;via: http://www.ubuntugeek.com/zbackup-a-versatile-deduplicating-backup-tool.html&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://www.ubuntugeek.com/author/ubuntufix"&gt;ruchi&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>由“电子游戏为什么吸引人”引发的若干思考</title><link href="/you-dian-zi-you-xi-wei-shi-yao-xi-yin-ren-yin-fa-de-ruo-gan-si-kao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/you-dian-zi-you-xi-wei-shi-yao-xi-yin-ren-yin-fa-de-ruo-gan-si-kao.html</id><summary type="html">&lt;p&gt;有人总结电子游戏吸引人，主要是因为它具备如下几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;具体明晰的目标&lt;/li&gt;
&lt;li&gt;挑战与能力相匹配&lt;/li&gt;
&lt;li&gt;即时的反馈&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如我玩一个电脑游戏。&lt;/p&gt;
&lt;p&gt;首先，我要知道在游戏中我需要完成什么，即目标，这个目标必须是具体明晰的，这样电脑才可以判断出来。&lt;/p&gt;
&lt;p&gt;其次，为了完成这个目标我需要一些努力，如果我只是看着电脑屏幕，目标就自动完成了，这就不是游戏了，更不会吸引人，但如果我花费了很长时间还是没能完成目标，那么我就会放弃了。&lt;/p&gt;
&lt;p&gt;最后，每完成一个目标，游戏都会给我一些奖励，比如金币、等级等，这会给我继续玩的动力。&lt;/p&gt;
&lt;p&gt;因为游戏具有这三个特点，吸引了很多人，所以有人想为什么学习和工作不能具有这些特点，然后人们就可以像玩游戏一样“沉迷”于学习和工作了。简单说，就是根据自己的能力和偏好实现设置好短期目标和长期目标，要达成每个目标需要一些努力，但又在自己的能力范围内，一旦目标达成，就给自己一些奖励。看起来好像挺容易的，但好像成功的案例比较少，可复制的就更罕见了。&lt;/p&gt;
&lt;p&gt;那么这是什么原因？其实这么想犯了一个明显的错误，是假设每个人（或者多数人）都会喜欢电子游戏。其实并不是这样的，喜欢游戏的人是很多，但恐怕并不比喜欢听歌、看电视或者看电影的人多。并且很多人玩游戏 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;有人总结电子游戏吸引人，主要是因为它具备如下几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;具体明晰的目标&lt;/li&gt;
&lt;li&gt;挑战与能力相匹配&lt;/li&gt;
&lt;li&gt;即时的反馈&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如我玩一个电脑游戏。&lt;/p&gt;
&lt;p&gt;首先，我要知道在游戏中我需要完成什么，即目标，这个目标必须是具体明晰的，这样电脑才可以判断出来。&lt;/p&gt;
&lt;p&gt;其次，为了完成这个目标我需要一些努力，如果我只是看着电脑屏幕，目标就自动完成了，这就不是游戏了，更不会吸引人，但如果我花费了很长时间还是没能完成目标，那么我就会放弃了。&lt;/p&gt;
&lt;p&gt;最后，每完成一个目标，游戏都会给我一些奖励，比如金币、等级等，这会给我继续玩的动力。&lt;/p&gt;
&lt;p&gt;因为游戏具有这三个特点，吸引了很多人，所以有人想为什么学习和工作不能具有这些特点，然后人们就可以像玩游戏一样“沉迷”于学习和工作了。简单说，就是根据自己的能力和偏好实现设置好短期目标和长期目标，要达成每个目标需要一些努力，但又在自己的能力范围内，一旦目标达成，就给自己一些奖励。看起来好像挺容易的，但好像成功的案例比较少，可复制的就更罕见了。&lt;/p&gt;
&lt;p&gt;那么这是什么原因？其实这么想犯了一个明显的错误，是假设每个人（或者多数人）都会喜欢电子游戏。其实并不是这样的，喜欢游戏的人是很多，但恐怕并不比喜欢听歌、看电视或者看电影的人多。并且很多人玩游戏，并不是因为多么喜欢玩，而是因为在某些时候打发时间。并且游戏的种类非常多，每个游戏的侧重点不同，这样就能吸引不同的人，如果只做一款游戏，想吸引大多数人，那么无论怎样绞尽脑汁，让它怎样程度地符合之前那三个特点，也是不可能的。&lt;/p&gt;
&lt;p&gt;但近几年，有一个比电子游戏更吸引人的东西出现了，这可能更值得思考，它就是手机。和电子游戏不同，它真正吸引了多数人。但奇怪的是，手机并不满足那三个特点。很多人玩手机时并没有明确的目标，过程中也没有什么挑战，甚至也没什么值得一提的奖励式反馈。那么手机是如何做到吸引多数人的？我们能不能让人们像喜欢玩手机一样喜欢学习或者工作呢？&lt;/p&gt;</content></entry><entry><title>友情和爱情的区别</title><link href="/you-qing-he-ai-qing-de-qu-bie.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/you-qing-he-ai-qing-de-qu-bie.html</id><summary type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;这是我两年前写的旧文，虽然最近很少再思考爱情方面的问题，但重读后发现自己基本还是保持之前的观点。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;友情和爱情的本质区别是我疑惑了比较长时间的一个问题，我一度认为自己想不出结果了，这几天在想另一个问题时，突然对这个问题有了新的看法。&lt;/p&gt;
&lt;p&gt;我认为友情和爱情并没有本质区别，爱的程度上，友情要低于爱情。&lt;/p&gt;
&lt;p&gt;关于这个问题另一个截然不同的观点是：友情和爱情有着本质的区别，就像两条路，如果两个人往朋友关系发展，就会离恋人关系越来越远。&lt;/p&gt;
&lt;p&gt;分析这个问题并不容易，下面尝试从几句话着手。&lt;/p&gt;
&lt;p&gt;关于友情和爱情，有几句经典的话：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们关系很好，无话不谈，却只能做朋友。&lt;/li&gt;
&lt;li&gt;因为太熟悉了，所以不会成为恋人。&lt;/li&gt;
&lt;li&gt;对不起，我从最开始就只把你当朋友/哥哥/妹妹/姐姐/弟弟。&lt;/li&gt;
&lt;li&gt;如果表白后，被拒绝了，朋友也做不成了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从以上4句话看，全对“友情和爱情有本质区别”的观点有利，所以最开始我也是更倾向这种观点的。于是我开始想这个本质区别是什么，最容易想到的是友情和爱情是完全不同的两种感情，这也是被广为接受的一种观点，但区别在哪呢？&lt;/p&gt;
&lt;p&gt;如果友情和爱情完全不同，那两个人的感情应该既有友情的成分，又有爱情的成分。可以把两个人假设为两个点，而友情和爱情是两个点相互的作用力。但根据实际情况，这个力不是相互的，也就是你喜欢她但她不一定喜欢你 …&lt;/p&gt;</summary><content type="html">&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;这是我两年前写的旧文，虽然最近很少再思考爱情方面的问题，但重读后发现自己基本还是保持之前的观点。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;友情和爱情的本质区别是我疑惑了比较长时间的一个问题，我一度认为自己想不出结果了，这几天在想另一个问题时，突然对这个问题有了新的看法。&lt;/p&gt;
&lt;p&gt;我认为友情和爱情并没有本质区别，爱的程度上，友情要低于爱情。&lt;/p&gt;
&lt;p&gt;关于这个问题另一个截然不同的观点是：友情和爱情有着本质的区别，就像两条路，如果两个人往朋友关系发展，就会离恋人关系越来越远。&lt;/p&gt;
&lt;p&gt;分析这个问题并不容易，下面尝试从几句话着手。&lt;/p&gt;
&lt;p&gt;关于友情和爱情，有几句经典的话：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们关系很好，无话不谈，却只能做朋友。&lt;/li&gt;
&lt;li&gt;因为太熟悉了，所以不会成为恋人。&lt;/li&gt;
&lt;li&gt;对不起，我从最开始就只把你当朋友/哥哥/妹妹/姐姐/弟弟。&lt;/li&gt;
&lt;li&gt;如果表白后，被拒绝了，朋友也做不成了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从以上4句话看，全对“友情和爱情有本质区别”的观点有利，所以最开始我也是更倾向这种观点的。于是我开始想这个本质区别是什么，最容易想到的是友情和爱情是完全不同的两种感情，这也是被广为接受的一种观点，但区别在哪呢？&lt;/p&gt;
&lt;p&gt;如果友情和爱情完全不同，那两个人的感情应该既有友情的成分，又有爱情的成分。可以把两个人假设为两个点，而友情和爱情是两个点相互的作用力。但根据实际情况，这个力不是相互的，也就是你喜欢她但她不一定喜欢你。这样有两种说法，一种是相恋的两个人只有爱情没有友情，另一种是他们既有爱情又有友情，只是爱情比友情更强烈。&lt;/p&gt;
&lt;p&gt;先看第一种说法，两个人本来是朋友，但慢慢随着互相了解的加深，往恋人关系过渡。那反映到模型上就是两个点间的友情作用突然断裂，同时近似相同大小的爱情作用生成，也就是友情变成了爱情。友情和爱情有本质区别，但可以跳过量变直接完成质变，是很难让人接受的，如果有人认为这还不构成矛盾。而且我们知道“关心”、“爱护”之类基本元素在亲情、友情、爱情中都是存在的，认为友情和爱情都是不可拆解的感情更像是逃避问题，而不是解决问题。&lt;/p&gt;
&lt;p&gt;那第二种说法呢，看起来复杂些。两个人之间既有友情又有爱情，强者占主导地位。这种说法存在更大的问题。在这个模型上看，友情和爱情有本质区别并没问题，但实际上这个本质区别说的是两个人之间，或者是爱情，或者是友情，也就是人与人关系的本质区别。但两个人之间的感情却是混合着爱情和友情的一种东西，如果爱情强了是爱情，爱情弱了就是友情，本质区别变成了二者的数值比较，里边单独的友情和爱情已经没有了意义，和前提描述的不符。&lt;/p&gt;
&lt;p&gt;那只好看看友情和爱情没有本质区别的观点，能否自圆其说。首先面对的就是上边的4句话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、我们关系很好，无话不谈，却只能做朋友。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个是出现最频繁的，我在网上搜友情到爱情过渡失败的例子，数十个出现类似的描述，占多数。这句话看上去无懈可击，关系很好，却不能成为恋人，是因为是往朋友方向发展跑偏了，离恋人关系越来越远么，是否有其他解释？&lt;/p&gt;
&lt;p&gt;有的。这句话极具误导性，诱导点在于“关系很好，无话不谈”。言外之意就是因为无话不谈，所以关系很好。实际从使用这句话的上下文也看出就是这个意思。两个人在网上、电话或者面对面无话不谈，于是一方甚至双方认为和对方关系很好。但无话不谈真的就是关系很好吗？&lt;/p&gt;
&lt;p&gt;不是！想到这里我也有些吃惊了。事实上无话不谈不仅不是关系很好，而是关系很一般，浮于表面。可以想想，你在网上遇到一个谈得来的人，几天时间就聊了很多，不管是个人自然情况、情感史、对各种问题的理解、甚至一些和亲戚朋友恋人都不会提起的隐私，都聊得来，说无话不谈一点也不过分。但这能算关系很好吗。两个人没相处过，甚至面都没见着，只是通过文字瞎子摸象般了解对方。&lt;/p&gt;
&lt;p&gt;无话不谈的原因是无戒备、无顾虑，再加上一点信任，基本就没别的了。你基本不考虑对方是否喜欢这个话题，看了这句话是否有什么不良反应，是否侵犯到对方隐私等等。也就是不在乎，无责任感。说得夸张点，你们真的无话不谈，是因为你们互相根本不在乎对方，这怎么叫关系好？在这个基础上往恋人发展，不用想就知道可能性渺茫，能发展成普通朋友就不错了。&lt;/p&gt;
&lt;p&gt;当然慢慢两个人可能会慢慢了解对方喜欢什么反感什么，也就不再是无话不谈了，继续发展下去，实际关系是在加深。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、因为太熟悉了，所以不会成为恋人。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这句话实际是有一些道理的，但只是在某种特定情况下。这句话的诱导性会让这一点点道理不值得一提。&lt;/p&gt;
&lt;p&gt;说这句话的情景，一般是两个人，一方甚至双方认为和对方太熟，无法往恋人关系发展，实际也没有表白发生，然后和局外人说的。&lt;/p&gt;
&lt;p&gt;先说这个特定情况。就是一方或双方确实很了解对方，深知对方的某缺点（外在或内在）不符合择偶要求，进而不会往恋人关系发展，但这个缺点不影响成为好朋友。这个缺点外在的可能是钱、家庭条件、地理因素等等，内在的可能是性格上、志向上等等。关于这个再多说一句，我认为只有外在因素基本起不到决定性作用，往往是已经有内在因素了，但用那个外在因素作为说辞。&lt;/p&gt;
&lt;p&gt;但这往往不是多数情况，多数情况是这样的。&lt;/p&gt;
&lt;p&gt;所谓熟悉只是表面的熟悉，实际根本不了解对方的真实想法。我网上查到的情景基本都是这类。双方可能确实关系还好，经常一起出去玩得很开心，其中一方或双方知道如何取悦对方，甚至不分彼此，这个和无话不谈是不同的。双方以对方好友、哥们、知己、知音等自居。但关系就不继续发展了，维持了现状，久了就产生了那个想法。&lt;/p&gt;
&lt;p&gt;这种情况是双方关系发展到了一个瓶颈，其实其中一方或双方已经想到往恋人方向发展了，但存在种种问题，比如对方对自己的了解还不够，不够体贴，一些原则性问题无法达成共识等等。但都不想主动再往前迈一步，或者主动提出，于是不再发展了。慢慢因为一直维持着现状，新鲜感也没了，造成太熟悉的假象，像什么没感觉了之类。这种情况如果一方意识到了，主动再迈出一步，或者更深入了解对方，还是很可能发展成恋人的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、对不起，我从最开始就只把你当朋友/哥哥/妹妹/姐姐/弟弟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个只能说是骗人。当然可能是有意的，也可能是无意的。&lt;/p&gt;
&lt;p&gt;有意的就是，明明动了真感情，后来发现对方有缺点无法满足择偶要求的情况。&lt;/p&gt;
&lt;p&gt;无意的是，确实他从最开始就是这么当的，对于说这话的人他没有撒谎，但这句话本身有问题。不是说这种感情与爱情有本质的不同，而是它具有了爱情的某些特点，但缺失了另一些，使它看起来更像友情或者亲情。这种情况也不是不能发展的，找出问题所在，双方做出一些改变后，还是有一定可能发展成恋人的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、如果表白了，被拒绝了，朋友也做不成了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种情况是最纠结的。因为这是一个选择，而且有赌注在里边。我想很多人都面临过这个选择。提这个是因为，如果爱情和友情有本质区别，为什么在爱情上的努力会严重影响到友情，如果没有本质区别，这个表白究竟产生了什么作用，当然现在这个不是主要的话题了。&lt;/p&gt;
&lt;p&gt;首先看下这个结果在什么情况会发生。&lt;/p&gt;
&lt;p&gt;实际上这个结果的发生还是比较多的。但看看那些实例，其实多数是和第1句话类似的场景。但为什么第1句话里表白后做了朋友，这个连朋友都没得做呢？（想到个有趣的方法，如果想和一个认识不久的人快速成为普通朋友，表白吧。当然这不是个好方法。）&lt;/p&gt;
&lt;p&gt;因为这种情况发生前，两个人确实是关系不错的朋友，类似于第2句的情况，也就是说它是第2句的前提下，一方表白了后的一种结果。那么看下在什么情况下，会出现这个结果。&lt;/p&gt;
&lt;p&gt;在那种情况表白会有几种结果，一是打破僵局成为恋人，二是话说明白后保持原有的朋友关系，三是这里说的，不仅没成为恋人，原有的朋友关系也断裂了。&lt;/p&gt;
&lt;p&gt;先看看第二种结果，相对还好分析点。一般是表白的人的对方知道他满足不了自己择偶要求。还有个变体，是他说，我配不上你，你找个更好的吧。这种情况往往不是单纯的自卑、谦虚之类，而是确实对方满足不了自己择偶要求，只是换个说法说出来好听些。不过这个说法太伤人了，因为还有后劲，还不如直说。（关于这个还有很多容易误解的问题，不在这提了。）&lt;/p&gt;
&lt;p&gt;然后呢，表白的人接收了事实，认为确实做恋人不合适，还是保持朋友吧，所以对原有的朋友关系也没有太大影响。&lt;/p&gt;
&lt;p&gt;那第三种结果呢，前半部分和第二种结果一样，不同在于后半部分。就是表白的人不甘心，感觉不公平，自己付出那么多为什么得不到回报等等。同时被表白的人也发现了对方的异常，朋友无法继续做下去。&lt;/p&gt;
&lt;p&gt;是否有表白的人自己感觉没什么，但被表白的人主动疏远了呢？这种情况也有，但我想主要是因为沟通不善了解不周，导致被表白人认为对方没死心，而从自己看是不存在可能性的，为了避免进一步伤害对方，用疏远进行进一步的暗示，而对方又理解错了，认为是朋友也没得做了。&lt;/p&gt;
&lt;p&gt;除了这4句话，还有许多关于友情和爱情的纠结问题，但都可以用类似的方法加以分析，结果也是类似的。&lt;/p&gt;
&lt;p&gt;如果这个结论是合理的，多数人对友情和爱情相关的问题都有相当的认识误区，为此许多对本可能在一起的两个人因为不应该的原因只做了朋友甚至朋友都没做成。&lt;/p&gt;</content></entry><entry><title>在 Archlinux 编译 Termux 包</title><link href="/zai-archlinux-bian-yi-termux-bao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zai-archlinux-bian-yi-termux-bao.html</id><summary type="html">&lt;p&gt;&lt;a href="https://termux.com/"&gt;Termux&lt;/a&gt; 是 Android 上的一个非常强大的终端模拟器。强大之处在于支持使用 apt 安装 zsh、git、vim、python、ruby、nodejs、openssh、gcc、golang 等几乎所有常用的终端软件，从此不用忍受功能孱弱的 busybox。&lt;/p&gt;
&lt;p&gt;目前 termux 源中有 400 多个包，显然还有很多不那么常用的没有覆盖到，除了在 &lt;a href="https://github.com/termux/termux-packages/issues"&gt;Issues · termux/termux-packages&lt;/a&gt; 上反馈外，自己编译也是个不错的主意。但目前相关文档比较匮乏（主页的 Readme 有错误），一不留神就会将简单的事情复杂化，耽误时间，故整理此文。&lt;/p&gt;
&lt;p&gt;需要注意的是，虽然 Termux 包使用的是 deb 格式，但无需使用基于 Debian 或者 Ubuntu 的发行版。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/termux/termux-packages"&gt;主页的 …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://termux.com/"&gt;Termux&lt;/a&gt; 是 Android 上的一个非常强大的终端模拟器。强大之处在于支持使用 apt 安装 zsh、git、vim、python、ruby、nodejs、openssh、gcc、golang 等几乎所有常用的终端软件，从此不用忍受功能孱弱的 busybox。&lt;/p&gt;
&lt;p&gt;目前 termux 源中有 400 多个包，显然还有很多不那么常用的没有覆盖到，除了在 &lt;a href="https://github.com/termux/termux-packages/issues"&gt;Issues · termux/termux-packages&lt;/a&gt; 上反馈外，自己编译也是个不错的主意。但目前相关文档比较匮乏（主页的 Readme 有错误），一不留神就会将简单的事情复杂化，耽误时间，故整理此文。&lt;/p&gt;
&lt;p&gt;需要注意的是，虽然 Termux 包使用的是 deb 格式，但无需使用基于 Debian 或者 Ubuntu 的发行版。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/termux/termux-packages"&gt;主页的 Readme &lt;/a&gt; 提供了两种方式，一种是使用 Docker 中的 Ubuntu 镜像，一种是直接在 Ubuntu 搭建环境。&lt;/p&gt;
&lt;p&gt;我图省事先用的 Docker 方式，虽然看起来很简单，只需要执行两条命令，但我折腾了几十分钟也没搞定。&lt;/p&gt;
&lt;p&gt;因为执行 &lt;code&gt;docker build --rm=true -t termux .&lt;/code&gt; 后会安装和升级大量（1G 左右）的包，默认的官方源速度是很不给力的。这样或者修改 &lt;code&gt;Dockerfile&lt;/code&gt; 修改源，或者直接手动进 Docker 里操作。这就不是两条命令的事情了，需要对 Docker 比较熟悉。我选择直接手动进 Docker 里操作。在安装过程中，我发现安装了大量看起来没有用的包，占用了大量空间。同时我看了下 &lt;code&gt;build-package.sh&lt;/code&gt; 脚本，发现并没有依赖 Ubuntu 特有的命令，于是改用直接在 Archlinux 里搭建环境，这样能节省很多时间。&lt;/p&gt;
&lt;p&gt;大概看了下几个脚本，发现步骤很简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载 termux-packages （&lt;code&gt;git clone https://github.com/termux/termux-packages.git&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;安装 android-ndk。下载 http://dl.google.com/android/android-sdk_r24.3.4-linux.tgz ，解压到 $HOME/lib/android-ndk （该目录下有 source.properties 文件）。（android-sdk 通常不需要，如需要，方法类似）&lt;/li&gt;
&lt;li&gt;创建 /data/data/com.termux/files/usr 目录，并把 /data 的属主改成当前用户。&lt;/li&gt;
&lt;li&gt;进入 termux-packages ，就可以直接用 &lt;code&gt;./build-package.sh packagename&lt;/code&gt; 编译包了（如果提示命令找不到，安装对应的包即可）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;搭建完可以随便编译一个包试试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;build&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;package&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;sh&lt;/span&gt; &lt;span class="s s-Atom"&gt;bc&lt;/span&gt;
&lt;span class="s s-Atom"&gt;termux&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;building&lt;/span&gt; &lt;span class="s s-Atom"&gt;bc&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
  &lt;span class="c1"&gt;% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current&lt;/span&gt;
                                 &lt;span class="nv"&gt;Dload&lt;/span&gt;  &lt;span class="nv"&gt;Upload&lt;/span&gt;   &lt;span class="nv"&gt;Total&lt;/span&gt;   &lt;span class="nv"&gt;Spent&lt;/span&gt;    &lt;span class="nv"&gt;Left&lt;/span&gt;  &lt;span class="nv"&gt;Speed&lt;/span&gt;
&lt;span class="mi"&gt;100&lt;/span&gt;  &lt;span class="mi"&gt;283&lt;/span&gt;&lt;span class="s s-Atom"&gt;k&lt;/span&gt;  &lt;span class="mi"&gt;100&lt;/span&gt;  &lt;span class="mi"&gt;283&lt;/span&gt;&lt;span class="s s-Atom"&gt;k&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;     &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;12885&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt; &lt;span class="s s-Atom"&gt;--:--:--&lt;/span&gt; &lt;span class="mi"&gt;74740&lt;/span&gt;
&lt;span class="nn"&gt;sed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s s-Atom"&gt;no&lt;/span&gt; &lt;span class="s s-Atom"&gt;input&lt;/span&gt; &lt;span class="s s-Atom"&gt;files&lt;/span&gt;
&lt;span class="nn"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;WARNING&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;If&lt;/span&gt; &lt;span class="s s-Atom"&gt;you&lt;/span&gt; &lt;span class="s s-Atom"&gt;wanted&lt;/span&gt; &lt;span class="s s-Atom"&gt;to&lt;/span&gt; &lt;span class="s s-Atom"&gt;set&lt;/span&gt; &lt;span class="s s-Atom"&gt;the&lt;/span&gt; &lt;span class="s s-Atom"&gt;--build&lt;/span&gt; &lt;span class="s s-Atom"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;don&amp;#39;t use --host.&lt;/span&gt;
&lt;span class="s s-Atom"&gt;    If a cross compiler is detected then cross compile mode will be used.&lt;/span&gt;
&lt;span class="s s-Atom"&gt;checking for a BSD-compatible install... /usr/bin/install -c&lt;/span&gt;
&lt;span class="s s-Atom"&gt;checking whether build environment is sane... yes&lt;/span&gt;
&lt;span class="s s-Atom"&gt;checking for gawk... gawk&lt;/span&gt;
&lt;span class="s s-Atom"&gt;checking whether make sets $(MAKE)... yes&lt;/span&gt;
&lt;span class="s s-Atom"&gt;...&lt;/span&gt;
&lt;span class="s s-Atom"&gt;make[2]: Leaving directory &amp;#39;&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;goreliu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;termux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;build&amp;#39;dc&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="s s-Atom"&gt;make[1]: Leaving directory &amp;#39;&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;goreliu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;termux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;build&amp;#39;-- &amp;quot;/data/data/com.termux/files/usr/bin&amp;quot;&lt;/span&gt;
&lt;span class="s s-Atom"&gt;termux-elf-cleaner: Removing the DT_VERNEEDED dynamic section entry from &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bc&amp;#39;&lt;/span&gt;
&lt;span class="s s-Atom"&gt;termux-elf-cleaner: Removing the DT_VERNEEDNUM dynamic section entry from &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bc&amp;#39;&lt;/span&gt;
&lt;span class="s s-Atom"&gt;termux-elf-cleaner: Removing the DT_VERNEEDED dynamic section entry from &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;dc&amp;#39;&lt;/span&gt;
&lt;span class="s s-Atom"&gt;termux-elf-cleaner: Removing the DT_VERNEEDNUM dynamic section entry from &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;dc&amp;#39;/files/usr/info&amp;quot;&lt;/span&gt;
&lt;span class="s s-Atom"&gt;termux - build of &amp;#39;bc&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="s s-Atom"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为 &lt;code&gt;build-package.sh&lt;/code&gt; 这个脚本写得比较渣，可能提示一些错误，但不影响功能，编译出来了。结果在 &lt;code&gt;$HOME/termux/_deb/bc_1.06.95-1_arm.deb&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这里需要注意的是 &lt;code&gt;build-package.sh&lt;/code&gt; 编译的是 32 位 arm 版本，如果需要的不是这个，可以直接改 &lt;code&gt;build-package.sh&lt;/code&gt; ，将&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;: &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;TERMUX_ARCH&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;arm&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; # (arm|aarch64|i686|x86_64) - the 64 bit variants do not work yet
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;里的 &lt;code&gt;"arm"&lt;/code&gt;改成后边括号内的，比如 aarch64 是64 位 arm 的。&lt;/p&gt;
&lt;p&gt;还有因为 android-ndk 目录体积巨大，在编译完一个包后，这个目录的同级目录下会产生一个类似 android-standalone-toolchain-aarch64-api21-gcc4.9 的目录，然后我们就可以只保留 android-ndk 下的 source.properties 文件，将该目录其他文件删除（试验如此，保险的话还是先保留）。&lt;/p&gt;
&lt;p&gt;验证没问题了，我们就可以添加源里没有的包了，拿 atool 举例：&lt;/p&gt;
&lt;p&gt;新建 termux-packages/packages/atool 目录，在该目录创建 build.sh 文件，内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;TERMUX_PKG_HOMEPAGE=http://www.nongnu.org/atool
TERMUX_PKG_DESCRIPTION=&amp;quot;A script for managing file archives of various types&amp;quot;
TERMUX_PKG_VERSION=0.39.0
TERMUX_PKG_BUILD_REVISION=1
TERMUX_PKG_SRCURL=https://savannah.nongnu.org/download/atool/atool-&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;TERMUX_PKG_VERSION&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;.tar.gz
TERMUX_PKG_DEPENDS=&amp;quot;file, perl&amp;quot;
TERMUX_PKG_PLATFORM_INDEPENDENT=yes
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这些字段都比较简单，参考 termux-packages/packages 下的例子就可以写出来（有疑问的话，可以看 build-package.sh 脚本的实现）。&lt;/p&gt;
&lt;p&gt;然后在 termux-packages 目录运行 &lt;code&gt;./build-package.sh atool&lt;/code&gt; 就可以了。&lt;/p&gt;</content></entry><entry><title>在没有工作的半年时间，我做了什么</title><link href="/zai-mei-you-gong-zuo-de-ban-nian-shi-jian-wo-zuo-liao-shi-yao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zai-mei-you-gong-zuo-de-ban-nian-shi-jian-wo-zuo-liao-shi-yao.html</id><summary type="html">&lt;p&gt;转眼间已经过去了半年多，时间过得也是很快。这半年也确实发生了很多事情，突然想盘点一下，也当作一个总结吧。&lt;/p&gt;
&lt;p&gt;在休年假的十几天里，我连续去了八天图书馆，现在想起来还印象深刻。上完最后半天班，吃完饭，收拾完东西，走出了办公楼，当时并没有什么特殊的感觉。然后我就坐地铁直奔国图了，可能是因为想不到其他可去的地方吧。然后接下来的七天我都去了图书馆，国图或者首图。然后我就突然不想去了，于是再也没去过。除了去图书馆，大概就是看电影了。那十几天，我一共看了 8 个电影吧，好几天都是一天看两场，有的感觉还不错，有的看了一半就想走了。&lt;/p&gt;
&lt;p&gt;接下来的一个月是在家过的，期间去 合肥-南京-无锡-苏州-上海 玩了一趟，去看了几个朋友。感觉南京是个不错的城市，以后可以去那住一段时间，而上海完全没有第一次去的感觉了，基本只去了外滩和田子坊转了转，就回家了。&lt;/p&gt;
&lt;p&gt;如我所愿，11 月来了威海，第二天就租到了房子，环境还不错，接下来就是我如愿以偿的生活了吧。开始时也完全没计划做什么，几乎天天去海边散步，其余时间就上上网。偶然对赛斯书产生了兴趣，看了十几天，加了两个灵修相关的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;转眼间已经过去了半年多，时间过得也是很快。这半年也确实发生了很多事情，突然想盘点一下，也当作一个总结吧。&lt;/p&gt;
&lt;p&gt;在休年假的十几天里，我连续去了八天图书馆，现在想起来还印象深刻。上完最后半天班，吃完饭，收拾完东西，走出了办公楼，当时并没有什么特殊的感觉。然后我就坐地铁直奔国图了，可能是因为想不到其他可去的地方吧。然后接下来的七天我都去了图书馆，国图或者首图。然后我就突然不想去了，于是再也没去过。除了去图书馆，大概就是看电影了。那十几天，我一共看了 8 个电影吧，好几天都是一天看两场，有的感觉还不错，有的看了一半就想走了。&lt;/p&gt;
&lt;p&gt;接下来的一个月是在家过的，期间去 合肥-南京-无锡-苏州-上海 玩了一趟，去看了几个朋友。感觉南京是个不错的城市，以后可以去那住一段时间，而上海完全没有第一次去的感觉了，基本只去了外滩和田子坊转了转，就回家了。&lt;/p&gt;
&lt;p&gt;如我所愿，11 月来了威海，第二天就租到了房子，环境还不错，接下来就是我如愿以偿的生活了吧。开始时也完全没计划做什么，几乎天天去海边散步，其余时间就上上网。偶然对赛斯书产生了兴趣，看了十几天，加了两个灵修相关的 QQ 群，也时不时在相关贴吧回复一下贴子。慢慢就不感兴趣了，相关的 QQ 群也屏蔽了，感觉国内的灵修圈真是气氛很不好的地方，不过也难怪。&lt;/p&gt;
&lt;p&gt;接下来就有些无所事事了，对周围的环境熟悉了后，也不想经常出去了。手机天天看也没兴趣了，就开着电脑随便看些什么。当时喜欢看一些游戏视频，主要是 doraiba 的 《零：濡鸦之巫女初见实况》，这个是我几个月前就开始看的，但没看完，这回又从头开始看了一遍。感触还是比较深的，因为游戏的主题是孤独，而我对孤独有一种特殊的情结吧。我还记得看完最后一期的那一天的晚上，我顺着海边一直走，耳机里单曲循环着游戏中的一首主题曲《鸟笼》，往回走的时候，路过一座石桥，我回过头看了好久，就像我再也不会回来了。&lt;/p&gt;
&lt;p&gt;第二天我照常醒来，但感觉有些东西好像再也不会回来了，某种非常失落的感觉，好像和某种生活告别了一样，那几天心情都不大好。那时离过年只有几天了，我突然想做一个《零：濡鸦之巫女》的视频剪辑 mv，背景就是那首《鸟笼》，最后在火车上我用手机记下怎样安排场景。回家后的几天我一直在做这个 mv，春节晚会都没看，终于在大年初一做完了，当时也是特别开心。再回到威海时，我又做了几个视频剪辑，但没有当初的感觉了，另外因为看的人实在太少了，也就没兴趣了。&lt;/p&gt;
&lt;p&gt;我又开始对电脑感兴趣，毕竟是老本行。当时我突然想起有个 TotalCommander 的文件管理软件，之前用过几次，都当天就卸了，这会正好没事，再装个试试。我同时又搜到了一个 VimDesktop 的软件，是用类 vim 的按键绑定来操作 TotalCommander，一用果然不错。这回没有再卸载 TotalCommander，反而对 VimDesktop 非常感兴趣。接下来，我开始维护这个 VimDesktop，也算是我除了玩之外做的第一件正经的事情吧。我曾经就想，用不了半年，我就会找些事情做，果然没到半年。&lt;/p&gt;
&lt;p&gt;因为维护 VimDesktop，我加了两个 QQ 群，也认识了一些朋友。另外开始解答一些人的问题，突然又想起工作时解答问题的场景，真是轻车熟路。VimDesktop 升级了 10 多个版本后，比较稳定了，也没什么想新增的功能了，我就开始想自己写个软件，于是有了 RunZ。当天晚上我在手机记下功能点，然后用了一天的时间，基本的功能就写好了。然后用了两周时间，每天升级一个版本，最后也比较满意了。我本想写文章宣传 RunZ，但后来想来想去，还是感觉这样的小众软件再怎么宣传也不会吸引多少用户，现在宣传时机还没有成熟，以后再说吧。然后我突然想写文章介绍下 AHK，也就是 VimDesktop 和 RunZ 所使用的编程语言。于是我开通了微信公众号和知乎专栏，每天发一篇 AHK 相关的文章。我本来是完全因为兴趣的，发了几篇后突然感觉以后或许可以结集出版，然后就更有动力了一些。这已经就是这几天的事情了。&lt;/p&gt;
&lt;p&gt;期间还发生了许多事情，就不一一展开了。总体来说，我确实过上了自己想要的生活。我也验证了自己之前的观点，一个人闲久了就总会找些事情做的。最近几个月的花销比较少，每个月房租吃喝日用全加起来不到两千，也没有什么特别想吃的或者想买的。这样算起来，即使不考虑收入问题，也还能过好久。我本来是打算做软件外包赚钱，但几次想尝试都没什么兴趣，也就作罢。现在看来靠写东西赚钱也并非不可能，不过这也是后话了。&lt;/p&gt;
&lt;p&gt;在没事情做的时候，我也想过静坐冥想之类，但尝试了几次都放弃了。不到一会就感觉困了，然后就躺下睡觉了。现在有事情做了，对那些就更没兴趣了，感觉还是因人而异吧。&lt;/p&gt;
&lt;p&gt;以前我总想思考一些人生大道理之类，现在也不怎么想了，也许是一些问题想通了也就没兴趣了吧。而且自己的观点也只是自己的观点，别人没有我的经历，对我的观点也自然没有什么感触。几个月前我最困惑的一个问题，是我不清楚我还在留恋这个世界的什么。最后在机缘巧合下我终于想明白了这个问题，我只是认为现在的我还很重要而已，即使我不再留恋其他的任何东西，只要我还认为现在的我很重要，我就还是现在的我。什么时候我认为这个我已经不重要了，自然也就无所谓了。对世界的留恋，终究也只是对自己的留恋而已。没有了自己，那个曾经属于自己的世界也就荡然无存了。如果真的离开的话，并不是离开了自己所在这个世界，而是毁灭了自己所在的这个世界。有千千万万个世界，其中有一个比较特别，只因为自己就处于那个世界。而离开之后，那个世界和其他的千千万万个世界没有丝毫区别，哪一个是你的呢？&lt;/p&gt;</content></entry><entry><title>在远离电子产品的两天里</title><link href="/zai-yuan-chi-dian-zi-chan-pin-de-liang-tian-li.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zai-yuan-chi-dian-zi-chan-pin-de-liang-tian-li.html</id><summary type="html">&lt;p&gt;25号晚上我突然想做这样一个实验，在接下来的一周时间里，不接触网络以及相关电子产品，细则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了手机，自己其他的如电脑、平板等带屏幕或者能播放声音的电子产品都关机&lt;/li&gt;
&lt;li&gt;手机断网，只有来电话或者提示灯亮（有未接来电或者短信）时才可以看屏幕，不能处理除了电话和短信之外的其他事情&lt;/li&gt;
&lt;li&gt;不主动看时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在是28号凌晨，我现在写了这篇文章，显然实验已经失败了，只持续了两天零五个小时。我承认现在做这个实验时机不是很成熟，不过还是简单总结一下吧，多少有一些收获。&lt;/p&gt;
&lt;h2&gt;26号&lt;/h2&gt;
&lt;p&gt;起床后太阳已经很高，看起来大概9点多了。吃完饭后去海边走了走。因为几天前刚下过大雪，沙滩被积雪取代，很漂亮。海水下边是冰，表面没有结冰，看起来有些奇怪，是因为退潮后海水和之前已经融化的雪结冰了，然后又涨潮了。&lt;/p&gt;
&lt;p&gt;在路上我突然想到一个问题，是和自由有关的。我们如何判断一个行为是否干涉了对方的自由呢？&lt;/p&gt;
&lt;p&gt;其实这来自于另一个问题，如何有效地帮助别人，不过这个问题我暂时不想写。不得不说这是个不好回答的问题，真正帮助到别人远没有想象的那么简单。&lt;/p&gt;
&lt;p&gt;还是说自由吧。举个不是那么恰当的例子，比如说有一个外星文明突然发现了地球，简单了解后发现地球已经被地球人破坏得不成样子，而地球人似乎过得不那么幸福。而这个外星文明拥有先进的技术，同时生活得很幸福，想必是可以帮助到地球人的。那么问题是这种帮助是否会干涉地球人以及地球上其他生命的自由呢？如果一种文明的发展注定要经历如今这样的阶段才能迈向更高的阶段 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;25号晚上我突然想做这样一个实验，在接下来的一周时间里，不接触网络以及相关电子产品，细则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了手机，自己其他的如电脑、平板等带屏幕或者能播放声音的电子产品都关机&lt;/li&gt;
&lt;li&gt;手机断网，只有来电话或者提示灯亮（有未接来电或者短信）时才可以看屏幕，不能处理除了电话和短信之外的其他事情&lt;/li&gt;
&lt;li&gt;不主动看时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在是28号凌晨，我现在写了这篇文章，显然实验已经失败了，只持续了两天零五个小时。我承认现在做这个实验时机不是很成熟，不过还是简单总结一下吧，多少有一些收获。&lt;/p&gt;
&lt;h2&gt;26号&lt;/h2&gt;
&lt;p&gt;起床后太阳已经很高，看起来大概9点多了。吃完饭后去海边走了走。因为几天前刚下过大雪，沙滩被积雪取代，很漂亮。海水下边是冰，表面没有结冰，看起来有些奇怪，是因为退潮后海水和之前已经融化的雪结冰了，然后又涨潮了。&lt;/p&gt;
&lt;p&gt;在路上我突然想到一个问题，是和自由有关的。我们如何判断一个行为是否干涉了对方的自由呢？&lt;/p&gt;
&lt;p&gt;其实这来自于另一个问题，如何有效地帮助别人，不过这个问题我暂时不想写。不得不说这是个不好回答的问题，真正帮助到别人远没有想象的那么简单。&lt;/p&gt;
&lt;p&gt;还是说自由吧。举个不是那么恰当的例子，比如说有一个外星文明突然发现了地球，简单了解后发现地球已经被地球人破坏得不成样子，而地球人似乎过得不那么幸福。而这个外星文明拥有先进的技术，同时生活得很幸福，想必是可以帮助到地球人的。那么问题是这种帮助是否会干涉地球人以及地球上其他生命的自由呢？如果一种文明的发展注定要经历如今这样的阶段才能迈向更高的阶段，那么这样的帮助是否真的是有益的，而不是揠苗助长那样将这个文明推向灭亡呢？&lt;/p&gt;
&lt;p&gt;简单想了下后，我自己定义了一个名为“自由行为”的行为，满足如下四个特点的行为是“自由行为”：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当事人清楚自己在做什么&lt;/li&gt;
&lt;li&gt;当事人确定自己在做的事情正是自己想做的&lt;/li&gt;
&lt;li&gt;当事人能够预期事情的结果&lt;/li&gt;
&lt;li&gt;当事人可以对事情的结果负责&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果在未经对方同意的前提下，对对方的自由行为产生阻碍性影响，就是干涉对方的自由。&lt;/p&gt;
&lt;p&gt;简单举几个例子。&lt;/p&gt;
&lt;p&gt;针对特点一。比如某人正要吃感冒药，药已经到了嘴边，但他不知道感冒药已经被其他人替换成毒药，一下肚就会当场毙命。一个知情人发现，手疾眼快将他手中的药打翻在地。因为服药人对自己正在做什么并不清楚，知情人的行为不是干涉他的自由。&lt;/p&gt;
&lt;p&gt;针对特点二。一个不会游泳的人，不慎落水。他知道自己的处境，但挣脱的力气都没有了。正巧一个路人发现并把他救下。对于当事人，他清楚自己在经历落水一事，但这是意外而不是他真正想做的事情，救人者没有干涉他的自由。&lt;/p&gt;
&lt;p&gt;针对特点三。一个壮汉得知他妹妹被同学欺负，立即从厨房取出菜刀，直奔她不远处的同学。此时一个邻居及时发现和武力制止，并促成双方的和解。当事人知道自己是给妹妹报仇，也确定这就是他想做的事情，但一时冲动并未考虑结果，邻居的行为不构成对他自由的干涉。&lt;/p&gt;
&lt;p&gt;针对特点四。另一个壮汉得知他妹妹被同学欺负，立即从厨房取出菜刀，直奔她不远处的同学。不同之处在于他考虑到了结果，因为和妹妹的感情深厚，对她同学的行为无法原谅，即使自己要坐牢甚至被判死刑也要出这口气。此时一个邻居及时发现和武力制止，并费了很大功夫促成双方的和解。当事人知道自己在做什么，确定就是自己想做的，同时考虑到了结果。但是一个人可以对自己的生命负责，却无法对别人的生命负责。他对致残甚至致死对方的行为是无法负责的，邻居的行为不构成对他自由的干涉。&lt;/p&gt;
&lt;p&gt;满足所有特点。有一人经过周密考虑后决定结束自己的生命，因为他得到这一生的使命已经完成，没有更多的事情需要做了的结论。他的一个好友从多种渠道了解到这一情况后，联合他的亲人将他密切监视起来，阻止他任何的单独行动以防“不测”。当事人清楚自己在做什么，确定是自己想做的，知道结果，并且可以为结果负责。他好友和亲人的行为构成对他自由的干涉。&lt;/p&gt;
&lt;p&gt;因为以上五个例子都很典型，可能看不出什么。但简单想想平时生活中经常发生的事情，就会发现很多习以为常的行为并不是自由行为，同时很多习以为常的行为是对自由的干涉。&lt;/p&gt;
&lt;p&gt;在沙滩（应该叫雪滩了）走了走后感觉景色虽好，不宜久留，有点冻脚。回去顺道在超市买点东西，然后做饭吃饭，估计就过了中午了。吃完饭感觉没什么事情可做，感觉有点困了，先睡个午觉吧。这一睡就睡到了天黑，感觉五点多了吧。吃过晚饭，发现长夜漫漫，真正的挑战才刚刚开始。&lt;/p&gt;
&lt;p&gt;也没什么问题可想（其实有一个，后边会提），不如想想往事吧。把从记事起到现在的时间，分成数个阶段，一个个阶段回忆。想到最后，发现所有能想起的事情，基本就是反复想起的那些，没有新鲜的，其中某些还是不想回忆的那种。&lt;/p&gt;
&lt;p&gt;感觉人的记忆就像存在一大块硬盘里的数据，但这数据有一些特点。最大的特点就是不支持顺序读和随机读。我没有办法从头到尾遍历一遍，把每天吃了什么说个清楚。让我想2005年7月13日那天发生了什么，除非这个日期是事件的一部分，否则想破头也想不出来个所以然。&lt;/p&gt;
&lt;p&gt;但某些热点数据却是常驻内存的，很容易想起，甚至想忘掉都很难。那如何去想那些非热点数据呢？一个办法是顺藤摸瓜。比如我对某一件往事记忆深刻，那么我就可以仔细想它的每一个细节，而如果某一个细节正好和另一件事情有关，那么就有可能从记忆中浮现，以此类推。这也是这数据的一大特点，有一定程度的相互关联。&lt;/p&gt;
&lt;p&gt;所以像我之前那样按时间顺序想，就是在做将内存中的热点数据按时间分类的事情，自然想不出别的什么。同一天发生的两件事之前可能没什么关联，相隔十年发生的两件事却可能是一件事的两部分。不过我想了想，也没有那件事真的能让我深挖下去，就此作罢。&lt;/p&gt;
&lt;p&gt;迷迷糊糊睡了一觉，醒了看窗外和睡前一样，也不知道是几点。我突然感觉自己好像被自己的思维束缚了。我也许算是比较爱思考的人，这也确实为我解决了很多问题。但我一直没有做到的事情，就是让自己停止想任何事情，虽然很多时候我不想这么做。当没有想思考的问题时，停不下来的思维就像空转的机器一样让人难受，总想找点东西来想。平时用手机电脑上个网，总不缺可以想的东西。但切断了信息来源就不同了，思来想去也没有可供想的素材。&lt;/p&gt;
&lt;p&gt;我又想起以前看到关于静坐冥想之类的书了，以前尝试过，无一例外都失败了。感觉我就像不适合冥想的体质，我也不想强迫自己做什么。况且我感觉那些冥想所能得到的东西我通过其他方法也得到了，就没什么兴趣了。现在感觉冥想应该算是消磨时光的好办法，要是我会冥想，就算七十天也不惧吧，但这才第一天。我还记得有一种方法是把注意力集中的自己的呼吸上，我尝试了几次，感觉没什么效果。又睡着了几次，醒了几次，每次看窗外都没什么不同，不知道这一夜有多长。&lt;/p&gt;
&lt;h2&gt;27号&lt;/h2&gt;
&lt;p&gt;最后一次醒来发现天已大亮，太阳已经很高了，我还以为天蒙蒙亮就会醒呢。&lt;/p&gt;
&lt;p&gt;简单吃点东西后继续出去走走。这次想去公路走走，但走了一回感觉没意思，又绕回到海边。在秋千坐了会后，感觉有点饿了，回来吃个饭。一想今天下午不能继续睡了，不然晚上睡不着，翻来覆去的真难受。&lt;/p&gt;
&lt;p&gt;不如去逛逛商场吧。距离最近的十五分钟就到了，在一楼转了一会，感觉没有什么想买的。然后在二楼找个椅子坐会，旁边围栏上有附近幼儿园和小孩的画，多半是房子之类。其中有一幅比较另类，也比较好看，好像是万圣节的气氛，不知道画的是什么鬼。如果是原创的话，这孩子挺有天赋的。&lt;/p&gt;
&lt;p&gt;广播里唱着恭喜发财之类的歌，这些歌我好像从未听过。昏昏沉沉打了个盹，这商场是没什么可逛的。又走到海边，在长廊的椅子坐会，旁边的湖水结冰了，其实是湖面的雪化了后结冰的，不过还是挺漂亮的。回来的路上看了一眼沙滩的大钟，发现才两点半，我还以为快四点了呢。&lt;/p&gt;
&lt;p&gt;回来后继续无事可做，又有点困了，睡了一觉，这回应该不太久，醒来天还亮着。吃完饭天有些黑了，估计刚过五点。这个晚上怎么过是个问题。&lt;/p&gt;
&lt;p&gt;我最早的时候提到过我并不是真的没有问题可想了，还有一个，就是“做点什么呢”。在前一个晚上我就又仔仔细细想了一般这个问题。开始时是从五感方面，比如想吃点什么，喝点什么，看点什么，听点什么，想来想去没想到什么想做的事情。当然也包括和手机电脑网络相关的事情，那些基本也是打发时间的。然后就想和人有关的，曾经认识的，现在还联系的，想认识的，也没想出什么。天马行空地想，也还是没结果。&lt;/p&gt;
&lt;p&gt;今天晚上不知不觉又开始想这个问题，我之前已经感觉这问题没得想了，但突然我发现有一个很大的进展。如果我真的没什么事情是特别想做的话，那看起来似乎是无欲无求了，但我总感觉不对劲，又说不出来哪里不对劲。所以我就认为是某个欲望我还没有找到，于是一直尝试找到它，但又找不到。现在我突然发现这就像脑筋急转弯一样啊，我的那个没找到的欲望，不就是“我想找欲望”本身吗？骑驴找驴这样的事情，真困扰了我一些时日。一旦发现了“我想找出欲望”本身就是那个等待被找出的欲望后，这个欲望也就得到满足了。戏剧性的是再之后，我不需要再找欲望了，问题本身不再存在。自己最后一个欲望是“我要找到自己的欲望”，真是一个有趣的事情，细想却十分合理。&lt;/p&gt;
&lt;p&gt;昏昏沉沉睡了几觉，每次醒了窗外看起来都一样，不知道几点了。最后一次醒了时也是，但我突然感觉我该终止这个试验了。一看手机，才两点半多，我以为至少快四点了呢，这一夜可真够长的。&lt;/p&gt;
&lt;p&gt;虽然实验失败了，但还是有一些收获。我还是没办法做到什么都不想，姑且就认为是体质问题吧。不知道自己以后会不会再尝试呢。&lt;/p&gt;</content></entry><entry><title>这个世界之所以这样，是因为这就是多数人想要的样子</title><link href="/zhe-ge-shi-jie-zhi-suo-yi-zhe-yang-shi-yin-wei-zhe-jiu-shi-duo-shu-ren-xiang-yao-de-yang-zi.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zhe-ge-shi-jie-zhi-suo-yi-zhe-yang-shi-yin-wei-zhe-jiu-shi-duo-shu-ren-xiang-yao-de-yang-zi.html</id><summary type="html">&lt;p&gt;这个世界之所以这样，是因为这就是多数人想要的样子。&lt;/p&gt;
&lt;p&gt;忘了从什么时候有了这样的想法。一方面感觉很欣慰，另一方面感觉很无力。这似乎是两个极端，却也只是角度不同。&lt;/p&gt;
&lt;p&gt;不知道有多少人在看到街道上有人随地扔垃圾时这样想，如果人们可以更文明些，这个世界就会更美好了，没有人不希望这个世界变得更美好，那么为什么那些人一定要随地扔垃圾呢？但不知道又有多人会接着想到，自己眼中的“更美好的世界”在别人眼中可能毫无吸引力，随手扔垃圾的人在其他方面更多让世界更美好的事情。多数人都在让这个世界慢慢变成自己认为更美好的世界，只是这“美好”定义不同。&lt;/p&gt;</summary><content type="html">&lt;p&gt;这个世界之所以这样，是因为这就是多数人想要的样子。&lt;/p&gt;
&lt;p&gt;忘了从什么时候有了这样的想法。一方面感觉很欣慰，另一方面感觉很无力。这似乎是两个极端，却也只是角度不同。&lt;/p&gt;
&lt;p&gt;不知道有多少人在看到街道上有人随地扔垃圾时这样想，如果人们可以更文明些，这个世界就会更美好了，没有人不希望这个世界变得更美好，那么为什么那些人一定要随地扔垃圾呢？但不知道又有多人会接着想到，自己眼中的“更美好的世界”在别人眼中可能毫无吸引力，随手扔垃圾的人在其他方面更多让世界更美好的事情。多数人都在让这个世界慢慢变成自己认为更美好的世界，只是这“美好”定义不同。&lt;/p&gt;</content></entry><entry><title>《重新认识你自己》读书笔记第二版</title><link href="/zhong-xin-ren-shi-ni-zi-ji-du-shu-bi-ji-di-er-ban.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zhong-xin-ren-shi-ni-zi-ji-du-shu-bi-ji-di-er-ban.html</id><summary type="html">&lt;h2&gt;《重新认识你自己》读书笔记&lt;/h2&gt;
&lt;p&gt;“我”是什么，是哲学终极问题之一，我认为这也是最重要的一个。它并没有标准答案，想这个问题的目的并不是寻找一个多数人认同的的答案，而是认识自己。&lt;/p&gt;
&lt;p&gt;克里希那穆提的书/演说一向不着重宣扬自己的观点，而是让读者/听众自己思考，别人说的再正确也是别人的，唯有自己想明白的才是自己的。这本书可能是少有的例外，因为“我”的问题是一个根基，必须坚实，没有这个根基其他的都无从谈起。但即使这样，读这本书的时候还是要抱有质疑，自己思考，而不能全盘接收。&lt;/p&gt;
&lt;p&gt;“我”的问题，最著名的一句话便是笛卡尔的“我思故我在”。在这个世界我到底可以相信什么？如果我正处在一个梦境，所有看到、听到、闻到、尝到、触摸到的东西都真实存在吗？如果不能确定的话，那么在我怀疑一切的时候是否存在一种我无法怀疑的东西？我在思考，我在怀疑，不管“我”具体指的是什么，这个“我”是必须存在的。这不是一个演绎或者归纳的结果，而是一个直观的命题。你可以怀疑其他的一切，也可以有很多种 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;《重新认识你自己》读书笔记&lt;/h2&gt;
&lt;p&gt;“我”是什么，是哲学终极问题之一，我认为这也是最重要的一个。它并没有标准答案，想这个问题的目的并不是寻找一个多数人认同的的答案，而是认识自己。&lt;/p&gt;
&lt;p&gt;克里希那穆提的书/演说一向不着重宣扬自己的观点，而是让读者/听众自己思考，别人说的再正确也是别人的，唯有自己想明白的才是自己的。这本书可能是少有的例外，因为“我”的问题是一个根基，必须坚实，没有这个根基其他的都无从谈起。但即使这样，读这本书的时候还是要抱有质疑，自己思考，而不能全盘接收。&lt;/p&gt;
&lt;p&gt;“我”的问题，最著名的一句话便是笛卡尔的“我思故我在”。在这个世界我到底可以相信什么？如果我正处在一个梦境，所有看到、听到、闻到、尝到、触摸到的东西都真实存在吗？如果不能确定的话，那么在我怀疑一切的时候是否存在一种我无法怀疑的东西？我在思考，我在怀疑，不管“我”具体指的是什么，这个“我”是必须存在的。这不是一个演绎或者归纳的结果，而是一个直观的命题。你可以怀疑其他的一切，也可以有很多种“我”是什么的观点，唯一无法怀疑的是存在一个必然存在的“我”。&lt;/p&gt;
&lt;p&gt;那么这个必然存在的“我”是什么？&lt;/p&gt;
&lt;p&gt;“我”这个字我们每天都会用到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我不冷。&lt;/li&gt;
&lt;li&gt;我的身体很健康。&lt;/li&gt;
&lt;li&gt;我认为我的身体很健康。&lt;/li&gt;
&lt;li&gt;昨天我很快乐，现在我也很快乐。&lt;/li&gt;
&lt;li&gt;1 + 1 = 2。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些场景中的“我”含义并不相同。&lt;/p&gt;
&lt;p&gt;“我不冷”中的我指的是我的身体，但显然“我”不等于我的身体。当我说“我的身体”时，“我”又是指什么？身体只是这个“我”的一件物品，就像我说我的苹果时，显然不会认为苹果是我的一部分一样。于是我把“我”和“我的身体”分开，就像下边这样。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; ----    ---
|身体|   |我|
 ----    ---
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;身体所看到、听到、闻到、尝到、触摸到的东西，都是身体自己的事情，而不是“我”的，我们只需要关心身体和“我”的关系就好，暂时无需关心身体的具体功能。&lt;/p&gt;
&lt;p&gt;那么除了身体，“我”还有其他东西吗？&lt;/p&gt;
&lt;p&gt;“我认为我的身体很健康”，这里出现了两个“我”，显然这两个“我”指的不是同一件东西。“我的身体”这个“我”之前提到过，我没有给它下定义，因为当时这是我所想问题的答案。但如果“我的身体”中的我就是最终答案的话，“我认为我的身体很健康”中第一个“我”又是指什么的？&lt;/p&gt;
&lt;p&gt;这个问题看起来似乎不是那么简单，我们来换一种场景。“昨天我很快乐”和“现在我也很快乐”中的“我”是一样的吗？一个是昨天的“我”，一个是现在的“我”。看起来每个时间点都存在这样一个“我”，就像把时间看成一个数轴，每个实数都对应一个“我”一样。但显然“昨天的我”现在并不真实存在，而是只存在于现在的我的回忆中，而现在的我也一直在追着时间跑。但是麻烦来了，任何时候我想这个“我”就是现在的“我”时，时间又向前走了一小段，这个“我”就已经成为“以前的我”了。“现在的我很快乐”和“昨天的我很快乐”中的“我”并没有本质区别，都只是“以前的我”，而最新的“我”是否快乐，我是不知道的，或者我可以猜“将来的我很快乐”，然后某个时刻那个“将来的我”变成了“现在的我”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; ---  ------    ----
|我m| |我m+1|...|我n|
 ---  ------    ----

-------(时间)-------&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;已经有一些进展了。我们再回过头看“我认为我的身体很健康”。显然第二个“我”是过去某个时刻的“我”，第一个“我”也是，但要比第二个“我”更接近现在。而“认为”是“我”的一种功能。&lt;/p&gt;
&lt;p&gt;现在出现一个使继续思考下去变得更加困难的麻烦，一旦我在某一句话中提到“我”，并且这个“我”指我本人，那就只能指过去的自己，而从这个“过去的我”中，我很难得到任何关于“我”的有用的东西。&lt;/p&gt;
&lt;p&gt;那么我把“我”从句子中去掉，只留下别的，比如“1 + 1 = 2”。这和“我”有关吗？当然有关系，这个“1 + 1 = 2”显然是我写下的，同时我也认同它是对的，我们来分析这个隐藏的“我”。当我认同“1 + 1 = 2”时，脑海中并没有出现一个人（这个人和我一样大，和我穿着一样的衣服，实际上这就是过去的自己），他认同“1 + 1 = 2”。非常好，我们已经成功摆脱了“过去的我”，这个进展意义重大。&lt;/p&gt;
&lt;p&gt;当脑海中的“我”消失后，真正的“我”开始露出眉目。我们可以从“我”做的事情上来推断“我”是什么。我认同“1 + 1 = 2”，或者我认同“现在的我很快乐”，这并没有本质区别。“我”的一个功能就是认同一件事情。当我问“1 + 1 = 2吗”时，也没有区别，这和我认同“1 + 1 = 2是值得怀疑的”等价。当我做一些逻辑判断时，比如“所有正整数都大于0, 1是正整数，所以1 &amp;gt; 0”，和我认同“所有正整数都大于0”，我认同“1是正整数”，我认同“演绎法是正确的”，我认同“根据演绎法，由所有正整数都大于0, 1是正整数，可以得到1 &amp;gt; 0”，我认同“1 &amp;gt; 0”。任何思考都可以拆解成一个接着一个的认同。&lt;/p&gt;
&lt;p&gt;除了“认同”，“我”还有其他功能吗？这回我不能用句子来举例了，因为一旦陷入思考后就得不到别的东西了，必须再换个思路。比如我感觉到冷，究竟发生了什么？我的身体有感觉到冷热的功能，然后它把这种感觉传递给了“我”。“我”有感知到一种感觉的功能，这和“认同”，或者说和思考是不同的。即使当时没有思考，也会感觉到冷。同样看到的东西、闻到的东西，也是类似的，也许有些人身体功能比其他人更强大，可以感受到其他的东西，但这些东西都会传递给“我”后，对“我”来说，这些感觉之间并没有本质的不同。甚至某些感觉可能不是经由身体到达“我”的，而是通过其他的东西，但这个东西并并不属于“我”的一部分，那么对于“我”来说也并无不同。&lt;/p&gt;
&lt;p&gt;除了“感知”，“我”还有一个相关的功能。比如“我”感觉到身体冷了，然后给自己加了一件衣服。这包括三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;身体感觉到了冷，传递给“我”。&lt;/li&gt;
&lt;li&gt;“我”根据冷的信息，以及穿衣服会暖和等常识，做出需要加衣服的决定。&lt;/li&gt;
&lt;li&gt;“我”指导自己的身体穿上衣服。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第3步是一个新功能，如果把“我”和除了“我”之外的所有东西分成两个部分的话，那么“我”就只剩下了两个功能（其实这是把“我”当黑盒来思考时的起点，但我最开始没有这么思考，因为从这个起点思考更加艰难）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接收信息。&lt;/li&gt;
&lt;li&gt;输出信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但思考的功能呢？如果把“我”当黑盒来看，思考就必须在“我”的外面，这里一定出了什么问题。我已经了解到这个黑盒里边的东西了，需要把这些东西从黑盒里放出来，也就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接收信息。&lt;/li&gt;
&lt;li&gt;处理信息，也就是思考。&lt;/li&gt;
&lt;li&gt;输出信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里就必须思考“思考”本身是什么，或者“认同”本身是什么的问题了。一个异常艰难的麻烦出现了，用“思考”真的可以思考出“思考”本身是什么吗？本着不撞南墙不回头的精神，我决定再试上一试。&lt;/p&gt;
&lt;p&gt;比如我计算“1 + 1 = 2”，究竟发生了什么。1、1、2、+这些东西都是什么？我可以认同1、2这些数字是存在的，那+又是什么？简化一下，我看到了一个数字1，这时发生了什么？“我”经由身体接收到了一个数字1，这是在接收信息阶段，然后似乎没有处理和输出，就石沉大海了。看起来是这样，似乎没有任何进展。&lt;/p&gt;
&lt;p&gt;那么计算“1 + 1 = 2”呢？我接收到“1 + 1 = ”，这个是需要拆解下的。一个数字1，又一个数字1，这两个1是+的关系，我需要计算1 + 1 = 什么。拆成了4个信息。但前两个和后两个似乎不一样，一个数字1是什么意思？它的确切意思应是“存在一个数字1”&lt;/p&gt;
&lt;p&gt;我说“昨天的我”时，假想当时有一个人，那个人就是曾经的自己，但我也可以说“昨天的xx很快乐”，这个“xx”和我就没有任何关系了，可以指任何人，甚至可以是一个完全不存在的假想的人。但“xx”修改回“我”的时候，我认同了这个“xx”和我有关系，仅此而已。&lt;/p&gt;
&lt;p&gt;我不会说昨天的我就不是我了，显然我认为昨天的我和现在的我虽然所处的时间是不同的，但还是有一些东西是不变的，我要找的是最根本的那个“我”。&lt;/p&gt;</content></entry><entry><title>《重新认识你自己》读书笔记第一版</title><link href="/zhong-xin-ren-shi-ni-zi-ji-du-shu-bi-ji-di-yi-ban.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zhong-xin-ren-shi-ni-zi-ji-du-shu-bi-ji-di-yi-ban.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;克里希那穆提的书，还是非常值得一读的。这个书主题是终极问题之一——认识自己，显然这不是一个容易的问题。这本书中提到的一些理论非常重要，可以根据自己的实际情况选择性接受。&lt;/p&gt;
&lt;p&gt;因为这本书比较重要，理论相对完备，内容中的硬伤也比较少，我会比较详细地写这篇笔记。事实上这本书对我来说也比较重要。&lt;/p&gt;
&lt;h2&gt;目标读者&lt;/h2&gt;
&lt;p&gt;克里希那穆提的书普遍有一个特点，不是为了宣扬自己的观点，而是让读者自己思考解决自己的问题。这种风格的作者几乎是绝无仅有的，非常难得。而结果就是读克氏的书一般没有什么坏处，当然这也不是绝对的。读克氏的书需要有比较强的理解能力，更重要的是独立思考的能力，因为一般情况不用指望从他的书中寻找到所谓的真理，一切都需要自己想，而在阅读和思考过程中，独立思考能力会有所提升，这是非常重要的。反之，可能读后理解不了，或者没有找到自己想要的答案，而产生挫败感，或者之后很长时间不想再读克氏的书，而去走其他弯路。&lt;/p&gt;
&lt;p&gt;但这本书又有所不同，因为涉及到认识自己这个非常基本的问题，书中的观点是很明确的，这也是克氏系列书籍中比较好理解的一本。但带来的问题就是读者容易盲目接受而不自己思考，这样下来的收获是很有限的，所以需要在不同阶段仔细阅读。&lt;/p&gt;
&lt;h2&gt;第一章 没有任何向导&lt;/h2&gt;
&lt;h3&gt;生命的意义&lt;/h3&gt;
&lt;p&gt;这本书的切入点还是生命的意义。“多少世纪以来，人类就不断设法超越自己，超越物质世界的幸福。”生命到底有没有任何意义？面对并不算美好的世界 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;克里希那穆提的书，还是非常值得一读的。这个书主题是终极问题之一——认识自己，显然这不是一个容易的问题。这本书中提到的一些理论非常重要，可以根据自己的实际情况选择性接受。&lt;/p&gt;
&lt;p&gt;因为这本书比较重要，理论相对完备，内容中的硬伤也比较少，我会比较详细地写这篇笔记。事实上这本书对我来说也比较重要。&lt;/p&gt;
&lt;h2&gt;目标读者&lt;/h2&gt;
&lt;p&gt;克里希那穆提的书普遍有一个特点，不是为了宣扬自己的观点，而是让读者自己思考解决自己的问题。这种风格的作者几乎是绝无仅有的，非常难得。而结果就是读克氏的书一般没有什么坏处，当然这也不是绝对的。读克氏的书需要有比较强的理解能力，更重要的是独立思考的能力，因为一般情况不用指望从他的书中寻找到所谓的真理，一切都需要自己想，而在阅读和思考过程中，独立思考能力会有所提升，这是非常重要的。反之，可能读后理解不了，或者没有找到自己想要的答案，而产生挫败感，或者之后很长时间不想再读克氏的书，而去走其他弯路。&lt;/p&gt;
&lt;p&gt;但这本书又有所不同，因为涉及到认识自己这个非常基本的问题，书中的观点是很明确的，这也是克氏系列书籍中比较好理解的一本。但带来的问题就是读者容易盲目接受而不自己思考，这样下来的收获是很有限的，所以需要在不同阶段仔细阅读。&lt;/p&gt;
&lt;h2&gt;第一章 没有任何向导&lt;/h2&gt;
&lt;h3&gt;生命的意义&lt;/h3&gt;
&lt;p&gt;这本书的切入点还是生命的意义。“多少世纪以来，人类就不断设法超越自己，超越物质世界的幸福。”生命到底有没有任何意义？面对并不算美好的世界，我们该怎么办？所谓的人生究竟是怎么一回事？这几乎是每个人都会想到的问题。但奇怪的是，有文字记载的人类历史也有几千年了，这样重要的问题在历代人的反复思考过程中，仍没有形成一个绝大多数人都可以接受的观点。而且看了无数前人的观点后，我们真正开始自己思考这个问题时，仿佛又从零开始了，循环往复。是不是有这样的一种可能，这个问题根本没有一个确定的答案，或者至少没有一个人们能普遍接受的答案，每个人都需要寻找属于自己的答案。&lt;/p&gt;
&lt;p&gt;而作者正是引导读者走上寻找答案的道路上。&lt;/p&gt;
&lt;h3&gt;没有任何向导&lt;/h3&gt;
&lt;p&gt;这是第一章的导语：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“你不能依赖任何人，事实上并没有向导，没有老师，也没用权威，只有靠你自己——你和他人，以及你和世界的关系——除此之外，一无所有。”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是读所有书（即使是最好、最正确、最无害的书，如果有的话）或者听任何人的观点之前都需要牢记的一句话。然而真正做到并不容易，大多作者煽动性很强，自己没有一个成熟的理论体系的话，是很容易陷进去的。读书最忌讳的就是读一本书后全盘接受，然后读下一本时又全盘接受，如果存在矛盾就推翻之前所接受的，以此类推。这样不管读了多少书，最终都会一无所获，因为东西始终是别人的，记住多少都没有变成自己的东西。&lt;/p&gt;
&lt;p&gt;正确的方法是形成自己的理论体系，然后不管读什么书都抱着怀疑精神，接受自己认为合理的，补充到自己的理论体系中，并做适当的融合（这个理论体系里真正重要的东西往往不是某本书上的具体内容，而是自己思考得到的，或者融合了很多书中的不同观点所得到的），拒绝自己所不认同的。但这样有个前提，就是自己的理论体系需要已经具有一定的规模，而且至少不能过于离谱，显然靠空想是很难形成的。所以最开始读的书至关重要，它们的内容几乎被全部放入到自己的理论体系中，一旦书没挑好，后续就非常麻烦了。而且这些书很可能在自己小时候就已经看过了，并且形成了根深蒂固的观点，而因为这些观点，自己很难接受另一些明显不同的书。&lt;/p&gt;
&lt;p&gt;所以看起来容易，真做到还是非常难的，而且在做到之前，读很多书都是比较危险的（真正重要的书恰恰包含在内，有些人可能不理解，两本书的主要观点完全相悖，却可能都是值得一读的好书，而随便全盘接受其中一本都会有灾难性的影响，这种情况非常普遍）。&lt;/p&gt;
&lt;h2&gt;第二章 认识自我&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2&gt;第三章 觉察力&lt;/h2&gt;
&lt;h2&gt;第四章 什么是快感&lt;/h2&gt;
&lt;h2&gt;TODO&lt;/h2&gt;</content></entry><entry><title>专业思考人生问题十余年，我依然在路上</title><link href="/zhuan-ye-si-kao-ren-sheng-wen-ti-shi-yu-nian-wo-yi-ran-zai-lu-shang.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zhuan-ye-si-kao-ren-sheng-wen-ti-shi-yu-nian-wo-yi-ran-zai-lu-shang.html</id><summary type="html">&lt;p&gt;说来可笑，被别人问到有什么兴趣爱好时，我总是不知道怎么回答。有时我说喜欢看书，但我知道我看书基本都是带着目的的，为了寻找答案，而不是享受看书的过程。而除了偶尔看书，我便找不到什么值得一提的兴趣爱好了，甚至听歌上网等对我来说也只是一个打发时间的手段。&lt;/p&gt;
&lt;p&gt;今天我突然发现了一个看似兴趣爱好的事情，想问题，而且是专门思考人生相关问题。可能会有很多人想，你才二十多岁，也没经历过什么值得一提的事情，又能想出什么，不过是胡思乱想罢了。说得确实有道理，但如果真正喜欢做一个事情，会关注结果吗？我是不是应该因为发现自己的兴趣爱好而高兴呢？&lt;/p&gt;
&lt;p&gt;不过玩笑归玩笑，人生问题还是需要严谨对待的。我已经很久没有写过相关文章了，因为所谓的大道理很多人都清楚，但真正活得幸福不是知道什么道理就可以做到的，变成纸上谈兵就会很无趣。在这一点，我自己就吃过不少亏。我经常会在某个时候突然“想通”了某个问题，然后高兴地认为自己好像是拿到了某个大门的钥匙，从此生活就大不同了，但总会有新的问题等着我，也许这一次也不例外吧。&lt;/p&gt;
&lt;p&gt;这并不是一个新鲜的观点，甚至是某些宗教的教义。&lt;/p&gt;
&lt;p&gt;人生的目的虽然因人而异，但并不是无迹可寻，概况起来是这样的：学习爱。&lt;/p&gt;</summary><content type="html">&lt;p&gt;说来可笑，被别人问到有什么兴趣爱好时，我总是不知道怎么回答。有时我说喜欢看书，但我知道我看书基本都是带着目的的，为了寻找答案，而不是享受看书的过程。而除了偶尔看书，我便找不到什么值得一提的兴趣爱好了，甚至听歌上网等对我来说也只是一个打发时间的手段。&lt;/p&gt;
&lt;p&gt;今天我突然发现了一个看似兴趣爱好的事情，想问题，而且是专门思考人生相关问题。可能会有很多人想，你才二十多岁，也没经历过什么值得一提的事情，又能想出什么，不过是胡思乱想罢了。说得确实有道理，但如果真正喜欢做一个事情，会关注结果吗？我是不是应该因为发现自己的兴趣爱好而高兴呢？&lt;/p&gt;
&lt;p&gt;不过玩笑归玩笑，人生问题还是需要严谨对待的。我已经很久没有写过相关文章了，因为所谓的大道理很多人都清楚，但真正活得幸福不是知道什么道理就可以做到的，变成纸上谈兵就会很无趣。在这一点，我自己就吃过不少亏。我经常会在某个时候突然“想通”了某个问题，然后高兴地认为自己好像是拿到了某个大门的钥匙，从此生活就大不同了，但总会有新的问题等着我，也许这一次也不例外吧。&lt;/p&gt;
&lt;p&gt;这并不是一个新鲜的观点，甚至是某些宗教的教义。&lt;/p&gt;
&lt;p&gt;人生的目的虽然因人而异，但并不是无迹可寻，概况起来是这样的：学习爱。&lt;/p&gt;</content></entry><entry><title>自我的思考</title><link href="/zi-wo-de-si-kao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zi-wo-de-si-kao.html</id><summary type="html">&lt;p&gt;“我”是什么？这是哲学上一个很重要却又几乎无解的问题。然而要通俗而又深入地展示问题所在也并不容易。&lt;/p&gt;
&lt;p&gt;想象这样一个场景，你面前摆放着一个可以自动旋转的桌子，桌子上放着一杯水，杯子随着桌子一起旋转。但桌子外罩着一个无顶的圆筒，你只能看到旋转的杯子，而看不到桌子。于是你很好奇，不清楚杯子为什么会转。然后你用手握住杯子，虽然杯子和桌面有摩擦力，但你的力量还是能使杯子停止下来。你放开手，杯子又恢复转动了。那么，你会认为杯子转动与否全凭你控制吗？&lt;/p&gt;
&lt;p&gt;我想大部分人不会，虽然可能不清楚杯子下边的是桌子，也能大概猜到是一个会转的机器。但你能影响杯子的转动是毋需置疑的，而且这不是什么神秘力量，服从最基本的物理定律。你更不会认为旋转的杯子是你的一部分。&lt;/p&gt;
&lt;p&gt;那么让我们的视线暂时远离那个桌子，注意自己的鼻子。自己每时每刻都在呼吸，但只有你把注意力放在自己的鼻子上，才会感受到呼吸间鼻子的动作。你可以控制自己鼻子，让呼吸暂停，也可以让他恢复。但即使你睡着了，呼吸也不会暂停。&lt;/p&gt;
&lt;p&gt;那么问题来了，你的鼻子是不是和那个转动的杯子有相似之处？它背后也是由一个机器控制，可以自动运转，但你也可以干预。你可能不清楚呼吸的确切原因，但你知道一定有一个类似机器的东西在控制它，而你对这个机器了解并不多。那你会认为鼻子是你的一部分吗？&lt;/p&gt;
&lt;p&gt;我想多数人认为是的，鼻子当然是我们的一部分。但如果它是由一个我们根本不清楚细节的机器（比如脑干 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;“我”是什么？这是哲学上一个很重要却又几乎无解的问题。然而要通俗而又深入地展示问题所在也并不容易。&lt;/p&gt;
&lt;p&gt;想象这样一个场景，你面前摆放着一个可以自动旋转的桌子，桌子上放着一杯水，杯子随着桌子一起旋转。但桌子外罩着一个无顶的圆筒，你只能看到旋转的杯子，而看不到桌子。于是你很好奇，不清楚杯子为什么会转。然后你用手握住杯子，虽然杯子和桌面有摩擦力，但你的力量还是能使杯子停止下来。你放开手，杯子又恢复转动了。那么，你会认为杯子转动与否全凭你控制吗？&lt;/p&gt;
&lt;p&gt;我想大部分人不会，虽然可能不清楚杯子下边的是桌子，也能大概猜到是一个会转的机器。但你能影响杯子的转动是毋需置疑的，而且这不是什么神秘力量，服从最基本的物理定律。你更不会认为旋转的杯子是你的一部分。&lt;/p&gt;
&lt;p&gt;那么让我们的视线暂时远离那个桌子，注意自己的鼻子。自己每时每刻都在呼吸，但只有你把注意力放在自己的鼻子上，才会感受到呼吸间鼻子的动作。你可以控制自己鼻子，让呼吸暂停，也可以让他恢复。但即使你睡着了，呼吸也不会暂停。&lt;/p&gt;
&lt;p&gt;那么问题来了，你的鼻子是不是和那个转动的杯子有相似之处？它背后也是由一个机器控制，可以自动运转，但你也可以干预。你可能不清楚呼吸的确切原因，但你知道一定有一个类似机器的东西在控制它，而你对这个机器了解并不多。那你会认为鼻子是你的一部分吗？&lt;/p&gt;
&lt;p&gt;我想多数人认为是的，鼻子当然是我们的一部分。但如果它是由一个我们根本不清楚细节的机器（比如脑干）驱动，我们有什么理由认为它就是我们的一部分呢，仅仅是一厢情愿吗？&lt;/p&gt;
&lt;p&gt;再比如思想，比如我们想回忆昨天发生的事情，就可以想到；想一道数学题，也没问题。但如果你想安安静静10分钟什么都不想，多半就会出现问题。一个个念头不断涌现出来，那些都不是你自己真正要想的，你甚至不清楚它们是从哪里来的。你还认为你的思想完全由你自己控制吗？&lt;/p&gt;
&lt;p&gt;思想和那个旋转的杯子没有太多不同，你可以干预它，但它却不是完全受你控制。它和那个杯子一样，背后有一个机器在运作，而你对这个机器的实现细节知之甚少。如果杯子所在的桌子上有一个按钮，你一按下它就停止转动，你就可以让杯子一直属于停止状态，但这不意味着你就完全控制了那个杯子了，你对桌子的细节还是不清楚（或许有很多其他按钮可以对桌子旋转的参数进行各种控制，而你都没有发现）。思想也是一样，你还是有办法让自己不再思考任何东西，就像发现并按下了控制思想的那个开关，虽然比较困难。但即使这样，你还是不能说你就是完全掌控思维了，你对那个机器实现细节的了解程度并没有加深。&lt;/p&gt;
&lt;p&gt;如果我们认同思维并不是由我们自身全权掌控的，而是由背后的一个机器运作，我们认为自己在控制思维，实际却只是在干预那个机器。甚至当我们停止干预时，思维还在很好的运作（这很常见）。那么还剩什么东西真正是我的组成部分？或者说“我”指代的是怎样一种东西？&lt;/p&gt;
&lt;p&gt;对“我”的进一步思考则会进入“身心”关系的根本性哲学问题，从而难以得到任何确切性结论（一般可分为唯物论、唯心论和二元论三类，然而问题不在于哪一种正确，而在于各种理论都没有解释清楚“身心”关系，或者试图绕过甚至拒绝承认“身心”关系存在问题）。事实上，到此为止我们就可以发现我们对生活的某些固有看法存在问题。&lt;/p&gt;
&lt;p&gt;再回头看之前的那个旋转的杯子。一般情况我们可能只是看这个杯子会转动比较好奇，但也会有些人不喜欢转动的杯子（或许因为它在动而心烦意乱，或者他认为旋转速度不够快，或者认为它应该逆时针旋转而不是顺时针），于是用手紧握使它静止下来（或者让它转动更快，或者反方向转），这是显然是需要消耗精力的。如果在他面前又出现了另一个旋转的杯子，于是他用另一只手握住。麻烦的是又出现了第三个，他发现自己只有两只手，却需要让三个杯子停止转动，于是开始手忙脚乱，但不管怎么努力，总有一个杯子继续旋转，于是他感到很强的挫败感。&lt;/p&gt;
&lt;p&gt;可是现实中会有那样愚蠢的人吗？如果只是旋转的杯子，那大概没有。但和这些杯子类似的东西有很多，比如你的银行账户，你的工作，你的住所，你的交通工具，你的朋友，你的家人，你的身体，你的思维，所有你认为是你的东西，都和那个旋转的杯子并无明显不同。于是你看着摆在眼前无穷无尽的旋转的杯子有点手足无措，因为你的精力有限，不可能全照顾到，只能握住那些你认为最重要的杯子，然而这样也会因为照顾不到的那些杯子而感到挫败感。或许你看到旁边的人耍杯子的技巧更高超而心生羡慕。&lt;/p&gt;
&lt;p&gt;慢慢得其中一些人开始发现事情的诡异之处，我们为什么非要费劲干预那些杯子的转动，如果放开双手让它们自由转动呢？&lt;/p&gt;
&lt;p&gt;这样的结果可能是看着杯子不按照自己的心意转动而感觉非常不适。对应的实际情况就是没有足够的钱花、工作没有着落、没有稳定住所、没有自己的交通工具、没有真正的朋友、和家人不和睦、身体状态不佳、思维充满混乱等等。注意这是最坏的情况。&lt;/p&gt;
&lt;p&gt;但真的是如此的结果吗？我们之前已经知道如果你不干预呼吸，呼吸也是会正常工作的。当你不去强迫想自己想不喜欢的问题，大脑会变得轻松；当你不去强迫自己为了其他的东西牺牲身体，身体会更加健康；当你不会因为试图说服家人而争吵，关系会更加和睦；当你不再努力维持和朋友之间的利益关系，朋友会更加纯粹；没有自己的交通工具后，不再需要再向其中投入金钱和精力；没有稳定的住所后，反而更加自在；没有稳定工作后，反而更加自由；没有足够的钱后，前边的那些如何得以维持？&lt;/p&gt;
&lt;p&gt;很多人这样思考后，发现金钱的问题无法绕过，金钱就像一个大号的旋转杯子摆在每个人的面前，几乎每个人都认为这个杯子只有在自己的干预下才能良好运转，否则自己就会沦为乞丐，甚至冻饿而死。很多书籍面临着同样的问题，一旦遇到金钱问题，前边的努力全部化作泡影。&lt;/p&gt;
&lt;p&gt;一个人若没有经历真正的绝望，是不情愿再深入思考下去的。我曾经疑惑为何所谓看透人生的人几乎都经历过这样那样的苦难。直到我发现，思考自我本身就是一个异常痛苦的过程，人们对痛苦往往敬而远之，少有人忍着痛苦深入思考。一个人若处于外在的深刻苦难中，如果他没有被打败，便很容易了解痛苦的本质，这样痛苦便不再是痛苦，从而思考自我变得不再艰难。而如果有人在没有经历外部苦难的前提下思考这个问题，那思考本身就会成为一个苦难，甚至可能比外部的苦难还要剧烈。思考自我的问题并不有趣，它是把所谓的“自我”一点点撕碎的过程，那些被撕掉的都不是自我，而是像那些摆在面前的杯子一样的外在东西。&lt;/p&gt;
&lt;p&gt;如果一个人从出生起就从未接受过“自我”的概念，那他是异常幸运的。而我们其余的大多数，都在潜移默化中接受了“自我”的概念，相信摆在自己面前的杯子都是自己的一部分，或者是自己所掌控的，或者是自己不得不干预的。而只有说服自己认同那些都不是“自我”，那些都不再重要，剩下的东西才是真正的自我。&lt;/p&gt;
&lt;p&gt;如何思考自我？或者接受思考过程带来的所有苦难，或者直接放弃。&lt;/p&gt;</content></entry><entry><title>Zookeeper 和 etcd 使用场景</title><link href="/zookeeper-he-etcd-shi-yong-chang-jing.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zookeeper-he-etcd-shi-yong-chang-jing.html</id><summary type="html">&lt;h3&gt;1、Zookeeper和etcd共同点&lt;/h3&gt;
&lt;p&gt;Zookeeper和etcd的功能和使用场景都很类似。&lt;/p&gt;
&lt;h3&gt;2、Zookeeper选主方法&lt;/h3&gt;
&lt;h4&gt;Paxos &amp;amp; fast paxos&lt;/h4&gt;
&lt;p&gt;参考 &lt;a href="http://blog.csdn.net/xhh198781/article/details/10949697"&gt;Paxos算法与Zookeeper分析&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、Zookeeper复制数据方法&lt;/h3&gt;
&lt;h4&gt;Zab&lt;/h4&gt;
&lt;p&gt;Zab协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在leader崩溃后，Zab就进入了恢复模式，当leader被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和follower具有相同的系统状态。&lt;/p&gt;
&lt;h5&gt;广播模式&lt;/h5&gt;
&lt;p&gt;Leader向follower发送请求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leader向follower依次发送prepare请求，并等待回应，半数以上回复即prepare成功。&lt;/li&gt;
&lt;li&gt;Leader按相同顺序依次发送commit请求，并等待回应，半数以上回复即commit成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果client连上的是follower，写请求会转发给leader处理，读请求如果要读到最新数据也需要转发给leader，如果不需要可以直接在follower中读取。&lt;/p&gt;
&lt;h5&gt;恢复模式&lt;/h5&gt;
&lt;p&gt;这种情况主要解决的是新老交互的问题，即新leader是否需要继续老leader未完成的状态。&lt;/p&gt;
&lt;p&gt;这里要看老leader挂掉时的情况：
1. 多数follower还没有收到老leader的commit。
2. 多数follower已经收到老leader的commit，并且操作完成。&lt;/p&gt;
&lt;p&gt;第一种情况，因为多数follower还没有commit，该commit失败。完成commit的server需要在新leader选出后将该commit回滚。&lt;/p&gt;
&lt;p&gt;第二种情况 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;1、Zookeeper和etcd共同点&lt;/h3&gt;
&lt;p&gt;Zookeeper和etcd的功能和使用场景都很类似。&lt;/p&gt;
&lt;h3&gt;2、Zookeeper选主方法&lt;/h3&gt;
&lt;h4&gt;Paxos &amp;amp; fast paxos&lt;/h4&gt;
&lt;p&gt;参考 &lt;a href="http://blog.csdn.net/xhh198781/article/details/10949697"&gt;Paxos算法与Zookeeper分析&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、Zookeeper复制数据方法&lt;/h3&gt;
&lt;h4&gt;Zab&lt;/h4&gt;
&lt;p&gt;Zab协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在leader崩溃后，Zab就进入了恢复模式，当leader被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和follower具有相同的系统状态。&lt;/p&gt;
&lt;h5&gt;广播模式&lt;/h5&gt;
&lt;p&gt;Leader向follower发送请求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leader向follower依次发送prepare请求，并等待回应，半数以上回复即prepare成功。&lt;/li&gt;
&lt;li&gt;Leader按相同顺序依次发送commit请求，并等待回应，半数以上回复即commit成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果client连上的是follower，写请求会转发给leader处理，读请求如果要读到最新数据也需要转发给leader，如果不需要可以直接在follower中读取。&lt;/p&gt;
&lt;h5&gt;恢复模式&lt;/h5&gt;
&lt;p&gt;这种情况主要解决的是新老交互的问题，即新leader是否需要继续老leader未完成的状态。&lt;/p&gt;
&lt;p&gt;这里要看老leader挂掉时的情况：
1. 多数follower还没有收到老leader的commit。
2. 多数follower已经收到老leader的commit，并且操作完成。&lt;/p&gt;
&lt;p&gt;第一种情况，因为多数follower还没有commit，该commit失败。完成commit的server需要在新leader选出后将该commit回滚。&lt;/p&gt;
&lt;p&gt;第二种情况，新leader通过一个多数派获得老leader提交的最新数据，老leader重启后，可能还会认为自己是leader，可能会继续发送未完成的请求，从而因为两个leader同时存在导致算法过程失败，解决办法是把leader信息加入每条消息的id中，Zookeeper中称为zxid，zxid为一64位数字，高32位为leader信息又称为epoch，每次leader转换时递增；低32位为消息编号，leader转换时应该从0重新开始编号。通过zxid，follower能很容易发现请求是否来自老leader，从而拒绝老leader的请求。新leader首先要获得大多数节点的支持，然后从状态最新的节点同步事务（如何同步见下文），完成后才可正式成为leader发起事务。&lt;/p&gt;
&lt;p&gt;选出新leader以后，zookeeper就进入状态同步过程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leader等待server连接；&lt;/li&gt;
&lt;li&gt;Follower连接leader，将最大的zxid发送给leader；&lt;/li&gt;
&lt;li&gt;Leader根据follower的zxid确定同步点（需要多数派都在这种状态或更新状态）&lt;/li&gt;
&lt;li&gt;完成同步后通知follower已经成为uptodate状态；&lt;/li&gt;
&lt;li&gt;Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;4、Etcd选主方法&lt;/h3&gt;
&lt;p&gt;Raftppt-understandable-cons-protocol.pdf&lt;/p&gt;
&lt;h3&gt;5、Etcd复制数据方法&lt;/h3&gt;
&lt;p&gt;Raftppt-understandable-cons-protocol.pdf&lt;/p&gt;
&lt;h3&gt;6、Zookeeper常见使用场景&lt;/h3&gt;
&lt;h4&gt;配置管理、数据分发与订阅&lt;/h4&gt;
&lt;p&gt;管理配置是zookeeper最常见的应用场景。比如一个服务的多个实例部署在不同机器上，如果使用本地配置文件，修改、实例迁移等操作都比较麻烦，可以把配置存放到zookeeper的某个路径下。每个实例启动后都去zookeeper读取配置，如果需要追踪配置的更新，可以监视节点的变更。&lt;/p&gt;
&lt;p&gt;这个配置不局限为服务运行所需要的配置信息，符合分发、订阅方法使用的数据都可，也可以指不同服务实例运行时的中间状态（对应单机进程使用的内存中状态数据或者状态文件），这样各个实例可以实现为无状态的，一旦实例挂掉不会丢失数据，方便服务迁移（具体迁移方式参考集群管理部分）。&lt;/p&gt;
&lt;h4&gt;集群管理与Master选举&lt;/h4&gt;
&lt;h5&gt;集群机器监控&lt;/h5&gt;
&lt;p&gt;这通常用于那种对集群中机器状态，机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。这样的场景中，往往有一个监控系统，实时检测集群机器是否存活。&lt;/p&gt;
&lt;p&gt;利用ZooKeeper可以实现一种集群机器存活性监控系统：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个机器在/Machines/下创建一个临时节点（如/Machines/${hostname}，可以把具体的状态作为节点内容）。&lt;/li&gt;
&lt;li&gt;服务端监视/Machines/下节点的变动，来判断机器是否存活以及具体状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;Master选举&lt;/h5&gt;
&lt;p&gt;在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行master选举。&lt;/p&gt;
&lt;p&gt;利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 /currentMaster 节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选举了。&lt;/p&gt;
&lt;p&gt;此外，也可以利用Zookeeper的EPHEMERAL_SEQUENTIAL节点，实现动态选举：每个客户端都在/Master/下创建一个EPHEMERAL_SEQUENTIAL节点,由于ZooKeeper保证SEQUENTIAL的有序性，因此我们可以简单的把节点号最小的作为Master，就完成了选主。&lt;/p&gt;
&lt;h4&gt;分布式锁&lt;/h4&gt;
&lt;h5&gt;屏障&lt;/h5&gt;
&lt;p&gt;似乎不是很常用，参考官方文档（http://zookeeper.apache.org/doc/r3.4.6/recipes.html#sc_recipes_eventHandles）&lt;/p&gt;
&lt;h5&gt;独占锁&lt;/h5&gt;
&lt;p&gt;获取锁时如果不需要等待（只使用try_lock()、unlock()，不使用lock()），可以直接以一个节点（如/Lock，事先不存在）作为锁，试图获取这个锁的客户端直接创建这个节点，只有一个可以成功，使用完了则删除这个节点（或者使用临时节点，关闭会话）。如果需要等待，参考控制时序的锁。&lt;/p&gt;
&lt;h5&gt;控制时序的锁&lt;/h5&gt;
&lt;p&gt;就是所有试图来获取这个锁的客户端，最终都会获得（除非有人一直不释放），只是有个全局时序。&lt;/p&gt;
&lt;p&gt;预先创建/Lock/，客户端在它下面创建临时有序节点lock-（Zk的父节点维持一份子节点创建的时序），然后获取/Lock/下的子节点（设置监视标志），直到自己拥有的是最小的序号则获得锁，释放时只需要删除该节点。&lt;/p&gt;
&lt;p&gt;如果每个客户端都不可撤销锁（包括设置获取锁的超时时间），也可以改成这样。预先创建/Lock/，客户端在它下面创建有序节点lock-（非临时，否则某还没得到锁的客户端会话意外关闭后，会使得下一个客户端获得锁，导致混乱），然后获取/Lock/下的子节点（不设置监视标志），如果自己拥有的是最小的序号则获得锁，否则只监视比自己小的最大子节点，直到该节点被删除后获得锁，释放时删除自己的节点。和前一种方法相比，每次锁被释放时只有下一个获取该锁的客户端被唤醒。&lt;/p&gt;
&lt;h5&gt;共享锁（读写锁）&lt;/h5&gt;
&lt;p&gt;获取读锁过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在/Lock/（/Lock/是预先创建的）下创建有序节点read-。&lt;/li&gt;
&lt;li&gt;获得/Lock/下的子节点（不设置监视标志）。&lt;/li&gt;
&lt;li&gt;如果没有以write-开头并且比自己小（一个目录里的序号是统一的，不区分节点名）的节点，则获得了读锁。&lt;/li&gt;
&lt;li&gt;否则监视这个以write-开头并且比自己小的节点，直到这个节点被删除了，返回2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;获取写锁的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在/Lock/下创建有序节点write-。&lt;/li&gt;
&lt;li&gt;获得/Lock/下的子节点（不设置监视标志）。&lt;/li&gt;
&lt;li&gt;如果没有比自己小的节点，则获得了写锁。&lt;/li&gt;
&lt;li&gt;否则监视这个以比自己小的节点，直到这个节点被删除了，返回2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但前提是每个客户端都不可撤销锁（包括设置获取锁的超时时间），否则请参考&lt;a href="http://zookeeper.apache.org/doc/r3.4.6/recipes.html#Shared+Locks"&gt;Shared+Locks&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;名字服务&lt;/h4&gt;
&lt;p&gt;这个主要是作为分布式命名服务，通过调用zk的create node api，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。&lt;/p&gt;
&lt;p&gt;命名服务是指通过指定的名字来获取资源或者服务的地址，提供者的信息。利用Zookeeper很容易创建一个全局的路径，而这个路径就可以作为一个名字，它可以指向集群中的集群，提供的服务的地址，远程对象等。简单来说使用Zookeeper做命名服务就是用路径作为名字，路径上的数据就是其名字指向的实体。&lt;/p&gt;
&lt;p&gt;服务提供者在启动的时候，向ZK上的指定节点（如/${serviceName}/providers）目录下写入自己的URL地址，这个操作就完成了服务的发布。
服务消费者启动的时候，订阅/${serviceName}/providers/目录下的提供者URL地址（如果一次性使用直接读取即可），并向/${serviceName}/consumers/目录下写入自己的URL地址（如果服务提供者者需要通过ZK获取服务消费者身份，可选）。
所有向ZK上注册的地址都是临时节点，这样就能够保证服务提供者和消费者能够自动感应资源的变化。&lt;/p&gt;
&lt;p&gt;典型例子（参考http://blog.csdn.net/qq910894904/article/details/40833859，省略其中的服务监控者）：
nameservice：
    -m 程序运行的方式，指定是服务提供者provider还是服务消费者consumer
    -n 服务名称
    -s Zookeeper的服务地址IP:PORT&lt;/p&gt;
&lt;p&gt;服务提供者：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nameservice -m provider -n ServiceDemo -s 172.17.0.36:2181&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;服务消费者：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nameservice -m consumer -n ServiceDemo -s 172.17.0.36:2181&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一条命令启动服务提供者，它提供一个ServiceDemo的服务，首次启动后会创建/NameService/、/NameService/ServiceDemo/、/NameService/ServiceDemo/provider/几个路径（永久节点）。然后在服务提供进程在/NameService/ServiceDemo/provider/下创建临时序列节点。&lt;/p&gt;
&lt;p&gt;第二条命令启动一个服务消费进程,它在/NameService/ServiceDemo/consumer/下创建临时序列节点，并watch /NameService/ServiceDemo/provider/下的子节点变化事件，及时更新provider列表。&lt;/p&gt;
&lt;h4&gt;分布式通知/协调&lt;/h4&gt;
&lt;p&gt;通知的典型实现方式是被通知方监听一个端口，等待通知方往端口发送消息。双方耦合比较严重，如果双方需要互相通知，有多个通知方和被通知方自己交互则逻辑复杂、难于实现。&lt;/p&gt;
&lt;p&gt;典型的通知就是被通知方监视一个节点，通知方修改或者删除这个节点。&lt;/p&gt;
&lt;h4&gt;分布式队列&lt;/h4&gt;
&lt;h5&gt;队列&lt;/h5&gt;
&lt;p&gt;预先创建/Queue/。&lt;/p&gt;
&lt;p&gt;push：创建一个有序的/Queue/queue-节点。
pop：取出/Queue/下序列号最小的节点（先获取到所有节点，然后删除序号最小的节点表示取出，如果删除之前节点已经被别人删了也没事，直接跳过。也可以获取所有节点是设置监视标志，这样可以及时处理新添加的节点）。&lt;/p&gt;
&lt;p&gt;zookeeeper源码的recipes/queue目录有示例。&lt;/p&gt;
&lt;h5&gt;优先队列&lt;/h5&gt;
&lt;p&gt;在上边普通队列的基础上作2个小改动即可实现优先队列。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;push时，创建以queue-x-的节点，x是代表优先级的数字。&lt;/li&gt;
&lt;li&gt;pop时，取出x最小的节点，而不是序列号最小的节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;7、Etcd常见使用场景&lt;/h3&gt;
&lt;p&gt;Etcd和zookeeper的使用场景大致相同，主要不同在于接口和部分周边功能上。&lt;/p&gt;
&lt;h3&gt;8、Zookeeper和etcd使用场景比较&lt;/h3&gt;
&lt;p&gt;Etcd支持更方便的HTTP API，多语言支持比zookeeper也要好一些。&lt;/p&gt;
&lt;p&gt;Etcd没有acl权限控制。&lt;/p&gt;
&lt;p&gt;性能上，需要自己根据使用场景做测试。&lt;/p&gt;
&lt;h3&gt;9、参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/linhaohong/archive/2012/11/26/2789394.html"&gt;Chubby 和Zookeeper 的理解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/qq910894904/article/details/40835105"&gt;ZooKeeper场景实践系列&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.coder4.com/archives/3856"&gt;ZooKeeper典型应用场景一览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/haippy/archive/2012/07/23/2603583.html"&gt;Zookeeper 进阶之——典型应用场景（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/haippy/archive/2012/07/23/2604556.html"&gt;Zookeeper 进阶之——典型应用场景（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://zookeeper.apache.org/doc/r3.4.6/recipes.html"&gt;ZooKeeper Recipes and Solutions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/xinguan1267/article/details/38422149"&gt;ZooKeeper原理及使用 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.kuqin.com/system-analysis/20111120/315148.html"&gt;ZooKeeper典型使用场景一览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/"&gt;分布式服务框架 Zookeeper -- 管理分布式环境中的数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Zab+vs.+Paxos"&gt;Zab vs. Paxos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/xhh198781/article/details/10949697"&gt;Paxos算法与Zookeeper分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>最后的难题——关于执着</title><link href="/zui-hou-de-nan-ti-guan-yu-zhi-zhao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zui-hou-de-nan-ti-guan-yu-zhi-zhao.html</id><summary type="html">&lt;p&gt;执着是一个很重要的主题，它曾经很让我困扰，现在我依然没有克服。我认为它是最后的难题，但也并不是说它是唯一的难题，为了解决它，我或许需要走更多弯路。&lt;/p&gt;
&lt;p&gt;我一直发现我的生活呈现某种有规律的反复。在某一段时间，我可能会感觉非常好，似乎没有任何问题了，但这样的状态并不能维持下去，然后我可能陷入某种低谷，一些很困扰我的问题再次出现，再过一段时间可能又再次消失。因为我并没有真正解决这些问题，而这问题就是执着。&lt;/p&gt;
&lt;p&gt;对生死的执着应该是其中最明显的一个。当我对生或死有比较明显的偏好，并且我不能真正控制自己的生死时，这就很容易给自己带来痛苦。我至今不清楚这个问题如何化解。我知道理想的情况是不执着于生死，也就是说也许自己能活一百多年，也许下一秒就死去，更可能再活上几十年，但自己对这三者都没有特别的偏好。但解决这个问题并不是想想就可以的，我也没有找到可行的方法。&lt;/p&gt;
&lt;p&gt;执着其实是一种控制欲，我执着于一件事物意味着我试图控制它。任何东西都无法完全控制另一件东西，而如果只涉及一件东西，就不需要用控制二字。所以控制是双向的，我控制它的同时它也在控制我，这是我较早之前认同的观点。所以我让自己的生活尽量简单，直到我对身外之物的控制欲比较少了。但再继续下去会遇到问题，比如对身体的控制，对生死的控制，是我不愿意放弃的。但我也知道我并不能完全控制它们，所以一旦我想控制它们，我就已经比较被动了。&lt;/p&gt;
&lt;p&gt;控制欲的产生在于认同。如果我认为一块石头和我没有任何关系，我不会想控制它。但我认为身体对我来说是很重要的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;执着是一个很重要的主题，它曾经很让我困扰，现在我依然没有克服。我认为它是最后的难题，但也并不是说它是唯一的难题，为了解决它，我或许需要走更多弯路。&lt;/p&gt;
&lt;p&gt;我一直发现我的生活呈现某种有规律的反复。在某一段时间，我可能会感觉非常好，似乎没有任何问题了，但这样的状态并不能维持下去，然后我可能陷入某种低谷，一些很困扰我的问题再次出现，再过一段时间可能又再次消失。因为我并没有真正解决这些问题，而这问题就是执着。&lt;/p&gt;
&lt;p&gt;对生死的执着应该是其中最明显的一个。当我对生或死有比较明显的偏好，并且我不能真正控制自己的生死时，这就很容易给自己带来痛苦。我至今不清楚这个问题如何化解。我知道理想的情况是不执着于生死，也就是说也许自己能活一百多年，也许下一秒就死去，更可能再活上几十年，但自己对这三者都没有特别的偏好。但解决这个问题并不是想想就可以的，我也没有找到可行的方法。&lt;/p&gt;
&lt;p&gt;执着其实是一种控制欲，我执着于一件事物意味着我试图控制它。任何东西都无法完全控制另一件东西，而如果只涉及一件东西，就不需要用控制二字。所以控制是双向的，我控制它的同时它也在控制我，这是我较早之前认同的观点。所以我让自己的生活尽量简单，直到我对身外之物的控制欲比较少了。但再继续下去会遇到问题，比如对身体的控制，对生死的控制，是我不愿意放弃的。但我也知道我并不能完全控制它们，所以一旦我想控制它们，我就已经比较被动了。&lt;/p&gt;
&lt;p&gt;控制欲的产生在于认同。如果我认为一块石头和我没有任何关系，我不会想控制它。但我认为身体对我来说是很重要的，甚至是我的一部分，使我很难不想控制它。这问题的突破口似乎是认识到并认同自己的真实身份，然后身体的重要性会降低，如果能降低到和一块和自己无关的石头那样，自己就不会再想控制它了。但认同并不只是理想的认识，更多是感性方面。这样还是无解的。&lt;/p&gt;
&lt;p&gt;执着的问题难解，因为它和通常的问题不一样。执着于解决执着的问题本身就是一种执着，仅这一点就让很多方法没有用武之地。这个问题的解决方法似乎是让问题自己淡化直到消失，那怎样的方法能促进这个过程呢。我还是想不到什么切实可行的办法。&lt;/p&gt;</content></entry><entry><title>最可怕的并不是强人工智能</title><link href="/zui-ke-pa-de-bing-bu-shi-qiang-ren-gong-zhi-neng.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zui-ke-pa-de-bing-bu-shi-qiang-ren-gong-zhi-neng.html</id><summary type="html">&lt;p&gt;关于人工智能，一个广为流传的说法是：“弱人工智能并不可怕，强人工智能才是可怕的。而至少目前看来强人工智能是遥遥无期的，所以现在就担心人工智能的危害还为时尚早。”之前我也有类似的想法，虽然我并不认为弱人工智能就完全没有危害，但基本处于可控的范围内，至少不比核武器或者病毒之类更危险些。&lt;/p&gt;
&lt;p&gt;这两天我闲来无事，仔细想了想相关问题，又看了一些资料，突然发现事情和我之前想的有很大出入。不夸张地说，弱人工智能比强人工智能更可怕一些。我想很多人已经意识到了这一点，才对人工智能如临大敌的。&lt;/p&gt;
&lt;p&gt;这里就不提“弱人工智能”和“强人工智能”的定义了，简单说，弱人工智能会“忠实”地完成（人类给它的）任务，而不会有任何其他的“反常”行为。而强人工智能的行为有更多的自主性，具有更大的不可控性。&lt;/p&gt;
&lt;p&gt;我的核心观点是，当你命令一个比你聪明的机器完成某个确定的任务时，你是无法预料到它会使用怎样的方式来实现的，而某种实现方式很可能在你还没有反应过来时就产生了无法挽回的副作用。&lt;/p&gt;
&lt;p&gt;这让我想起了雅各布斯的《猴爪》，或者我可以编这样一个比较俗套故事：&lt;/p&gt;
&lt;p&gt;A某天意味获得了一个魔镜，魔镜告诉他可以以许下任何愿望，它都可以将其实现。A大喜，然后许愿希望自己可以得到足够他后半生使用的钱财。刚许完愿，一则新闻从电视机传出，某航班飞机失事，所有乘客无一生还 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;关于人工智能，一个广为流传的说法是：“弱人工智能并不可怕，强人工智能才是可怕的。而至少目前看来强人工智能是遥遥无期的，所以现在就担心人工智能的危害还为时尚早。”之前我也有类似的想法，虽然我并不认为弱人工智能就完全没有危害，但基本处于可控的范围内，至少不比核武器或者病毒之类更危险些。&lt;/p&gt;
&lt;p&gt;这两天我闲来无事，仔细想了想相关问题，又看了一些资料，突然发现事情和我之前想的有很大出入。不夸张地说，弱人工智能比强人工智能更可怕一些。我想很多人已经意识到了这一点，才对人工智能如临大敌的。&lt;/p&gt;
&lt;p&gt;这里就不提“弱人工智能”和“强人工智能”的定义了，简单说，弱人工智能会“忠实”地完成（人类给它的）任务，而不会有任何其他的“反常”行为。而强人工智能的行为有更多的自主性，具有更大的不可控性。&lt;/p&gt;
&lt;p&gt;我的核心观点是，当你命令一个比你聪明的机器完成某个确定的任务时，你是无法预料到它会使用怎样的方式来实现的，而某种实现方式很可能在你还没有反应过来时就产生了无法挽回的副作用。&lt;/p&gt;
&lt;p&gt;这让我想起了雅各布斯的《猴爪》，或者我可以编这样一个比较俗套故事：&lt;/p&gt;
&lt;p&gt;A某天意味获得了一个魔镜，魔镜告诉他可以以许下任何愿望，它都可以将其实现。A大喜，然后许愿希望自己可以得到足够他后半生使用的钱财。刚许完愿，一则新闻从电视机传出，某航班飞机失事，所有乘客无一生还，而A的妻子正是其中之一。妻子所在的公司为出差的妻子投了数额可观的商业保险，保险赔偿足够A后半生使用了。A和妻子相亲相爱，之后A懊悔不已，从此一蹶不振，同时对魔镜恨之入骨，打算将其扔掉而不再许任何愿望了。&lt;/p&gt;
&lt;p&gt;邻居B听说此事，立即找A要走了这个魔镜。他当然听说了A的故事，但仔细考虑后发现并非无利可图。于是他许下了这样的愿望：我想要得到足够后半生使用的钱财，同时自己和所有的亲人朋友身体健康长命百岁。想必这回不会有任何差错了。第二天B在自己的院子了发现了一个藏有大量现金的包裹，大喜过望。正当他数钱时，几个警察破门而入。原来他们正在查一个涉案数额庞大的盗窃案，得到线索后立即赶来，逮捕了B。因为种种原因，B被认作小偷的同伙被监禁了十几年。等被释放出来时，B已经心灰意冷，整日在街头流浪，然而身体却很健康从不生病，直到百岁时寿终正寝。&lt;/p&gt;
&lt;p&gt;在B被逮捕后，B的朋友C就盯上了那个魔镜……&lt;/p&gt;
&lt;p&gt;那么，如果有一天你得到了这个魔镜，你是否能许下一个无懈可击的愿望呢？&lt;/p&gt;
&lt;p&gt;当人类给比自己聪明的机器下命令时，面临着相同的问题，虽然我还没想好一个比较切实的例子。我试举一例：&lt;/p&gt;
&lt;p&gt;将来的某年，人类发现大气层中的臭氧越来越少，照射到地面的紫外线已经对人类的健康产生了很大的威胁。于是派一些机器去大气层，用人类已知的方法填补臭氧层，但效果甚微。因为机器是有智能的，于是人类给它提供了大量的信息，供机器产出更好的方法，同时可以实地验证效果以加快进度。谨慎起见，科学家们每时每刻检测着机器传回的数据以及大气层的各项指标，同时时刻准备在发生任何异常时给机器发送终止指令。&lt;/p&gt;
&lt;p&gt;几天时间内，机器做了数百万次的实验，依然没有发现任何有效的方法，科学家们也有些松懈了。直到某一天突然大气层中某种化合物的含量急剧升高，这种化合物人类前所未见，它吸收红外线的效果异常显著，并且在吸收红外线过程中会引发连锁反应，制造出大量相同化合物。科学家们连忙终止机器的工作，并获取到该化合物样本，寻求解决方案。但在方案产生和成功实施之前，该化合物已经布满了地球上空，地表温度慢慢降低到零下几十摄氏度，人类文明就此结束。&lt;/p&gt;
&lt;p&gt;这似乎是科幻小说中才有的情节，也许不可能在现实中发生，但难保某个相似版本在未来发生，而且是不远的未来。&lt;/p&gt;
&lt;p&gt;也许某些人认为弱人工智能不会比人类聪明。其实发生这样的事情，无需机器的智力全方面超越人类，只需要它在解决某个特定领域问题的能力超过人类就行，而现在电脑在某种程度上就可以做到这一点。现在类似这样的事情不大可能发生，很大程度在于人类还没有委任智能机器这样的重任，机器也不可能在任何情况下产生不可挽回的后果。但随着人工智能的发现，智能机器所承担的角色和所做的事情毫无意外地会越来越重要。&lt;/p&gt;
&lt;p&gt;可以说，如果弱人工智能出了问题，只能是人类自身的“失误”导致的。但仔细想来，这种“失误”的含义远比字面上的深刻。人类如何能做到不允许这样的“失误”产生。&lt;/p&gt;
&lt;p&gt;当我们以人工智能发展的角度看，人工智能可能刚刚起步，以后还有很长的路要走。但如果从人类文明的角度看，有可能终点就在不远处。&lt;/p&gt;
&lt;p&gt;将来会发生什么，只能拭目以待。&lt;/p&gt;</content></entry><entry><title>做视频剪辑整理的一些记录</title><link href="/zuo-shi-pin-jian-ji-zheng-li-de-yi-xie-ji-lu.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zuo-shi-pin-jian-ji-zheng-li-de-yi-xie-ji-lu.html</id><summary type="html">&lt;p&gt;这几天做了一个视频剪辑，接触了一些相关工具，整理一下。&lt;/p&gt;
&lt;h2&gt;视频切割合并&lt;/h2&gt;
&lt;p&gt;视频切割合并是非常基础和常用的功能，往往是处理视频素材的第一步。我之前简单处理过一些音频，用的是开源软件audacity，所有想应该也有类似的处理视频的开源软件。找了一圈试用了好几个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Shotcut
据说是很有名的开源视频剪辑软件，安装后没用明白……上网搜教程还是没用明白（智商堪忧），没找到视频如何导出，也没找到切割和合并的功能。我知道一定是我的问题，放弃了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;爱剪辑
国内的免费软件。用户体验还好，格式支持也比较多。本来打算用这个了，结果发现导出的视频会强行加入开头和结尾，无法取消（至少免费版不能取消），也罢。另外我没找到可以保持原视频分辨率的选项，自己选和原视频相同的分辨率后，导出的视频有黑边，也许是我用得有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mencoder
强大的命令行工具，可以完成视频切割合并操作，麻烦是自然的。我本来想先用爱剪辑编辑，然后再用mencoder把开头和结尾去掉，因为开头和结尾时间是固定的，所以应该是可行的。但发现一个问题，视频的aac音频不能使用-oac copy，换了好几个版本的mencoder都不行（有的不支持libfaac，有的可以选择-oac faac重新编码），必须重新编码，也就是说每用mencoder处理一次，音频就得重新编码一次 …&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;这几天做了一个视频剪辑，接触了一些相关工具，整理一下。&lt;/p&gt;
&lt;h2&gt;视频切割合并&lt;/h2&gt;
&lt;p&gt;视频切割合并是非常基础和常用的功能，往往是处理视频素材的第一步。我之前简单处理过一些音频，用的是开源软件audacity，所有想应该也有类似的处理视频的开源软件。找了一圈试用了好几个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Shotcut
据说是很有名的开源视频剪辑软件，安装后没用明白……上网搜教程还是没用明白（智商堪忧），没找到视频如何导出，也没找到切割和合并的功能。我知道一定是我的问题，放弃了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;爱剪辑
国内的免费软件。用户体验还好，格式支持也比较多。本来打算用这个了，结果发现导出的视频会强行加入开头和结尾，无法取消（至少免费版不能取消），也罢。另外我没找到可以保持原视频分辨率的选项，自己选和原视频相同的分辨率后，导出的视频有黑边，也许是我用得有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mencoder
强大的命令行工具，可以完成视频切割合并操作，麻烦是自然的。我本来想先用爱剪辑编辑，然后再用mencoder把开头和结尾去掉，因为开头和结尾时间是固定的，所以应该是可行的。但发现一个问题，视频的aac音频不能使用-oac copy，换了好几个版本的mencoder都不行（有的不支持libfaac，有的可以选择-oac faac重新编码），必须重新编码，也就是说每用mencoder处理一次，音频就得重新编码一次，或者使用更麻烦的方法（比如先转成其他格式，-oac copy，最后再转回来）。另外考虑到对时间线的痛苦，我还是不直接使用这么原始的工具了，ffmpeg等命令行工具同理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AVS Video Editor 
据说是免费软件，安装后发现不注册的话，导出的视频是带水印的……&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Adobe Premiere Pro
我本来不想用它，因为体积比较大（比前几个合在一起还大），而且是商业软件。但找了一圈没有其他能用的，只好用它了。功能方面，导入视频就发现个问题，不支持导入h264+aac的flv视频，好在我之前找到了一个FLV_Extract（http://www.moitah.net ）工具可以把flv中的视频和音频提取成.264和.aac格式，然后就可以导入到Adobe Premiere Pro，导入后可以把视频和音频关联到一起，虽然麻烦点至少能用了。
操作界面没有爱剪辑那么易懂，但折腾了一会，没看教程也算会用切割合并功能了。但有时用鼠标拖动时会卡住（鼠标旁边的图示也会变，没看明白是什么功能），不知道是什么原因。还有当视频片段比较多，而且是从不同视频剪辑出来的时，播放起来容易卡顿，但看资源管理器，瓶颈貌似不在读磁盘速度上（ssd的系统盘，看Adobe Premiere Pro的磁盘读取速度在50M/s以下），CPU是i5 4590，性能上应该问题不大。
使用了几天后，发现Adobe Premiere Pro在复杂的剪辑操作上（需要导入几十个视频用来编辑，有多条音频，需要按帧把视频对齐到音频，需要能调整选定的片段到原视频前后的部分等等）还是很有优势的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenShot
补充一个OpenShot，前几天恰好看到的。
界面很简洁友好。
不支持选和源视频相同的分辨率，需要手动填写。导出视频时，导出30%后卡住了（未响应）……选h264和mpeg4编码都是，可能是视频文件的问题（一个2分多钟，h264+aac的flv文件）。换了一个（6分多钟，h264+aac的mp4文件）后，到50%多卡住了。又换了一个（6分多钟，h264+aac的mkv文件），没改分辨率导出成功了，改成和原始视频一样的分辨率后，到50%多又卡住了……
可能因为是beta版本（2.0.6），稳定性很差，经常导出视频中未响应，没法用。但看功能方面，基本的切割合并功能还是不错的，如果稳定性没有问题也许可以应付一些简单场景。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;视频压缩&lt;/h2&gt;
&lt;p&gt;使用Adobe Premiere Pro导出的视频体积很大（原始视频是h264+aac 1104x622 30fps的，6分多钟，导出后400多M），我之前想直接用ffmpeg之类的命令行工具压缩（但因为调参数比较麻烦，暂时放下了），但在做字幕时搜了各种软件，找到一个小丸工具箱（https://www.maruko.in/ ）发现很好用，基本不用管参数，处理后大小变成了30多M，没看出画质降低（6分钟的原始视频大概也是这个大小）。&lt;/p&gt;
&lt;p&gt;修正一下，我导出的视频体积很大的原因是没有修改默认的“目标比特率”，改成和原始视频差不多，然后导出就小很多了，但这样画质损失比较大。还是不修改它，直接再压一遍吧。&lt;/p&gt;
&lt;h2&gt;字幕&lt;/h2&gt;
&lt;p&gt;为了弄字幕，我折腾了不少时间。
先用的srt字幕（因为是mv，从lrc歌词转换的，没找到方便的工具。用在线网站转的，但貌似有bug，下载不了转换完的字幕文件，直接复制会有部分乱码……），但我需要右侧竖排的字幕，没找到能让srt字幕显示在屏幕右侧的方法。后来发现ass字幕可以。Aegisub（http://www.aegisub.org/ ）可以把srt字幕转成ass，然后设置字体、位置等，还是很好用的。
但发现一个问题，设置成竖排字幕后，如果Alignment设置成6的话，字幕显示不是纵向居中的，而是偏上，甚至超出了视频边界，选3又太低了。选5是正常的，但通过调整Margins-&amp;gt;Left调到右边又发现问题了。原来一行字幕中带空格是不自动换行的，但调整到视频右侧后，每个空格都换行了。我试过使用中文空格和\h，但间距和半角空格不一样，看起来很别扭。
期间试了试另一个字幕编辑软件PopSub，感觉没有Aegisub好用，没怎么用明白就放弃了。
后来用文本编辑器打开ass文件，发现可以直接编辑。上网搜了半天，说可以每行添加\pos调整位置，尝试了多次终于把位置调对了。&lt;/p&gt;
&lt;p&gt;然后是字幕封装的问题，我的一个视频对应了两种语言的字幕，mpv不能方便地选择显示不同的字幕。Mkvtoolnix（https://mkvtoolnix.download/downloads.html ）可以将视频和多个字幕合并到一个mkv文件，并且设置默认是否显示字幕，很好用。另外还可以在附件里添加字体，就不用担心播放时没有匹配的字体了。&lt;/p&gt;
&lt;p&gt;但有些视频网站（比如B站）是不支持带字幕的mkv文件的，只好把字幕压到视频里。之前提到的小丸工具箱（https://www.maruko.in/ ）有这个功能。&lt;/p&gt;</content></entry></feed>