<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>陌辞寒 - AHK</title><link href="/" rel="alternate"></link><link href="/feeds/ahk.atom.xml" rel="self"></link><id>/</id><updated>2017-09-18T20:29:00+08:00</updated><entry><title>AHK 语言介绍</title><link href="/ahk-yu-yan-jie-shao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ahk-yu-yan-jie-shao.html</id><summary type="html">&lt;p&gt;&lt;a href="http://autohotkey.com"&gt;&lt;strong&gt;AHK&lt;/strong&gt;（AutoHotkey）&lt;/a&gt; 是面向普通电脑用户的自由开源的自动化软件工具，它让用户能够快捷或自动执行重复性任务。&lt;/p&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;体积小巧、语法简明、易学易用。开发环境简单，只需要一个不足 1M 的解释器和一个顺手的编辑器，就可以开发了。&lt;/li&gt;
&lt;li&gt;API 丰富。AHK 提供了很多桌面软件需要用到的 API，而且调用 Windows API 非常方便，这是很多其他脚本语言所无法比拟的。&lt;/li&gt;
&lt;li&gt;AHK 对热键、热字符串有专门支持，写起来非常容易，而这在其他语言基本上都要费费尽周折。&lt;/li&gt;
&lt;li&gt;AHK 没有官方自带或者第三方实现的完善的标准库，这样如果需要实现非内置的功能通常需要直接调用 Windows API 或寻找别人封装好的函数。AHK 语言本身并不强大，缺少很多现代语言所具备的高级特性，同时也缺乏对多线程等操作系统特性的支持。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;AHK 的优点和缺点同样明显，我们需要慎重考虑，针对具体场景选择合适的工具。&lt;/p&gt;
&lt;h2&gt;当前版本&lt;/h2&gt;
&lt;h3&gt;AHK v1&lt;/h3&gt;
&lt;p&gt;AHK v1 是当前 AHK 的主流版本 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://autohotkey.com"&gt;&lt;strong&gt;AHK&lt;/strong&gt;（AutoHotkey）&lt;/a&gt; 是面向普通电脑用户的自由开源的自动化软件工具，它让用户能够快捷或自动执行重复性任务。&lt;/p&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;体积小巧、语法简明、易学易用。开发环境简单，只需要一个不足 1M 的解释器和一个顺手的编辑器，就可以开发了。&lt;/li&gt;
&lt;li&gt;API 丰富。AHK 提供了很多桌面软件需要用到的 API，而且调用 Windows API 非常方便，这是很多其他脚本语言所无法比拟的。&lt;/li&gt;
&lt;li&gt;AHK 对热键、热字符串有专门支持，写起来非常容易，而这在其他语言基本上都要费费尽周折。&lt;/li&gt;
&lt;li&gt;AHK 没有官方自带或者第三方实现的完善的标准库，这样如果需要实现非内置的功能通常需要直接调用 Windows API 或寻找别人封装好的函数。AHK 语言本身并不强大，缺少很多现代语言所具备的高级特性，同时也缺乏对多线程等操作系统特性的支持。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;AHK 的优点和缺点同样明显，我们需要慎重考虑，针对具体场景选择合适的工具。&lt;/p&gt;
&lt;h2&gt;当前版本&lt;/h2&gt;
&lt;h3&gt;AHK v1&lt;/h3&gt;
&lt;p&gt;AHK v1 是当前 AHK 的主流版本，也是官方网站下载地址中的版本。写此文时，最新版本为 1.1.23.05。&lt;/p&gt;
&lt;p&gt;其中又包含三个构建版本：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Unicode 32-bit。32 位 Unicode 版本，如无特殊需求，推荐使用此版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Unicode 64-bit。64 位 Unicode 版本，性能比 Unicode 32-bit 版本稍好，但占用更多内存。兼容性方面不如 Unicode 32-bit 版本。适合对性能敏感的场景使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ANSI 32-bit 。32 位 ANSI 版本，对历史遗留下来的老 AHK 脚本兼容性较好。如果写新脚本，无需关注此版本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;AHK v2&lt;/h3&gt;
&lt;p&gt;AHK v2 是试验分支，包含一些新的语言特性和平台相关功能等，语法上和 AHK v1 并不兼容，稳定性也不如 AHK v1。如果需要一些 AHK v2 的新特性，或者对 AHK 未来的发展方向感兴趣，可以关注此版本。&lt;/p&gt;
&lt;p&gt;下载地址：https://autohotkey.com/v2&lt;/p&gt;
&lt;h3&gt;其他版本&lt;/h3&gt;
&lt;p&gt;AutoHotkey_H: http://hotkeyit.github.io/v2
IronAHK: https://github.com/polyethene/IronAHK&lt;/p&gt;
&lt;p&gt;仅供有兴趣的朋友参考。&lt;/p&gt;
&lt;h2&gt;用法示例&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 热键示例，按 Win + n 启动记事本
#n::
    Run, notepad
return

; 热字符串示例，按 web 打开 AHK 官网
::web::
    Run, http://autohotkey.com
return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;更多用法请参考 &lt;a href="https://autohotkey.com/docs/AutoHotkey.htm"&gt;官网文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://zh.wikipedia.org/wiki/AutoHotkey"&gt;中文维基百科 AutoHotkey 词条&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://autohotkey.com"&gt;AHK 官方网站&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content></entry><entry><title>[基础] AHK 中标签和函数的用法</title><link href="/ji-chu-ahk-zhong-biao-qian-he-han-shu-de-yong-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-biao-qian-he-han-shu-de-yong-fa.html</id><summary type="html">&lt;p&gt;AHK 中有两种比较像的东西，标签和函数。&lt;/p&gt;
&lt;h2&gt;标签&lt;/h2&gt;
&lt;p&gt;标签比较简单，用来标记一段代码的位置，以 return 结束。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Gosub, Test
Goto, Test
; 不再执行
MsgBox, End

Test:
    MsgBox, Test
return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Test 就是一个标签。标签可以用 Gosub 调用，Gosub 执行完后会继续执行下一行。也可以用 Goto 调用，但 Goto 调用完就不会回来了。&lt;/p&gt;
&lt;p&gt;除了使用 Gosub 或者 Goto 调用，标签还可以作为其他命令的参数，比如 Hotkey、SetTimer 等等。&lt;/p&gt;
&lt;p&gt;标签里的代码默认是执行的。比如这样一个 AHK 文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MsgBox, Begin

Test …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;AHK 中有两种比较像的东西，标签和函数。&lt;/p&gt;
&lt;h2&gt;标签&lt;/h2&gt;
&lt;p&gt;标签比较简单，用来标记一段代码的位置，以 return 结束。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Gosub, Test
Goto, Test
; 不再执行
MsgBox, End

Test:
    MsgBox, Test
return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Test 就是一个标签。标签可以用 Gosub 调用，Gosub 执行完后会继续执行下一行。也可以用 Goto 调用，但 Goto 调用完就不会回来了。&lt;/p&gt;
&lt;p&gt;除了使用 Gosub 或者 Goto 调用，标签还可以作为其他命令的参数，比如 Hotkey、SetTimer 等等。&lt;/p&gt;
&lt;p&gt;标签里的代码默认是执行的。比如这样一个 AHK 文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MsgBox, Begin

Test:
    MsgBox, Test
return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;即使没有主动调用 Test 标签，Test 标签里的内容还是会被执行。&lt;/p&gt;
&lt;p&gt;可以使用动态的标签名来调用标签。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;labelName := &amp;quot;Test&amp;quot;

; IsLabel 函数用来判断标签是否存在
if (IsLabel(labelName))
{
    Gosub, %labelName%
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;函数&lt;/h2&gt;
&lt;p&gt;函数也可以实现标签的功能，但更强大和灵活。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test1()
Test2(&amp;quot;test&amp;quot;)

Test1()
{
    MsgBox, Test1
}

; 函数支持参数和返回值
Test2(text)
{
    MsgBox, % text
    return true
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数的调用方式是函数名加小括号，如果需要传递参数，在括号里添加参数。和标签不一样，函数里的代码默认是不执行的。&lt;/p&gt;
&lt;p&gt;可以使用动态的标签名来调用函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;functionName&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Test&amp;quot;&lt;/span&gt;

&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;IsFunc&lt;/span&gt; &lt;span class="err"&gt;函数用来判断函数是否存在&lt;/span&gt;
&lt;span class="nf"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;IsFunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;functionName&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nf"&gt;%function&lt;/span&gt;&lt;span class="n"&gt;Name&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数里可以调用标签，标签里也可以调用函数。标签和函数可以重名。&lt;/p&gt;
&lt;h2&gt;函数里的标签&lt;/h2&gt;
&lt;p&gt;在函数里可以再定义标签。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test()
{
    Gosub, Test2
    return

    Test2:
        MsgBox, Test2
    return
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代码中 Test2 是一个内部标签，只能在 Test 函数中访问。但不同函数中的内部标签也不能够重名，即所有的标签名必须是唯一的。&lt;/p&gt;
&lt;h2&gt;标签和函数的区别&lt;/h2&gt;
&lt;p&gt;总结下标签和函数的区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义和调用的方式不同。&lt;/li&gt;
&lt;li&gt;函数支持参数和返回值，标签不支持。&lt;/li&gt;
&lt;li&gt;标签默认是执行的，函数默认不执行。&lt;/li&gt;
&lt;li&gt;调用标签的开销比调用函数小，调用空函数的耗时比调用空标签多百分之几十。&lt;/li&gt;
&lt;li&gt;函数中可以使用局部变量和静态变量，但标签中只能使用全局变量。&lt;/li&gt;
&lt;li&gt;某些场景可能只允许用标签，但最新的 AHK 版本基本所有场景都可以用函数了（如果以后想起来有不可取代的场景再补充）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么是使用标签还是函数呢？&lt;/p&gt;
&lt;p&gt;通常情况，使用函数就可以了。如果考虑到性能，在无需参数和返回值的情况可以用标签取代函数。除非一个函数被高频率地调用，否则优化的效果不大。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中的字符串处理函数</title><link href="/ji-chu-ahk-zhong-de-zi-fu-chuan-chu-li-han-shu.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-de-zi-fu-chuan-chu-li-han-shu.html</id><summary type="html">&lt;p&gt;上一篇文章我介绍了AHK 中的字符串拼接和遍历操作，但除此之外还有很多其他类型的字符串操作。本文会罗列 AHK 中多数用于字符串操作的函数，但也正因为此，我不会对每一个函数都详细讲解和举例，大家可以直接去帮助文档查询感兴趣的函数，里边有详细的讲解和举例。另外有一些高级内容，我只在文中提及，后续会专门写文章来展开。&lt;/p&gt;
&lt;p&gt;很多字符串处理函数还有对应的命令，比如 StrLen 函数对应 StringLen 命令。因为通常情况，函数比命令好用，有时功能还更强大，所以只介绍函数。但在性能上，命令通常要比函数好一些，如果遇到性能问题，可以自行查找帮助文档，将函数替换成对应命令。&lt;/p&gt;
&lt;h2&gt;计算长度&lt;/h2&gt;
&lt;p&gt;StrLen 函数用于计算字符串的长度，这个我们在之前的判断空字符串的文章提及过，所以并不陌生。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;OutputVar := StrLen(InputVar)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要注意的是，StrLen 的结果并非字符串所占用的字节数。如果字符串里包含中文、全角字符以及日文、韩文等非 ASCII 字符，长度也是只算 1 的，虽然实际储存时并非只消耗 1 个字节 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;上一篇文章我介绍了AHK 中的字符串拼接和遍历操作，但除此之外还有很多其他类型的字符串操作。本文会罗列 AHK 中多数用于字符串操作的函数，但也正因为此，我不会对每一个函数都详细讲解和举例，大家可以直接去帮助文档查询感兴趣的函数，里边有详细的讲解和举例。另外有一些高级内容，我只在文中提及，后续会专门写文章来展开。&lt;/p&gt;
&lt;p&gt;很多字符串处理函数还有对应的命令，比如 StrLen 函数对应 StringLen 命令。因为通常情况，函数比命令好用，有时功能还更强大，所以只介绍函数。但在性能上，命令通常要比函数好一些，如果遇到性能问题，可以自行查找帮助文档，将函数替换成对应命令。&lt;/p&gt;
&lt;h2&gt;计算长度&lt;/h2&gt;
&lt;p&gt;StrLen 函数用于计算字符串的长度，这个我们在之前的判断空字符串的文章提及过，所以并不陌生。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;OutputVar := StrLen(InputVar)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要注意的是，StrLen 的结果并非字符串所占用的字节数。如果字符串里包含中文、全角字符以及日文、韩文等非 ASCII 字符，长度也是只算 1 的，虽然实际储存时并非只消耗 1 个字节。同时，StrLen 的结果也不能作为字符串的显示长度，因为通常中文、全角字符等要比英文、半角字符的显示宽度要大（如果是等宽字体，前者的宽度是后者的两倍）。&lt;/p&gt;
&lt;p&gt;StrLen 函数对应的命令是 StringLen。&lt;/p&gt;
&lt;h2&gt;查找&lt;/h2&gt;
&lt;p&gt;查找操作是指判断一个字符串是否包含另一个字符串，如果包含，还需要找到具体的位置，这便是 InStr 函数的工作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FoundPos := InStr(Haystack, Needle [, CaseSensitive = false, StartingPos = 1, Occurrence = 1])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;InStr 函数的参数比较多。Haystack 是被查找的字符串，Needle 是待查找的字符串（即从 Haystack 里查找 Needle），CaseSensitive 用于设置是否区分大小写，StartingPos 是开始查找的位置（从头开始为 1，如果是 0 或者负数，将逆序查找），Occurrence 指查找几次（比如 Occurrence 是  2，那么即使 Haystack 里有一个 Needle，也会因为没有第 2 个 Needle 而返回 0）。&lt;/p&gt;
&lt;p&gt;InStr 函数的返回值是 Needle 在 Haystack 的位置，从 1 开始。如果返回 0，说明没找到。&lt;/p&gt;
&lt;p&gt;和 InStr 函数有关的命令有 IfInString、IfNotInString、StringGetPos，如果遇到性能问题，可以使用。&lt;/p&gt;
&lt;p&gt;另外 if 也可以用来判断一个字符串中是否包含另一个字符串。可以在帮助文档搜索 if var [not] in/contains 找到，里边有详细讲解。我也会在以后专门介绍 if 判断的文章里展开。&lt;/p&gt;
&lt;h2&gt;截取&lt;/h2&gt;
&lt;p&gt;截取操作是指取一个字符串的子字符串，这正是 SubStr 函数的工作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;NewStr := SubStr(String, StartPos [, Length])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;SubStr 函数很好理解，String 即原始字符串。StartPos 为截取的起点，从 1 开始，如果为 0，表示截取最后一个字符；如果为 -1，表示截取最后两个字符，以此类推。Length 为截取的长度，如果省略指截到原始字符串的末尾。&lt;/p&gt;
&lt;p&gt;和 SubStr 函数有关的命令有 StringLeft、StringRight、StringMid、StringTrimLeft、StringTrimRight，这些命令用起来都不大方便，如果遇到性能问题，可以使用。&lt;/p&gt;
&lt;h2&gt;分隔&lt;/h2&gt;
&lt;p&gt;分隔字符串，和我们上一篇文章了解到的遍历字符串很像，但 StrSplit 使用起来更灵活。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Array := StrSplit(String [, Delimiters, OmitChars])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;String 是原始字符串，Delimiters 是分割符（和 Loop, Parse 不同，这里支持字符串，而且可以是一个字符串数组，非常强大），OmitChars 是移除和分隔符相邻的特定字符。&lt;/p&gt;
&lt;p&gt;返回的结果 Array 是一个数组，可以用 Array[1] 访问第一个元素，用 Array.Length() 获取数组中的元素个数等。以后我们会专门了解数组的用法。&lt;/p&gt;
&lt;p&gt;StrSplit 函数对应的命令是 StringSplit，但二者在细节上有很多不同，如果因为性能等原因一定要用 StringSplit，要仔细测试。&lt;/p&gt;
&lt;h2&gt;替换&lt;/h2&gt;
&lt;p&gt;有时我们需要将字符串的特定内容替换成其他内容，StrReplace 函数就派上用场了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;OutputVar := StrReplace(Haystack, SearchText [, ReplaceText, OutputVarCount, Limit := -1])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;StrReplace 函数参数比较多，但也很好理解。Haystack 是原始字符串，SearchText 是被替换的内容，ReplaceText 是替换成的内容（如果省略，代表直接删除），OutputVarCount 用来存放替换的次数（如果省略代表不保存），Limit 指最多替换几次（-1 指全部替换，如果为 1，代表只替换找到的第一个）。&lt;/p&gt;
&lt;p&gt;StrReplace 函数对应的命令是 StringReplace。&lt;/p&gt;
&lt;h2&gt;判断类型&lt;/h2&gt;
&lt;p&gt;判断类型是指判断一个字符串是否是整数、浮点数、字母、大写字母、小写字母、空白、时间等。&lt;/p&gt;
&lt;p&gt;帮助文档里讲得很详细，这里就不展开了，搜 if var is [not] type 即可。&lt;/p&gt;
&lt;p&gt;这里举个和下一节有关的判断大小写字母的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;abc&amp;quot;
b := &amp;quot;ABC&amp;quot;
c := &amp;quot;abc1&amp;quot;

if a is lower
{
    ; 条件成立，只有字符串里全部是小写字母（a-z）才成立
}

if b is upper
{
    ; 条件成立，同理
}

if c is lower
{
    ; 条件不成立，因为包含了一个数字
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;大小写转换&lt;/h2&gt;
&lt;p&gt;有时我们需要转换字符串中字母的大小写，StringLower 命令用于将大写字母转换成小写，StringUpper 命令用于将小写字母转换成大写。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StringLower, OutputVar, InputVar [, T]
StringUpper, OutputVar, InputVar [, T]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参数中的 OutputVar 和 InputVar 都是变量名，即不用加 %。T 参数表示将字符串转换为标题格式，即每个单词的首字母大写，其余部分小写。&lt;/p&gt;
&lt;h2&gt;移除首尾指定字符&lt;/h2&gt;
&lt;p&gt;有时我们需要移除一个字符串首尾的某些字符，典型情况就是移除首尾的空格。这就需要使用 Trim 系列函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Result := Trim(String, OmitChars = &amp;quot; `t&amp;quot;)
Result := LTrim(String, OmitChars = &amp;quot; `t&amp;quot;)
Result := RTrim(String, OmitChars = &amp;quot; `t&amp;quot;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这三个函数用法一致，Trim 用于移除字符串首尾（两侧）的指定字符，LTrim 用于移除字符串首部（左侧）的指定字符，RTrim 用于移除字符串尾部（右侧）的指定字符。&lt;/p&gt;
&lt;p&gt;另外还有一个和此相关的命令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;AutoTrim, On|Off
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;AutoTrim 的含义是在用 = 赋值时是否自动移除首尾空白（空格和 Tab），默认是移除。&lt;/p&gt;
&lt;h2&gt;格式化&lt;/h2&gt;
&lt;p&gt;格式化操作主要是将整数、浮点数等格式化成特定格式的字符串，用来展示。这主要是 Format 函数的工作，SetFormat 命令也与此有关。Format 函数的参数很复杂，但帮助文档里有详细讲解，暂时就不展开了，以后可能单独讲解。&lt;/p&gt;
&lt;h2&gt;排序&lt;/h2&gt;
&lt;p&gt;对字符串排序可以使用 Sort 命令，因为排序比较复杂，我以后再单独讲。&lt;/p&gt;
&lt;h2&gt;字符编码操作&lt;/h2&gt;
&lt;p&gt;通常情况，我们不需要了解字符串对应的二进制数据是怎样的。但有些时候我们需要知道字符对应编码（比如 ASCII 编码，或者 UTF-8 编码），在字符与编码间相互转换等，Asc、Chr、Ord 函数用于此类操作。这其中涉及到一些复杂问题，先不展开，我以后会单独讲。&lt;/p&gt;
&lt;h2&gt;内存操作&lt;/h2&gt;
&lt;p&gt;通常情况，我们不需要关注字符串在内存是怎么储存的，但某些场景我们需要这么做，比如转编码（此处编码指代码页，比如将字符串从 UTF-8 转成 CP936）。这就需要用到 StrPut 和 StrGet 函数。这属于高级内容，也比较复杂，我以后会单独讲。&lt;/p&gt;
&lt;h2&gt;正则表达式&lt;/h2&gt;
&lt;p&gt;正则表达式也是用来查找和替换字符串用的，但自成体系，功能强大，也特别复杂。RegExMatch 函数、RegExReplace 函数和 ~= 运算符和正则表达式有关。因为 AHK 中的正则表达式和其他语言中的大同小异，而且关于正则表达式的内容特别多，暂时就不展开了，以后也会单独讲到。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中的字符串拼接和遍历操作</title><link href="/ji-chu-ahk-zhong-de-zi-fu-chuan-pin-jie-he-bian-li-cao-zuo.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-de-zi-fu-chuan-pin-jie-he-bian-li-cao-zuo.html</id><summary type="html">&lt;p&gt;字符串处理在多数编程语言中都是重头戏，AHK 自然也不例外。AHK 在字符串处理方面还是很灵活的，如果掌握好了，写起代码来会事半功倍。本文先介绍最常用的操作：拼接和遍历。&lt;/p&gt;
&lt;h2&gt;字符串拼接&lt;/h2&gt;
&lt;p&gt;拼接恐怕是最常用的操作了，在 AHK 中也非常简单，直接将两个字符串用空格隔开就可以了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;abc&amp;quot;
b := 100
c := &amp;quot;def&amp;quot;
d := 123.456
e := 200

; f 的值是字符串 abc100anddef123.456
f := a b &amp;quot;and&amp;quot; c d
; g 的值是字符串 100200
g := b e
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不管是字符串、整数还是浮点数，都可以用空格拼接成一个字符串。更神奇的是，空格可以和其他算术运算符一起使用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 100
b …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;字符串处理在多数编程语言中都是重头戏，AHK 自然也不例外。AHK 在字符串处理方面还是很灵活的，如果掌握好了，写起代码来会事半功倍。本文先介绍最常用的操作：拼接和遍历。&lt;/p&gt;
&lt;h2&gt;字符串拼接&lt;/h2&gt;
&lt;p&gt;拼接恐怕是最常用的操作了，在 AHK 中也非常简单，直接将两个字符串用空格隔开就可以了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;abc&amp;quot;
b := 100
c := &amp;quot;def&amp;quot;
d := 123.456
e := 200

; f 的值是字符串 abc100anddef123.456
f := a b &amp;quot;and&amp;quot; c d
; g 的值是字符串 100200
g := b e
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不管是字符串、整数还是浮点数，都可以用空格拼接成一个字符串。更神奇的是，空格可以和其他算术运算符一起使用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 100
b := 200

; c 的值是 100150
c := a b - 50
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其实 AHK 中整数 100200 和 字符串 "100200" 是没有区别的，当整数用的时候就是 100200，当字符串用的时候就是 "100200"，当然内部实现上会有一些优化。如果感觉无法接受的话，也可以认为整数和字符串是有区别的，在实际使用中会自动相互转换。&lt;/p&gt;
&lt;p&gt;实际上，AHK 中 .（点运算符）是专门用来拼接字符串的，在某些情况还是不能省略的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 300
b := 200

; c 的值是 100
c := a - b

; d 的值是 300-200
d := a . - b
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正因为空格可以和其他算术运算符一起使用，使用起来可以很灵活，为了避免歧义，空格只有在必要的情况（即这个表达式没有其他的解释办法时）才起拼接作用。&lt;/p&gt;
&lt;h2&gt;子字符串遍历&lt;/h2&gt;
&lt;p&gt;还有一个非常常见的操作，是遍历一个字符串的子字符串。Loop, Parse 是专门用来做这个的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop, Parse, InputVar [, Delimiters, OmitChars]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中 InputVar 是变量名，不需要加 %。Delimiters 是分隔符，OmitChars 是要忽略的字符。&lt;/p&gt;
&lt;p&gt;最简单的场景就是遍历字符串中的每一个字符。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;text := &amp;quot;abcd&amp;quot;

Loop, Parse, text
{
    ; 依次弹出
    ; a
    ; b
    ; c
    ; d
    MsgBox, %A_LoopField%
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Delimiters 和 OmitChars 都省略的情况，就是遍历字符串中的每一个字符。&lt;/p&gt;
&lt;p&gt;另外一个典型场景是依次处理一段文字的每一行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;text =
(
line1
line2
line3
)

Loop, Parse, text, `n, `r
{
    ; 依次弹出
    ; line1
    ; line2
    ; line3
    MsgBox, %A_LoopField%
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里 Delimiters 是 `n。`r 又是什么呢？在类 UNIX 操作系统中，文本中的换行符就是 `n，但在 Windows 中，换行符是 `r`n。如果处理一段换行符是 `r`n 的文本，直接用 `n 分隔，会保留多余的 `r，所以设置 OmitChars 为 `r 可以将其去掉。可能有不仔细的朋友认为 &lt;code&gt;Loop, Parse, text, \&lt;/code&gt;n, `r&lt;code&gt;是将字符串同时按 \&lt;/code&gt;n 和 `r 来分隔，这是错误的，`n 和 `r 的顺序也不能颠倒。&lt;/p&gt;
&lt;p&gt;除了按换行符，我们也经常需要按其他符号分隔字符串，比如按空格，按逗号等，就大同小异了。但需要注意空格和逗号有点特殊，因为它们是特殊符号，写法有一些特别。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;text := &amp;quot;a b,c d:xxx&amp;quot;

Loop, Parse, text, %A_Space%
{
    ; 依次弹出
    ; a
    ; b,c
    ; d:xxx
    MsgBox, %A_LoopField%
}

Loop, Parse, text, `,
{
    ; 依次弹出
    ; a b
    ; c d:xxx
    MsgBox, %A_LoopField%
}

Loop, Parse, text, :
{
    ; 依次弹出
    ; a b,c d
    ; xxx
    MsgBox, %A_LoopField%
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里空格用的是 %A_Space%，A_Space 是一个 AHK 的内部变量，这样需要用 % 取该变量的值。`, 是用转义的方法取到的逗号字符，因为直接写逗号会被认为是参数的分隔符。类似的还有 `t 或者 %A_Tab% 是 Tab 等等，如果一个字符直接写会报语法错误，那么通常在前边加个 ` 就可以了。以后我也会专门写文章介绍转义字符。至于冒号，就没有什么特别，直接写就可以了。&lt;/p&gt;
&lt;p&gt;有些情况我们需要按字符串分隔，而不是按字符分隔，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;text := &amp;quot;abc()bcd(cde&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要按 () 分隔 text。需要注意，这种情况这样的写法就是错误的了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;text := &amp;quot;abc()bcd(cde&amp;quot;

Loop, Parse, text, (, )
{
    ; 依次弹出
    ; abc
    ; bcd
    ; cde
    MsgBox, %A_LoopField%
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个可行的办法，是先将字符串中的 () 替换成一个字符串里没有的特殊字符，比如 @，然后再用这个特殊字符作为分隔符：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;text&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;abc()bcd(cde&amp;quot;&lt;/span&gt;

&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;StrReplace&lt;/span&gt; &lt;span class="err"&gt;函数是用来替换字符串的，我们以后再详细了解&lt;/span&gt;
&lt;span class="nl"&gt;text&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;StrReplace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;()&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;@&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;Loop&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;@&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;依次弹出&lt;/span&gt;
    &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;abc&lt;/span&gt;
    &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;bcd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cde&lt;/span&gt;
    &lt;span class="n"&gt;MsgBox&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;A_LoopField&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;更多内容&lt;/h2&gt;
&lt;p&gt;除了拼接和遍历字符串，我们还需要进行查找、替换、匹配、分隔、计算长度等操作，这涉及数量较多的字符串处理函数，以后我们再详细了解。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中读写文件的方法</title><link href="/ji-chu-ahk-zhong-du-xie-wen-jian-de-fang-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-du-xie-wen-jian-de-fang-fa.html</id><summary type="html">&lt;p&gt;读写文件是很常用的操作，本文简单介绍 AHK 中读写文件的方法。可以使用命令和函数两种方式读写文件，二者各有所长，所以分别介绍一下。&lt;/p&gt;
&lt;h2&gt;命令方式&lt;/h2&gt;
&lt;p&gt;使用命令写入和读取文件比较方便，但如果频繁调用，性能较差。&lt;/p&gt;
&lt;h3&gt;写入文件&lt;/h3&gt;
&lt;p&gt;FileAppend 命令用于写入文件，当文件不存在时会先创建文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileAppend [, Text, Filename, Encoding]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个命令用起来很方便，Text 即要写入的内容，如果 Text 为空，那么如果文件不存在，会创建空文件，如果文件已经存在，则只更新文件的修改时间。Filename 为文件名，如果 Filename 不包含绝对路径，那么就是在 A_WorkingDir 目录下。Encoding 是文件的编码，默认是 FileEncoding 命令指定的编码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileEncoding [, Encoding]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;常用的有以下几个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UTF-8。带 BOM 的 UTF-8 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;读写文件是很常用的操作，本文简单介绍 AHK 中读写文件的方法。可以使用命令和函数两种方式读写文件，二者各有所长，所以分别介绍一下。&lt;/p&gt;
&lt;h2&gt;命令方式&lt;/h2&gt;
&lt;p&gt;使用命令写入和读取文件比较方便，但如果频繁调用，性能较差。&lt;/p&gt;
&lt;h3&gt;写入文件&lt;/h3&gt;
&lt;p&gt;FileAppend 命令用于写入文件，当文件不存在时会先创建文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileAppend [, Text, Filename, Encoding]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个命令用起来很方便，Text 即要写入的内容，如果 Text 为空，那么如果文件不存在，会创建空文件，如果文件已经存在，则只更新文件的修改时间。Filename 为文件名，如果 Filename 不包含绝对路径，那么就是在 A_WorkingDir 目录下。Encoding 是文件的编码，默认是 FileEncoding 命令指定的编码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileEncoding [, Encoding]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;常用的有以下几个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UTF-8。带 BOM 的 UTF-8。&lt;/li&gt;
&lt;li&gt;UTF-8-RAW。不带 BOM 的 UTF-8。&lt;/li&gt;
&lt;li&gt;CP936。GBK 编码对应的代码页。&lt;/li&gt;
&lt;li&gt;ANSI。系统默认的代码页，对于中文的 Windows 系统，即 CP936。&lt;/li&gt;
&lt;li&gt;UTF-16。带 BOM 的小端 UTF-16。&lt;/li&gt;
&lt;li&gt;UTF-16-RAW。不带 BOM 的小端 UTF-16。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果也没用 FileEncoding 指定编码，那么默认是 ANSI 编码（也可以在用 AutoHotkey.exe 运行脚本时加参数指定，不推荐使用）。&lt;/p&gt;
&lt;p&gt;如果对这些编码没概念，建议使用 UTF-8，比较通用，在 Windows 下用记事本打开也显示正常。如果不需要记事本打开后显示正常，推荐使用 UTF-8-RAW，兼容性好，方便处理。如果需要尽量减少文件体积，可以使用 CP936。尽量不要使用 ANSI，以免在其他语言的系统出问题。非特殊情况，不建议使用 UTF-16 系列编码，以免衍生各种问题。&lt;/p&gt;
&lt;p&gt;如果文件中有内容，并且文件是带 BOM 的 UTF-8 或 UTF-16 编码，那么即使不指定编码，也会使用对应编码写入文件。&lt;/p&gt;
&lt;p&gt;如果文件不存在，并且指定了带 BOM 的 UTF-8 或 UTF-16 编码，那么将创建的文件并不是空文件，而是带了对应的 BOM。所以如果要创建一个空文件，可以使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileAppend, , Filename, UTF-8-RAW
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果往标准输出（stdout）写内容，Filename 填写 * 即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileAppend, Text, *
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;FileAppend 命令还有一些其他细节，比如换行符的问题，可以直接参考帮助文档。&lt;/p&gt;
&lt;h3&gt;读取文件&lt;/h3&gt;
&lt;p&gt;读取文件比写入文件复杂。&lt;/p&gt;
&lt;p&gt;FileRead 命令用于读取文件的全部内容（也可用参数指定大小）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileRead, OutputVar, Filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Filename 中可以指定一些参数，用于指定读取内容的大小、指定编码、是否转换换行符等。&lt;/p&gt;
&lt;p&gt;FileReadLine 命令用于读取文件的某一行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;FileReadLine, OutputVar, Filename, LineNum
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除了使用 FileRead 和 FileReadLine 命令，还可以用 Loop, Read 从头一行一行读取文件，效率要比 FileReadLine 高。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop, Read, InputFile [, OutputFile]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;循环中使用 A_LoopReadLine 变量访问读取到的一行内容。如果指定了 OutputFile，那么在循环中用 FileAppend 不指定文件名则会直接写入该文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop, Read, C:\Docs\Address List.txt, C:\Docs\Family Addresses.txt
{
    IfInString, A_LoopReadLine, family, FileAppend, %A_LoopReadLine%`n
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;函数方式&lt;/h2&gt;
&lt;p&gt;这里只简单列出相关函数，细节请参考帮助文档（搜 File object）。&lt;/p&gt;
&lt;h3&gt;打开文件&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;File := FileOpen(Filename, Flags [, Encoding])
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;写入内容&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 写入内容
File.Write(String)
; 按行写入内容
File.WriteLine([String])
; 写入特定类型数据
File.WriteNumType(Num)
; 写入原始格式数据
File.RawWrite(VarOrAddress, Bytes)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;读取内容&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 读取内容
String := File.Read([Characters])
; 读取一行内容
Line := File.ReadLine()
; 读取特定类型数据
Num := File.ReadNumType()
; 读取原始格式数据
File.RawRead(VarOrAddress, Bytes)
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;其他操作&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 移动文件指针
File.Seek(Distance [, Origin = 0])
File.Position := Distance
File.Pos := Distance

; 获取文件指针的当前位置
Pos := File.Tell()
Pos := File.Position
Pos := File.Pos

; 获取和设置文件的大小
FileSize := File.Length
File.Length := NewSize

; 判断文件指针是否到达文件末尾
IsAtEOF := File.AtEOF

; 关闭文件
File.Close()

; 获取或设置文件编码
Encoding := File.Encoding
File.Encoding := Encoding

; 获取文件句柄
File.__Handle
&lt;/pre&gt;&lt;/div&gt;</content></entry><entry><title>[基础] AHK 中 % 符号的用法</title><link href="/ji-chu-ahk-zhong-fu-hao-de-yong-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-fu-hao-de-yong-fa.html</id><summary type="html">&lt;p&gt;AHK 中有一个很特别的符号 %。几乎随便从网上下一段 AHK 代码，就可以看到里边有 % 符号，而且 % 在 AHK 里的用法和所有其他编程语言都不一样，基本靠猜的话是猜不出来的。&lt;/p&gt;
&lt;h2&gt;用法一：%var%&lt;/h2&gt;
&lt;p&gt;第一种用法我们在介绍赋值表达式的时候接触过：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = 123
b = %a%
c = %a%456
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当用 = 对变量赋值时，如果一个字符串被两个 % 包围，并且中间没有空格，那么含义是取这个变量的值。&lt;/p&gt;
&lt;p&gt;在调用一个命令时，也是这样。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = 123
MsgBox, %a%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们这样用，&lt;code&gt;Name, xx, yy&lt;/code&gt;，Name 就是命令；如果我们这样用，&lt;code&gt;Name("xx", "yy")&lt;/code&gt;，Name 就是函数。命令和函数的区别我们也会在之后的文章了解到，现在只需要关注命令即可。&lt;/p&gt;
&lt;p&gt;注意两个%之间只能有一个单独的变量名 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;AHK 中有一个很特别的符号 %。几乎随便从网上下一段 AHK 代码，就可以看到里边有 % 符号，而且 % 在 AHK 里的用法和所有其他编程语言都不一样，基本靠猜的话是猜不出来的。&lt;/p&gt;
&lt;h2&gt;用法一：%var%&lt;/h2&gt;
&lt;p&gt;第一种用法我们在介绍赋值表达式的时候接触过：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = 123
b = %a%
c = %a%456
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当用 = 对变量赋值时，如果一个字符串被两个 % 包围，并且中间没有空格，那么含义是取这个变量的值。&lt;/p&gt;
&lt;p&gt;在调用一个命令时，也是这样。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = 123
MsgBox, %a%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们这样用，&lt;code&gt;Name, xx, yy&lt;/code&gt;，Name 就是命令；如果我们这样用，&lt;code&gt;Name("xx", "yy")&lt;/code&gt;，Name 就是函数。命令和函数的区别我们也会在之后的文章了解到，现在只需要关注命令即可。&lt;/p&gt;
&lt;p&gt;注意两个%之间只能有一个单独的变量名，像 x[1]、x.y、x[y]、fun() 等一概不支持。&lt;/p&gt;
&lt;h2&gt;用法二：% var&lt;/h2&gt;
&lt;p&gt;% 还有另一种用法，这回它只出现一个，并且 % 的后边有至少一个空格。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = 123
b = % a
MsgBox, % a
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样用表示 % 后边的内容按表达式来解析。我们可以认为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;b = %a%
MsgBox, %a%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;b = % a
MsgBox, % a
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;是一样的，实际上后者更强大一些。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 1
b := 2
c := 3

; 计算 a + b + c，结果为 6
MsgBox, % a + b + c

; 语法错误
; MsgBox, %a + b + c%

; 语法正确，但 + 失去计算功能，变成了字符串的一部分
; MsgBox, %a% + %b% + %c%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果 % 后边不只是一个变量名，而是一个表达式，那么“用法二”有效，“用法一”无效。&lt;/p&gt;
&lt;h2&gt;使用“用法一”还是“用法二”&lt;/h2&gt;
&lt;p&gt;我们发现“用法一”和“用法二”的功能上是有重叠的，那么实际情况应该怎么用呢？这个还是因人而异，尽量前后一致即可。但在某些场景“用法一”更方便，某些情况“用法二”更方便，甚至只能用“用法二”。&lt;/p&gt;
&lt;p&gt;“用法一”更方便的场景：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;变量本身包含双引号等特殊字符&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;%a% %b%&amp;quot;&lt;/span&gt;

&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;多行字符串中包含变量&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="n"&gt;xxx&lt;/span&gt;
&lt;span class="nf"&gt;%a&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;
&lt;span class="nf"&gt;%b&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;“用法二”更方便的场景：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 字符串中的变量居多
MsgBox, % a &amp;quot; &amp;quot; b &amp;quot; &amp;quot; c &amp;quot; &amp;quot; d
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只能用“用法二”的场景：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 需要使用表达式
MsgBox, % a + b - c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外如果考虑性能的话，“方法一”是要比“方法二”快二分之一到一倍的，但一般情况瓶颈不应该出现在这里，所以也不用过多在乎性能问题，如果真的是因为在很大的循环里使用而产生性能问题，修改一下也是很轻松的事情。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中关联数组、列表、栈和队列的用法</title><link href="/ji-chu-ahk-zhong-guan-lian-shu-zu-lie-biao-zhan-he-dui-lie-de-yong-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-guan-lian-shu-zu-lie-biao-zhan-he-dui-lie-de-yong-fa.html</id><summary type="html">&lt;p&gt;关联数组就像字典一样，我们可以通过一个键访问它对应的值。比如我可以往一本空字典里添加两个单词，a：一个，good：好，然后我就可以通过 a 访问它对应的解释“一个”，通过 good 访问它对应的解释“好”。普通数组是关联数组的一个子集，它的键是从 1 开始的连续数字。&lt;/p&gt;
&lt;h2&gt;创建&lt;/h2&gt;
&lt;p&gt;创建一个关联数组比较简单，AHK 中的数组实际上使用对象（Object()，也可以用 Array()，二者是一样的）实现的，所以创建数组就是创建一个空对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;array := Object()

Loop, 10
{
    ; 这里键和值都是 A_Index
    array[A_Index] := A_Index
    ; 如果是创建普通数组，也可以直接用 Push 函数
    ; array.Push(A_Index)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果事先已经知道数组的所有元素，也可以直接这样创建：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 不指定键的时候，即创建普通数组，键是 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;关联数组就像字典一样，我们可以通过一个键访问它对应的值。比如我可以往一本空字典里添加两个单词，a：一个，good：好，然后我就可以通过 a 访问它对应的解释“一个”，通过 good 访问它对应的解释“好”。普通数组是关联数组的一个子集，它的键是从 1 开始的连续数字。&lt;/p&gt;
&lt;h2&gt;创建&lt;/h2&gt;
&lt;p&gt;创建一个关联数组比较简单，AHK 中的数组实际上使用对象（Object()，也可以用 Array()，二者是一样的）实现的，所以创建数组就是创建一个空对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;array := Object()

Loop, 10
{
    ; 这里键和值都是 A_Index
    array[A_Index] := A_Index
    ; 如果是创建普通数组，也可以直接用 Push 函数
    ; array.Push(A_Index)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果事先已经知道数组的所有元素，也可以直接这样创建：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 不指定键的时候，即创建普通数组，键是 1 2 3
array1 := [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]
array2 := { &amp;quot;a&amp;quot; : &amp;quot;x&amp;quot;, &amp;quot;b&amp;quot; : &amp;quot;y&amp;quot;}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;访问&lt;/h2&gt;
&lt;p&gt;创建完数组，就可以访问了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 访问数组中键是 5 的值
MsgBox, % array[5]

; 访问数组中键是 &amp;quot;abc&amp;quot; 的值
MsgBox, % array[&amp;quot;abc&amp;quot;]

; 修改 &amp;quot;abc&amp;quot; 键对应的值
array[&amp;quot;abc&amp;quot;] := &amp;quot;def&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以遍历。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for index, element in array
{
    MsgBox, % index &amp;quot; &amp;quot; element
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;更多操作&lt;/h2&gt;
&lt;p&gt;下边列出数组操作相关函数，更多细节请参考帮助文档。&lt;/p&gt;
&lt;p&gt;Push 函数用于在数组的末尾添加元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Object.Push([ Value, Value2, ..., ValueN ])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pop 函数用于取出数组末尾的元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Value := Object.Pop()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;InsertAt 函数用于在数组的指定位置添加元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Object.InsertAt(Pos, Value1 [, Value2, ... ValueN])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;RemoveAt 函数用于删除数组指定位置的元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Object.RemoveAt(Pos [, Length])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Delete 函数用于删除指定键对应的元素。和 RemoveAt 函数的区别是，Delete 函数只是将键对应的值清空，而不会将键也删除。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Object.Delete(Key)
Object.Delete(FirstKey, LastKey)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Length 函数用来获取普通数组的长度。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Length := Object.Length()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;HasKey 函数用来判断数组中是否有对应键。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Object.HasKey(Key)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;MinIndex 函数和 MaxIndex 函数用来返回最小的和最大的键。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MinIndex := Object.MinIndex()
MaxIndex := Object.MaxIndex()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Clone 函数用来返回数组的一个浅拷贝。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Clone := Object.Clone()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;GetCapacity 函数和 SetCapacity 函数用来获取或者调整数组或其中元素占用的内存空间。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MaxItems := Object.GetCapacity()
ByteSize := Object.GetCapacity(Key)

Object.SetCapacity(MaxItems)
Object.SetCapacity(Key, ByteSize)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;GetAddress 函数用来获取键对应元素的地址。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Ptr := Object.GetAddress(Key)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ObjRawSet 函数用来存储或覆盖对象中的一组键值对。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ObjRawSet(Object, Key, Value)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;_NewEnum 函数会返回一个新的计数器，用来枚举数组中的键值对。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Enum := Object._NewEnum()
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;列表、栈、队列&lt;/h2&gt;
&lt;p&gt;通过以上的函数我们发现使用对象可以实现列表、栈和队列。&lt;/p&gt;
&lt;h3&gt;列表&lt;/h3&gt;
&lt;p&gt;列表可以使用Push、Pop、InsertAt、RemoveAt、Length、_NewEnum 等函数实现。&lt;/p&gt;
&lt;p&gt;list.InsertAt 函数和 list.Push 函数用于往列表添加元素，list.RemoveAt 函数和 list.Pop 函数用于从列表取出元素，list.Length() 用于获取列表大小，可以自行维护一个整数作为数组访问的当前位置，或者用 list._NewEnum 函数获取计数器来访问。&lt;/p&gt;
&lt;h3&gt;栈&lt;/h3&gt;
&lt;p&gt;栈可以用 Push、Pop、Length 函数实现。&lt;/p&gt;
&lt;p&gt;stack.Push(element) 用于往栈里添加元素，stack.Pop() 用于从栈里取出元素，stack.Length() 用于获取栈的大小。&lt;/p&gt;
&lt;h3&gt;队列&lt;/h3&gt;
&lt;p&gt;队列可以用 Push、RemoveAt、Length 函数实现。&lt;/p&gt;
&lt;p&gt;queue.Push(element) 用于往队列尾部添加元素，queue.RemoveAt(1) 用于从队列头部取出元素，queue.Length() 用于获取队列大小。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中 = 和 == 等比较运算符的用法</title><link href="/ji-chu-ahk-zhong-he-deng-bi-jiao-yun-suan-fu-de-yong-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-he-deng-bi-jiao-yun-suan-fu-de-yong-fa.html</id><summary type="html">&lt;p&gt;上一篇文章我们了解到了 = 和 := 的区别，也了解了怎样对变量赋值。除了赋值，我们还经常需要比较两个变量的值是否相等，这就需要比较运算符了。&lt;/p&gt;
&lt;p&gt;一翻手册，头疼的事情又来了。其他语言要么用 = 比较，要么用 == 比较，只是习惯的问题。而 AHK 用 = 和 == 都可以比较，而且二者居然还有区别。不过还好区别不是那么大，也并不难理解。&lt;/p&gt;
&lt;h2&gt;大小写问题&lt;/h2&gt;
&lt;p&gt;这里先提下大小写问题，这与 = 和 == 的区别密切相关。AHK 的代码是不区分大小写的，也就是说，在通常情况，将一份不涉及外部交互（如创建目录、写文件、和其他程序交互等）的 AHK 代码中的小写字母全部转换成大写字母，是不影响功能的。所有的关键字、变量名，都是不区分大小写的。但有一些特例，用 == 比较字符串是区分大小写的，以及后边会提到的 StringCaseSense 命令。&lt;/p&gt;
&lt;h2&gt;= 和 == 的区别 …&lt;/h2&gt;</summary><content type="html">&lt;p&gt;上一篇文章我们了解到了 = 和 := 的区别，也了解了怎样对变量赋值。除了赋值，我们还经常需要比较两个变量的值是否相等，这就需要比较运算符了。&lt;/p&gt;
&lt;p&gt;一翻手册，头疼的事情又来了。其他语言要么用 = 比较，要么用 == 比较，只是习惯的问题。而 AHK 用 = 和 == 都可以比较，而且二者居然还有区别。不过还好区别不是那么大，也并不难理解。&lt;/p&gt;
&lt;h2&gt;大小写问题&lt;/h2&gt;
&lt;p&gt;这里先提下大小写问题，这与 = 和 == 的区别密切相关。AHK 的代码是不区分大小写的，也就是说，在通常情况，将一份不涉及外部交互（如创建目录、写文件、和其他程序交互等）的 AHK 代码中的小写字母全部转换成大写字母，是不影响功能的。所有的关键字、变量名，都是不区分大小写的。但有一些特例，用 == 比较字符串是区分大小写的，以及后边会提到的 StringCaseSense 命令。&lt;/p&gt;
&lt;h2&gt;= 和 == 的区别&lt;/h2&gt;
&lt;p&gt;用 = 比较字符串是不区分大小写的，而用 == 比较字符串是区分大小写的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;abc&amp;quot;
b := &amp;quot;ABC&amp;quot;

if (a = b)
{
    ; 条件成立
}

if (a == b)
{
    ; 条件不成立
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;!= 和 &amp;lt;&amp;gt; 的用法&lt;/h2&gt;
&lt;p&gt;如果只考虑 = 和 == 的用法，并没有什么需要注意的，一个不区分大小写，一个区分大小写，根据实际情况选择即可。但有等号，自然就有不等号，考虑到不等号，问题就复杂化了。&lt;/p&gt;
&lt;p&gt;AHK 中的不等号也有两种，!= 和 &amp;lt;&amp;gt;，好在二者是完全相同的，可以根据自己的习惯来使用。但在处理大小写问题上，不等号和等号有着很大的区别。&lt;/p&gt;
&lt;p&gt;我们需要先了解一个命令，StringCaseSense：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StringCaseSense, On|Off|Locale
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;StringCaseSense 用于设置在字符串处理时是否区分大小写。如果设置了 On，就是区分；如果设置了 Off，就是不区分。先不用关注 Locale 参数。默认是 Off。&lt;/p&gt;
&lt;p&gt;注意这个命令不影响 = 和 == 的功能。也就是说即使设置了 StringCaseSense, On，用 = 比较字符串还是不区分大小写的。但影响 != 和 &amp;lt;&amp;gt; 的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;abc&amp;quot;
b := &amp;quot;ABC&amp;quot;

StringCaseSense, On
if (a != b)
{
    ; 条件成立
}

StringCaseSense, Off
if (a != b)
{
    ; 条件不成立
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个也并不难理解，因为通常情况我们无需设置 StringCaseSense，比较的结果都是不区分大小写的。&lt;/p&gt;
&lt;h2&gt;=、==、!=、&amp;lt;&amp;gt; 一起使用&lt;/h2&gt;
&lt;p&gt;既然我们已经分别了解了 =、==、!= 和 &amp;lt;&amp;gt; 的区别，就可以一起使用了。但这里就又一些新的事情需要注意了。&lt;/p&gt;
&lt;p&gt;默认情况，也就是 StringCaseSense, Off 的情况。= 和 != 是对应的，也就是说：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (a = b)
{
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; ! 是逻辑非操作，和很多其他语言一样。
if (!(a != b))
{
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;是一样的。但 StringCaseSense, On 的情况，== 和 != 是对应的。&lt;/p&gt;
&lt;p&gt;也就是说，如果我们在 StringCaseSense, Off 的情况，将 == 和 != 在一起使用，可能会出问题。同理，在 StringCaseSense, On 的情况，将 = 和 != 在一起使用，也可能会出问题。会出什么样的问题呢，举一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StringCaseSense, Off

a := &amp;quot;abc&amp;quot;
b := &amp;quot;ABC&amp;quot;

; 片段一
if (a == b)
{
    ; 做 a
    ; 条件不成立
}
else
{
    ; 做 b
    ; 走此分支
}

; 片段二
if (a != b)
{
    ; 做 b
    ; 条件不成立
}
else
{
    ; 做 a
    ; 走此分支
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们看下里边的片段一和片段二。逻辑看起来好像一样，有人喜欢用等号比较，有人喜欢用不等号比较，这和习惯有关，无可厚非。但我们发现问题来了，这两段看起来一样的代码执行结果完全相反，片段一做了 b，片段二做了 a。如果这个判断很重要，会留下非常大的隐患。&lt;/p&gt;
&lt;p&gt;更要命的是，以上的代码如果设置了 StringCaseSense, On，片段一和片段二是一样的，不存在问题，但后续代码维护者可能因为某些原因，将其改成了 StringCaseSense, Off。改的人可能认为只是把原来的区分大小写改成了不区分大小写，其他地方都不用动，而不会专门把所有的 == 改成 =。而这一改可能就留下了非常严重的 bug，而且通常情况不会触发，只有在比较仅大小写不同的两个字符串时才会触发。&lt;/p&gt;
&lt;h2&gt;注意事项&lt;/h2&gt;
&lt;p&gt;所以，在比较字符串时还是需要留神的。因为通常情况我们无需设置 StringCaseSense，不等号在比较字符串的时候是不区分大小写的。对应地，我们也应该用 = 来比较字符串，以免发生之前描述的问题。如果因为某些情况，我们需要修改之前代码的 StringCaseSense，一定要仔细审视每一处用 = 或者 == 比较字符串的代码，看是否存在问题。必要的话，需要将 = 与 == 互换。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中 = 和 ：= 赋值运算符的用法</title><link href="/ji-chu-ahk-zhong-he-fu-zhi-yun-suan-fu-de-yong-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-he-fu-zhi-yun-suan-fu-de-yong-fa.html</id><summary type="html">&lt;p&gt;在接触一门新的编程语言后，了解如何对变量赋值几乎是第一步。有了变量，才可以对变量进行数学运算或者逻辑判断，将调用函数得到的结果存入变量也需要赋值操作。可见赋值运算符的重要性。&lt;/p&gt;
&lt;p&gt;但很多 AHK 初学者（包括其他编程语言的老手）惊奇地发现 AHK 有两种赋值运算符，= 和 :=，而且它们的用法居然不一样。一时摸不到头脑，甚至对 AHK 顿生反感。当然这不能怪用户，赋值操作如此混乱的语言，恐怕无出其右了。但如果掌握了，也会发现在赋值操作上，AHK 要比其他语言更为灵活和方便。&lt;/p&gt;
&lt;h2&gt;:= 的用法&lt;/h2&gt;
&lt;p&gt;先介绍其中相对好理解的 := 运算符。&lt;/p&gt;
&lt;p&gt;:= 和其他语言的 = 用法基本一致，来看几个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 123
b := 456.789
c := &amp;quot;text&amp;quot;
d := a
e := a . c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到如果将变量赋值成整数、浮点数、字符串，直接写就好了。我们也可以把一个已经存在的变量赋值给一个新变量。这和其他语言中 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;在接触一门新的编程语言后，了解如何对变量赋值几乎是第一步。有了变量，才可以对变量进行数学运算或者逻辑判断，将调用函数得到的结果存入变量也需要赋值操作。可见赋值运算符的重要性。&lt;/p&gt;
&lt;p&gt;但很多 AHK 初学者（包括其他编程语言的老手）惊奇地发现 AHK 有两种赋值运算符，= 和 :=，而且它们的用法居然不一样。一时摸不到头脑，甚至对 AHK 顿生反感。当然这不能怪用户，赋值操作如此混乱的语言，恐怕无出其右了。但如果掌握了，也会发现在赋值操作上，AHK 要比其他语言更为灵活和方便。&lt;/p&gt;
&lt;h2&gt;:= 的用法&lt;/h2&gt;
&lt;p&gt;先介绍其中相对好理解的 := 运算符。&lt;/p&gt;
&lt;p&gt;:= 和其他语言的 = 用法基本一致，来看几个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 123
b := 456.789
c := &amp;quot;text&amp;quot;
d := a
e := a . c
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到如果将变量赋值成整数、浮点数、字符串，直接写就好了。我们也可以把一个已经存在的变量赋值给一个新变量。这和其他语言中 = 的用法并无二致。.（点运算符）用来拼接字符串，这个在后续文章中也会单独介绍。&lt;/p&gt;
&lt;p&gt;如果我们将一个不存在的变量赋值给一个新变量，像这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;f := abc
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么 f 将是一个空字符串，也就是和这样效果一样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;f := &amp;quot;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;= 的用法&lt;/h2&gt;
&lt;p&gt;然后我们再来看 =。&lt;/p&gt;
&lt;p&gt;= 后边的内容全部被认为是字符串，看几个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a = 123
b = 456.789
c = text
d = a
e = %a%
f = %a%456
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意这里边的 a 和 b 已经不是整数和浮点数了，而全是字符串。d 的值也不是 123，而是字符串 a。那么是不是 = 只能用来将一个字符串常量赋值给一个变量呢？如果这样的话，= 基本也没有存在的必要了。我们可以看下 e = %a%，里边有一个奇怪的 % 符号（% 也是 AHK 中的大坑，以后我会专门写文章介绍），%a% 的意思是取 a 变量的值，所以 e 的值是字符串 123，同理 f 的值是字符串 123456。是不是 = 比 := 稍微难理解一些？&lt;/p&gt;
&lt;p&gt;另外 = 还有一些高级用法，比如将多行文本赋值给一个变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a =
(
123
456
789
)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在括号中的多行文本会被赋值给 a，这在某些需要赋值大段文字的场景是非常方便的。&lt;/p&gt;
&lt;p&gt;用 = 赋值空字符串也更加简洁：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a =
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（其实 a := 这样用也是可以的，虽然看起来怪怪的。）&lt;/p&gt;
&lt;p&gt;此外在某些场景只能用 = 赋值，比如上一篇文章中处理命令行参数的场景：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;argc = %0%
argv1 = %1%
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;使用场景&lt;/h2&gt;
&lt;p&gt;既然 = 和 := 在多数情况都可以实现相同的功能，什么场景应该使用 =，什么场景应该使用 := 呢？&lt;/p&gt;
&lt;p&gt;这个并没有明确的规定，可以因人而异，根据自己的习惯来。但尽量前后统一，以免给自己和别人带来麻烦。&lt;/p&gt;
&lt;p&gt;一般来说，使用 := 是更加严谨的，这也是和其他编程语言的用法对齐，更易于被接受。但也并不是弃 = 而不用，在某些场景，比如赋值大段文字，= 还是非常方便的。&lt;/p&gt;
&lt;p&gt;关于 = 的用法，此文只是简单介绍几个例子，还有更多的用法期待大家发掘。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中全局变量、局部变量和静态变量的用法和区别</title><link href="/ji-chu-ahk-zhong-quan-ju-bian-liang-ju-bu-bian-liang-he-jing-tai-bian-liang-de-yong-fa-he-qu-bie.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-quan-ju-bian-liang-ju-bu-bian-liang-he-jing-tai-bian-liang-de-yong-fa-he-qu-bie.html</id><summary type="html">&lt;p&gt;谈到全局变量、局部变量和静态变量，就涉及到两个概念：作用域和生存期。&lt;/p&gt;
&lt;p&gt;这是两个完全不同的概念，虽然很多时候相互关联。作用域是作用在空间上的，比如一个变量在代码的哪些行能访问，哪些行不能访问。而生存期是作用在时间上的，比如一个变量的值在函数返回后是否失效。&lt;/p&gt;
&lt;h2&gt;全局变量&lt;/h2&gt;
&lt;p&gt;全局变量比较好理解，如果一个变量是全局变量，那么程序中的所有代码都可以访问到这个变量（除非存在同名的局部变量或者静态变量）。全局变量用 global 定义。&lt;/p&gt;
&lt;p&gt;看一个例子。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 1
global b := 2
c := 3

fun()

fun()
{
    ; a 不是全局变量，访问不了，弹出空字符串
    MsgBox, % a

    ; b 是全局变量，弹出 2
    MsgBox, % b

    ; 在函数里也可以将 c 变成全局变量
    global c
    ; 弹出 3
    MsgBox, % c …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;谈到全局变量、局部变量和静态变量，就涉及到两个概念：作用域和生存期。&lt;/p&gt;
&lt;p&gt;这是两个完全不同的概念，虽然很多时候相互关联。作用域是作用在空间上的，比如一个变量在代码的哪些行能访问，哪些行不能访问。而生存期是作用在时间上的，比如一个变量的值在函数返回后是否失效。&lt;/p&gt;
&lt;h2&gt;全局变量&lt;/h2&gt;
&lt;p&gt;全局变量比较好理解，如果一个变量是全局变量，那么程序中的所有代码都可以访问到这个变量（除非存在同名的局部变量或者静态变量）。全局变量用 global 定义。&lt;/p&gt;
&lt;p&gt;看一个例子。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := 1
global b := 2
c := 3

fun()

fun()
{
    ; a 不是全局变量，访问不了，弹出空字符串
    MsgBox, % a

    ; b 是全局变量，弹出 2
    MsgBox, % b

    ; 在函数里也可以将 c 变成全局变量
    global c
    ; 弹出 3
    MsgBox, % c
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意代码里的 a 并不是全局变量，虽然它的作用域要比函数里的局部变量要大，在所有文件的函数外都可以访问，但在函数内它是不能被访问到的，这算是一个特例。&lt;/p&gt;
&lt;h2&gt;局部变量&lt;/h2&gt;
&lt;p&gt;在函数里使用的变量通常是局部变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fun()
; a 并不是全局变量，弹出空字符串
MsgBox, % a
; b 是全局变量，弹出 2
MsgBox, % b

fun()
{
    a := 1
    global b := 2
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意这里 b 是在函数里定义的全局变量，但不管是在什么地方定义的，在其他地方都可以访问到。&lt;/p&gt;
&lt;h2&gt;静态变量&lt;/h2&gt;
&lt;p&gt;全局变量和局部变量的作用域和生存期都不一样。全局变量的作用域和生存期都是全局的，局部变量的作用域是在函数内部，生存期是从函数开始执行到函数返回。&lt;/p&gt;
&lt;p&gt;但还有一种比较特别的变量是静态变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 弹出 1 1
fun()
; 弹出 1 2
fun()

fun()
{
    a := 1
    static b := 1
    MsgBox, % a &amp;quot; &amp;quot; b
    a++
    b++
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;a 就是普通的局部变量，因为每次执行 a 都会被初始化为 1，所以两次运行 fun 函数时 a 的值都是 1。但 b 是一个静态变量（使用 static 定义）。静态变量的作用域和局部变量一样，只能在函数内访问。但生存期和全局变量一样，也就是说一个静态变量定义后，它的值会一直有效，即使函数已经返回了。所有第二次运行 fun 函数后，b 的值已经是 2 了。&lt;/p&gt;
&lt;h2&gt;使用场景&lt;/h2&gt;
&lt;p&gt;那么什么分别在什么情况下使用三者呢？&lt;/p&gt;
&lt;p&gt;没有特殊需求的场景，都应该使用局部变量，这也是默认的情况。&lt;/p&gt;
&lt;p&gt;如果一个变量是需要全局有效的，那么使用全局变量。但全局变量会导致代码的耦合度比较高，不方便维护，所以尽量少用。有些看似需要使用全局变量的场景，其实使用函数的参数传递更合理。&lt;/p&gt;
&lt;p&gt;如果某个局部变量需要只初始化一次（一般情况是因为初始化有开销，这是主要的场景），或者需要保留上次运行的结果（这会导致代码容易滋生 bug，并且难于测试，尽量少用），那么需要将这个局部变量修改成静态变量。&lt;/p&gt;
&lt;p&gt;除了全局变量、局部变量、静态变量，还有在类中的变量，这个我会在类中单独讲。&lt;/p&gt;</content></entry><entry><title>[基础] AHK 中循环的基本用法</title><link href="/ji-chu-ahk-zhong-xun-huan-de-ji-ben-yong-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ahk-zhong-xun-huan-de-ji-ben-yong-fa.html</id><summary type="html">&lt;p&gt;在我们重复做一些事情的时候，就需要使用循环了。而 AHK 正是能将复杂的手动工作自动化的工具，循环自然必不可少。但 AHK 中的循环也是多种多样的，我们慢慢道来。&lt;/p&gt;
&lt;h2&gt;最简单的循环&lt;/h2&gt;
&lt;p&gt;最简单的情况，我们知道要循环多少次，比如想连续按下 10 次回车键：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop, 10
{
    Send, {Enter}
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就可以了。在 Loop 后加上要循环的次数，然后大括号里边就是要循环执行的语句。当然我们可以先把循环的次数放进一个变量，这样更灵活些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;count := 10

Loop, %count%
{
    Send, {Enter}
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以在循环体中使用 A_Index 来获取当前循环的次数。&lt;/p&gt;
&lt;p&gt;或者有可能我们想一直循环执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop
{
    Send, {Enter}
    Sleep, 1000
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个就是死循环了，如果脚本不退出就会一直执行，某些情况我们确实需要这样。但更多情况，我们需要在满足某个条件时结束循环：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 这个 stop 变量会在代码的其他地方修改 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;在我们重复做一些事情的时候，就需要使用循环了。而 AHK 正是能将复杂的手动工作自动化的工具，循环自然必不可少。但 AHK 中的循环也是多种多样的，我们慢慢道来。&lt;/p&gt;
&lt;h2&gt;最简单的循环&lt;/h2&gt;
&lt;p&gt;最简单的情况，我们知道要循环多少次，比如想连续按下 10 次回车键：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop, 10
{
    Send, {Enter}
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就可以了。在 Loop 后加上要循环的次数，然后大括号里边就是要循环执行的语句。当然我们可以先把循环的次数放进一个变量，这样更灵活些：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;count := 10

Loop, %count%
{
    Send, {Enter}
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以在循环体中使用 A_Index 来获取当前循环的次数。&lt;/p&gt;
&lt;p&gt;或者有可能我们想一直循环执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop
{
    Send, {Enter}
    Sleep, 1000
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个就是死循环了，如果脚本不退出就会一直执行，某些情况我们确实需要这样。但更多情况，我们需要在满足某个条件时结束循环：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 这个 stop 变量会在代码的其他地方修改，比如在某个定时器里
stop := false

Loop
{
    Send, {Enter}
    Sleep, 1000

    if (stop)
    {
        break
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;break 是用来退出循环的，continue 是用来结束当前循环，进入下一次循环的。这和其他语言都一致。&lt;/p&gt;
&lt;h2&gt;Loop Until 循环&lt;/h2&gt;
&lt;p&gt;上边的最后一种用法，即满足某个条件时结束循环，也可以用 Until 来实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;stop := false

Loop
{
    Send, {Enter}
    Sleep, 1000
}
Until stop
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起来比刚才的要简洁一些。&lt;/p&gt;
&lt;h2&gt;While 循环&lt;/h2&gt;
&lt;p&gt;有些时候我们需要先判断条件，然后再决定是否要循环，这样虽然用 Loop 也能实现，但有些别扭，这时就可以用 While 循环了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;count := 0

while (count &amp;lt; 10)
{
    Send, {Enter}
    Sleep, 1000
    count++
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;count := 0

Loop
{
    if (count &amp;gt;= 10)
    {
        break
    }

    Send, {Enter}
    Sleep, 1000
    count++
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;是等同的，使用哪个就看自己的习惯了。&lt;/p&gt;
&lt;h2&gt;更多内容&lt;/h2&gt;
&lt;p&gt;有些时候我们需要循环读取数组、读取字符串中的子字符串、读取文件内容、遍历目录下的文件甚至遍历注册表等，AHK 中都有很方便的用法，而无需让我们在 Loop 里写复杂的逻辑，我们会在之后的文章中了解到。&lt;/p&gt;</content></entry><entry><title>[基础] 如何用 AHK 处理命令行参数</title><link href="/ji-chu-ru-he-yong-ahk-chu-li-ming-ling-xing-can-shu.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ru-he-yong-ahk-chu-li-ming-ling-xing-can-shu.html</id><summary type="html">&lt;p&gt;写过 C 语言的朋友都清楚 main() 函数可以有两个参数，argc 和 argv，argc 是命令行参数个数，argv 则用于访问具体参数，使用起来非常容易。那么用 AHK 如何访问命令行参数呢？&lt;/p&gt;
&lt;p&gt;官方文档有介绍，但并不是很详细，容易让人看后感觉一头雾水，这里简单整理一下。&lt;/p&gt;
&lt;h2&gt;获取参数的个数&lt;/h2&gt;
&lt;p&gt;要处理参数，得先清楚有没有参数，也就是获取参数的个数。&lt;/p&gt;
&lt;p&gt;%0% 内部变量是用来存放参数个数的，这样可以用 MsgBox 弹出参数个数，是不是很简单？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MsgBox, %0%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但需要注意的时，如果一个变量名是 a，我们可以用 MsgBox, %a% 和 MsgBox, % a 两种方式在 MsgBox 中访问 a。但此时我们不能用 MsgBox, % 0 来访问参数个数，因为这样会直接弹出数字 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;写过 C 语言的朋友都清楚 main() 函数可以有两个参数，argc 和 argv，argc 是命令行参数个数，argv 则用于访问具体参数，使用起来非常容易。那么用 AHK 如何访问命令行参数呢？&lt;/p&gt;
&lt;p&gt;官方文档有介绍，但并不是很详细，容易让人看后感觉一头雾水，这里简单整理一下。&lt;/p&gt;
&lt;h2&gt;获取参数的个数&lt;/h2&gt;
&lt;p&gt;要处理参数，得先清楚有没有参数，也就是获取参数的个数。&lt;/p&gt;
&lt;p&gt;%0% 内部变量是用来存放参数个数的，这样可以用 MsgBox 弹出参数个数，是不是很简单？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MsgBox, %0%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但需要注意的时，如果一个变量名是 a，我们可以用 MsgBox, %a% 和 MsgBox, % a 两种方式在 MsgBox 中访问 a。但此时我们不能用 MsgBox, % 0 来访问参数个数，因为这样会直接弹出数字 0。那么如果我一定要在 MsgBox 的参数前加 % 呢？可以先将 %0% 转存到其他变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 注意这里不能用 :=
argc = %0%
MsgBox, % argc
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样 argc 就和其他变量无异了。&lt;/p&gt;
&lt;p&gt;如果我们想判断命令行参数有多少个，也有两种方式：&lt;/p&gt;
&lt;p&gt;第一种方式，也是官方文档中的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if 0 = 2
{
    MsgBox, 有两个参数
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有些朋友看到这就一头雾水了，0 怎么会等于 2？其实这句 if 判断里，2 确实是数字 2，而 0 并非数字 0，而是 %0% 的值，也就是命令行参数的个数。从这里也可以看出 AHK 语言不严谨的地方。如果实在认为这样判断太违背直觉，无法接受，也可以使用迂回的办法。&lt;/p&gt;
&lt;p&gt;第二种方式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;argc = %0%

if (argc == 2)
{
    MsgBox, 有两个参数
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就正常多了。但需要注意，如下用法是错误的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (%0% == 2)
{
    MsgBox, 有两个参数
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这也是让很多人困惑的地方。毕竟 %0% 是特例，不能像用其他正常变量一样使用，需要特殊记忆一下。&lt;/p&gt;
&lt;h2&gt;获取具体参数&lt;/h2&gt;
&lt;p&gt;当我们知道了参数个数，就可以去读参数的值了，有了刚才的铺垫，这一步也容易很多了。&lt;/p&gt;
&lt;p&gt;%1% 是第一个参数，%2% 是第二个参数，依次类推。而访问 %1% %2% 的方式，和访问 %0% 是一样的。为了不违反直觉，还是建议先将参数转存到一个有意义的变量名，再作处理，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;flag = %1%

if (flag == &amp;quot;-c&amp;quot;)
{
    MsgBox, -c 参数已传入
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;遍历所有参数&lt;/h2&gt;
&lt;p&gt;遍历所有参数是一种常见的处理方法，在 AHK 里也是比较容易的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Loop, %0%
{
    param := %A_Index%
    MsgBox, %param%
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里又有事情需要注意了。这个 Loop 看起来没什么，%0% 就是参数的个数，有几个参数就循环几次，但&lt;code&gt;param := %A_Index%&lt;/code&gt;，这里用的是&lt;code&gt;:=&lt;/code&gt;，而不是&lt;code&gt;=&lt;/code&gt;。这个之前的&lt;code&gt;param = %1%&lt;/code&gt;是不同的。为什么有这样的区别呢？&lt;/p&gt;
&lt;p&gt;A_Index 存放的是一个数字，如果直接用&lt;code&gt;param := A_Index&lt;/code&gt;，那么 param 的值自然也就是数字了，而不是对应的参数。所以需要用&lt;code&gt;%&lt;/code&gt;将这个数字解析成参数。这个用法又和通常的变量有所不同。&lt;/p&gt;
&lt;p&gt;这种用法并非处理命令行参数时的特例，我们可以看下这个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;b&amp;quot;
b := &amp;quot;c&amp;quot;
d := %a%
MsgBox, %d%
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;a 的值是 b，b 的值是 c，&lt;code&gt;d := %a%&lt;/code&gt;中，%a% 的值是 b，所以这里的&lt;code&gt;d := %a%&lt;/code&gt;等同于&lt;code&gt;d := b&lt;/code&gt;，于是 d 的值是 c。也就是可以将变量的值解析成变量名，再去取变量的值，这样的技巧在很多语言里都可以用。&lt;/p&gt;</content></entry><entry><title>[基础] 如何在 AHK 下载网络内容到文件或变量</title><link href="/ji-chu-ru-he-zai-ahk-xia-zai-wang-luo-nei-rong-dao-wen-jian-huo-bian-liang.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ru-he-zai-ahk-xia-zai-wang-luo-nei-rong-dao-wen-jian-huo-bian-liang.html</id><summary type="html">&lt;p&gt;现在早已是网络时代了，完全单机而不需要联网的软件很少了。某些时候，用 AHK 写个脚本也是需要去网络获取数据的。&lt;/p&gt;
&lt;h2&gt;下载网络内容到本地文件&lt;/h2&gt;
&lt;p&gt;有些时候我们需要把一个网页、图片、音频等文件下载到本地，再做后续处理。在其他编程语言可能就比较麻烦了，比如先下载网络内容到一个字符串变量，然后创建一个文件，将字符串写入，再保存文件。而 AHK 内置的 UrlDownloadToFile 命令就是为这个场景量身定做的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UrlDownloadToFile, URL, Filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，这个命令的用法非常简单，第一个参数是文件的网络地址，第二个参数是文件的本地地址。如果第二个参数不是完整路径，文件会被下载到当前脚本的工作目录，一般情况就是脚本自身的目录。&lt;/p&gt;
&lt;p&gt;比如我想下载 AHK 官网的 Logo 图片到 C:\test.png，就可以这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UrlDownloadToFile, http://ahkscript.org/logos/ahk_logo.png, C:\test.png …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;现在早已是网络时代了，完全单机而不需要联网的软件很少了。某些时候，用 AHK 写个脚本也是需要去网络获取数据的。&lt;/p&gt;
&lt;h2&gt;下载网络内容到本地文件&lt;/h2&gt;
&lt;p&gt;有些时候我们需要把一个网页、图片、音频等文件下载到本地，再做后续处理。在其他编程语言可能就比较麻烦了，比如先下载网络内容到一个字符串变量，然后创建一个文件，将字符串写入，再保存文件。而 AHK 内置的 UrlDownloadToFile 命令就是为这个场景量身定做的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UrlDownloadToFile, URL, Filename
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，这个命令的用法非常简单，第一个参数是文件的网络地址，第二个参数是文件的本地地址。如果第二个参数不是完整路径，文件会被下载到当前脚本的工作目录，一般情况就是脚本自身的目录。&lt;/p&gt;
&lt;p&gt;比如我想下载 AHK 官网的 Logo 图片到 C:\test.png，就可以这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UrlDownloadToFile, http://ahkscript.org/logos/ahk_logo.png, C:\test.png
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;是不是非常简单。除了 HTTP，UrlDownloadToFile 还支持 HTTPS 和 FTP 协议。&lt;/p&gt;
&lt;h2&gt;下载网络内容到字符串变量&lt;/h2&gt;
&lt;p&gt;但有些情况，我们并不需要将网络内容保存到文件里，而是直接使用，比如直接显示在控件里。虽然也可以先写到文件再读出来，但这样做不仅多此一举，有额外的开销，还需要考虑共用临时文件、临时文件没被删除等问题。&lt;/p&gt;
&lt;p&gt;AHK 并没有命令可以直接将网络内容下载到字符串变量，但可以使用 COM 对象 WinHttp.WinHttpRequest.5.1，官方文档中有一个例子，用起来倒也不是很麻烦。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;whr := ComObjCreate(&amp;quot;WinHttp.WinHttpRequest.5.1&amp;quot;)
; Open() 的第三个参数代表同步或者异步，现在不用过多关注，true 就可以了
; 以后我们会仔细了解同步和异步
whr.Open(&amp;quot;GET&amp;quot;, &amp;quot;https://autohotkey.com/download/1.1/version.txt&amp;quot;, true)
whr.Send()
whr.WaitForResponse()
version := whr.ResponseText
MsgBox, % version
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就可以用 MsgBox 将从网络获取到的一个字符串弹出来了。但比起 UrlDownloadToFile 还是麻烦了不少，如果需要经常使用，还是很不方便的，这就需要封装成一个函数来使用，比如这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UrlDownloadToVar(url)
{
    static whr := ComObjCreate(&amp;quot;WinHttp.WinHttpRequest.5.1&amp;quot;)
    whr.Open(&amp;quot;GET&amp;quot;, url, true)
    whr.Send()
    whr.WaitForResponse()
    return whr.ResponseText
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和刚才的代码差不多，但我这里 whr 是 static 类型的，因为只需要初始化一次就可以了，调用 ComObjCreate() 是有开销的。&lt;/p&gt;
&lt;p&gt;但有些时候我们并不只需要传入一个 URL，可以还包含一些 HTTP Headers，而且使用 POST 方式访问，这就需要再改造下这个函数，比如这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;UrlDownloadToVar(url, headers = &amp;quot;&amp;quot;)
{
    static whr := ComObjCreate(&amp;quot;WinHttp.WinHttpRequest.5.1&amp;quot;)
    whr.Open(&amp;quot;POST&amp;quot;, url, true)

    if (headers != &amp;quot;&amp;quot;)
    {
        for key, value in headers
        {
            whr.SetRequestHeader(key, value)
        }
    }

    whr.Send()
    whr.WaitForResponse()
    return whr.ResponseText
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用起来也很方便，比如我要使用 POST 方式访问 test.org，携带两个 HTTP Headers，key1:value1 和 key2:value2：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;result := UrlDownloadToVar(&amp;quot;http://test.org&amp;quot;
    , { &amp;quot;key1&amp;quot; : &amp;quot;value1&amp;quot;, &amp;quot;key2&amp;quot; : &amp;quot;value2&amp;quot; })
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果需要设置更多参数，比如超时时间，就需要查下 WinHttp.WinHttpRequest.5.1 的文档了，基本上都可以找到自己想要的功能。&lt;/p&gt;</content></entry><entry><title>[基础] 如何在 AHK 中判断空字符串</title><link href="/ji-chu-ru-he-zai-ahk-zhong-pan-duan-kong-zi-fu-chuan.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ru-he-zai-ahk-zhong-pan-duan-kong-zi-fu-chuan.html</id><summary type="html">&lt;p&gt;上一篇文章我们了解到了如何在 AHK 中比较字符串，但有一个细节我故意忽略了，也就是如何判断一个字符串是否为空（或者说一个变量是否为空，AHK 中空变量、空字符串和未定义变量是一回事）。按理说这应该是一个很简单的问题，一笔带过即可，无需单独写一篇文章来介绍。对其他语言也许是这样，但 AHK 在这个问题上存在一些麻烦，值得一提。&lt;/p&gt;
&lt;h2&gt;常规的字符串判空&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;&amp;quot;

; 方法一：
; = 也可替换成 ==，因为空字符串无大小写问题，不赘述
if (a = &amp;quot;&amp;quot;)
{
    ; 条件成立
}

; 方法二：
if (a)
{
    ; 做正常的事情
}
else
{
    ; 条件成立
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法一就是其他编程语言中的方法，无需过多解释。方法二是一种简化的写法，在多数情况看起来也是正常的，但存在一些特殊情况。&lt;/p&gt;
&lt;h2&gt;特殊情况一：数字 0&lt;/h2&gt;
&lt;p&gt;在一些特殊情况，方法二存在问题。&lt;/p&gt;
&lt;p&gt;如果变量为字符串 "0"，或者整数 0，或者浮点数 0.0：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;上一篇文章我们了解到了如何在 AHK 中比较字符串，但有一个细节我故意忽略了，也就是如何判断一个字符串是否为空（或者说一个变量是否为空，AHK 中空变量、空字符串和未定义变量是一回事）。按理说这应该是一个很简单的问题，一笔带过即可，无需单独写一篇文章来介绍。对其他语言也许是这样，但 AHK 在这个问题上存在一些麻烦，值得一提。&lt;/p&gt;
&lt;h2&gt;常规的字符串判空&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;&amp;quot;

; 方法一：
; = 也可替换成 ==，因为空字符串无大小写问题，不赘述
if (a = &amp;quot;&amp;quot;)
{
    ; 条件成立
}

; 方法二：
if (a)
{
    ; 做正常的事情
}
else
{
    ; 条件成立
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法一就是其他编程语言中的方法，无需过多解释。方法二是一种简化的写法，在多数情况看起来也是正常的，但存在一些特殊情况。&lt;/p&gt;
&lt;h2&gt;特殊情况一：数字 0&lt;/h2&gt;
&lt;p&gt;在一些特殊情况，方法二存在问题。&lt;/p&gt;
&lt;p&gt;如果变量为字符串 "0"，或者整数 0，或者浮点数 0.0：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := &amp;quot;0&amp;quot;
; 或者
; a := 0
; 或者
; a := 0.0

; 方法一：
; = 也可替换成 ==，因为空字符串无大小写问题，不赘述
if (a = &amp;quot;&amp;quot;)
{
    ; 条件不成立
}

; 方法二：
if (a)
{
    ; 做正常的事情
}
else
{
    ; 条件成立，判断错误
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;恐怕没有人认为一个长度为一的字符串 "0" 是空字符串。但第二种方法给出了错误的结果。原因是 0 被认为是布尔值 false，而且 AHK 中的字符串和数字并没有那么确切的区别，很多情况可以自动相互转换，直接用 if 判断自然不通过，看来这个简化还是要不得。&lt;/p&gt;
&lt;h2&gt;特殊情况二：Object()&lt;/h2&gt;
&lt;p&gt;还有一种特殊情况是空对象 Object()。通常来说，我们不应该认为 Object() 是空变量，但某些库的作者可能不严谨，在本应返回空变量的地方返回了 Object()（我印象中遇到过这样的问题，但今天没有复现出来，如果以后发现了再举例）。如果用方法一判断，就可能出问题。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;a := Object()

; 方法一
; = 也可替换成 ==，因为空字符串无大小写问题，不赘述
if (a = &amp;quot;&amp;quot;)
{
    ; 条件不成立
}

; 方法三
if (StrLen(a) = 0)
{
    ; 条件成立
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;方法一认为 Object() 不是空变量，那么继续将 a 传递下去处理，就可能出问题。方法三是调用 StrLen() 函数来检查字符串的长度，它成功发现了这不是一个有效的字符串。&lt;/p&gt;
&lt;p&gt;但用 StrLen() 函数判断也存在问题，一个很严重的问题是方法三的耗时要比方法一长一倍以上。因为调用函数需要一些额外开销，在几乎所有语言都是如此。如果这个判断在一个很大的循环里边，额外的开销是很大的。&lt;/p&gt;
&lt;p&gt;另外 Object() 是否算空变量或者空字符串，这其实是有争议的。我个人是认为不应该算，但在某些语言中，所有变量类型都是从 Object 类型继承来的，那么就应该算。在用一些库时，还是需要验证一下是否存在 Object() 的问题，以免以后出了问题没有头绪。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;通常情况，用方法一判断空字符串或者空变量就足够了，简单易懂。在某些特殊情况，可能需要用方法三来判断，但要付出额外的开销。另外本文可能还有一些细节没有提到，我想起来后再补充。&lt;/p&gt;</content></entry><entry><title>[基础] 如何在 AHK 中运行其他软件</title><link href="/ji-chu-ru-he-zai-ahk-zhong-yun-xing-qi-ta-ruan-jian.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/ji-chu-ru-he-zai-ahk-zhong-yun-xing-qi-ta-ruan-jian.html</id><summary type="html">&lt;p&gt;前几篇文章讲的都是 AHK 的语法，比较枯燥，这篇文章的内容更实用一些。很多情况我们使用 AHK，并不是为了写一个功能完备软件，而是写一个简单的脚本来和其他软件交互，这就涉及到如何在 AHK 中运行其他软件。本文重点讲 Run 命令的基本用法，其他高级内容之后的文章会依次提及。&lt;/p&gt;
&lt;h2&gt;启动软件&lt;/h2&gt;
&lt;p&gt;使用 AHK 的经典场景，就是用一个热键启动一个软件，比如用 Win + n 启动记事本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#n::
    Run, notepad
return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里就不详细讲绑定热键的语法了，因为相关资料特别多，而且我以后会单独介绍热键相关的内容。重点看 Run, notepad，这条语句就是启动记事本，因为记事本软件的文件名是 notepad.exe，是不是非常简单。但 Run 命令也并非简单到只支持一个参数，它的用法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, Target [, WorkingDir, Max|Min|Hide …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;前几篇文章讲的都是 AHK 的语法，比较枯燥，这篇文章的内容更实用一些。很多情况我们使用 AHK，并不是为了写一个功能完备软件，而是写一个简单的脚本来和其他软件交互，这就涉及到如何在 AHK 中运行其他软件。本文重点讲 Run 命令的基本用法，其他高级内容之后的文章会依次提及。&lt;/p&gt;
&lt;h2&gt;启动软件&lt;/h2&gt;
&lt;p&gt;使用 AHK 的经典场景，就是用一个热键启动一个软件，比如用 Win + n 启动记事本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#n::
    Run, notepad
return
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里就不详细讲绑定热键的语法了，因为相关资料特别多，而且我以后会单独介绍热键相关的内容。重点看 Run, notepad，这条语句就是启动记事本，因为记事本软件的文件名是 notepad.exe，是不是非常简单。但 Run 命令也并非简单到只支持一个参数，它的用法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, Target [, WorkingDir, Max|Min|Hide|UseErrorLevel, OutputVarPID]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Target 可以是可执行文件的文件名，如上边的 notepad，可以加参数，也可以是一些其他东西，后文会具体讲到。WorkingDir 用来指定工作目录，比如我想在 C 盘根目录运行记事本并打开 test.txt，就可以这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, notepad test.txt, C:\
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第三个参数 Max|Min|Hide|UseErrorLevel 是选项，可以让运行的软件最大化（Max），最小化（Min），隐藏（Hide），UseErrorLevel 用于获取进程退出的返回码，暂时用不到，以后再讲。&lt;/p&gt;
&lt;p&gt;第四个参数 OutputVarPID 用来获取进程的 PID，暂时也用不到。&lt;/p&gt;
&lt;p&gt;需要注意的一点，用 Run 启动其他软件后，AHK 代码会继续执行，而不会等软件退出。如果需要等软件退出再继续运行，需要用 RunWait 命令，这个后续我也会提到。&lt;/p&gt;
&lt;h2&gt;打开网址&lt;/h2&gt;
&lt;p&gt;Run 后边除了加可执行文件，还可以直接加网址，这样就不要到处找浏览器的安装位置了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 网址前边需要加 http:// 或 https://，以便让 AHK 知道这是一个网址
Run, https://autohotkey.com
; 如果网址是以 www. 开头的，也可以省略 http:// 或 https://
Run, www.autohotkey.com
; 错误用法，AHK 会尝试在本地找 autohotkey.com 文件，如果找不到就会报错
Run, autohotkey.com
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;其他用法&lt;/h2&gt;
&lt;p&gt;除了启动进程和打开网址，Run 还有一些其他用法。&lt;/p&gt;
&lt;p&gt;打开文件。当 Run 后边直接接非可执行文件时，效果也是打开文件。打开文件所使用的软件，是在资源管理器关联的默认软件，可以在资源管理器中选定文件，右键菜单-&amp;gt;属性 里更改打开方式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, open C:\test.txt
; open 可以省略
Run, C:\test.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编辑文件。效果同在资源管理器选定文件，右键菜单-&amp;gt;编辑，通常是用记事本打开。如果右键菜单里没有“编辑”菜单项，会报错。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, edit C:\test.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用资源管理器打开文件夹，需要加文件夹的路径。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, explore C:\
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看文件属性，效果同在资源管理器选定文件，右键菜单-&amp;gt;属性。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, properties C:\test.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用资源管理器打开文件夹，并进入搜索模式，以便查找文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, find C:\
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打印文件，效果同在资源管理器选定文件，右键菜单-&amp;gt;打印，如果无“打印”菜单项，会报错。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, print C:\test.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用资源管理器打开 CLSID 文件夹，CLSID 文件夹是由系统定义的一批特殊文件夹，名字是一串“神秘数字”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;; 打开我的文档文件夹
Run, ::{450d8fba-ad25-11d0-98a8-0800361b1103}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;常用 CLSID 文件夹列表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;CLSID&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td 20d04fe0-3aea-1069-a2d8-08002b30309d&gt;::&lt;/td&gt;
&lt;td&gt;我的电脑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td 450d8fba-ad25-11d0-98a8-0800361b1103&gt;::&lt;/td&gt;
&lt;td&gt;我的文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td 645ff040-5081-101b-9f08-00aa002f954e&gt;::&lt;/td&gt;
&lt;td&gt;回收站&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td 208d2c60-3aea-1069-a2d7-08002b30309d&gt;::&lt;/td&gt;
&lt;td&gt;网上邻居&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td 7007acc7-3202-11d1-aad2-00805fc1270e&gt;::&lt;/td&gt;
&lt;td&gt;网络连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td 2227a280-3aea-1069-a2de-08002b30309d&gt;::&lt;/td&gt;
&lt;td&gt;打印机和传真&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;关于空格和引号&lt;/h2&gt;
&lt;p&gt;如果文件名、路径名或者参数中包含空格，是需要特别注意的。&lt;/p&gt;
&lt;p&gt;Run 后边加的文件路径是可以包含空格的，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, c:\Program Files\Oracle\VirtualBox\VirtualBox.exe
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Program Files 里包含一个空格，但 Run 不会将 c:\Program 视为文件名，将 Files\Oracle\VirtualBox\VirtualBox.exe 视为参数。但如果之后再加参数就要小心了，谨慎起见，需要对每一个参数单独加上双引号。&lt;/p&gt;
&lt;p&gt;虽然在某些情况不加也可以工作，比如这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, notepad aa bb.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会用记事本打开一个名为 aa bb.txt 的文件。&lt;/p&gt;
&lt;p&gt;但也可能出问题，比如这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, c:\mine\app\AutoHotkey\AutoHotkey.exe aa bb.ahk
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;AutoHotkey.exe 提示 aa 文件不存在，而实际我想运行的文件为 aa bb.ahk。同样的语法，效果却不同，区别在于要运行的软件是如何解析参数的。&lt;/p&gt;
&lt;p&gt;如果在参数两边加上引号，就没有这样的问题了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Run, notepad &amp;quot;aa bb.txt&amp;quot;

Run, c:\mine\app\AutoHotkey\AutoHotkey.exe &amp;quot;aa bb.ahk&amp;quot;

; 后边可以再加参数，但包含空格的参数都要有引号。
Run, c:\mine\app\AutoHotkey\AutoHotkey.exe &amp;quot;aa bb.ahk&amp;quot; &amp;quot;arg 1&amp;quot; &amp;quot;arg 2&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;等待软件退出再继续运行&lt;/h2&gt;
&lt;p&gt;用 Run 命令启动软件的话，AHK 并不会等软件退出后才继续运行，在运行图形界面软件时，这也是我们通常的做法。如果我们需要让 AHK 暂停，直到运行起来的软件退出才继续，可以用 RunWait 命令取代 Run，除了这个区别，用法上和 Run 是一致的。&lt;/p&gt;
&lt;h2&gt;其他内容&lt;/h2&gt;
&lt;p&gt;除了将软件运行起来，很多时候我们也有一些其他需求。比如获取软件的输出（通常是命令行软件的输出，如 ipconfig），获取软件的退出码，获取软件进程的 PID 等等，我会在后续文章中详细讲到。&lt;/p&gt;</content></entry></feed>