<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>陌辞寒 - IT</title><link href="/" rel="alternate"></link><link href="/feeds/it.atom.xml" rel="self"></link><id>/</id><updated>2017-09-18T20:29:00+08:00</updated><entry><title>Apache Drill 学习笔记二：Dremel 原理</title><link href="/apache-drill-xue-xi-bi-ji-er-dremel-yuan-li.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/apache-drill-xue-xi-bi-ji-er-dremel-yuan-li.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;《Apache Drill学习笔记一：环境搭建和简单试用》提到过Apache Drill是受Google的Dremel系统启发而设计实现的，这出于Google公开于2010年的论文“&lt;a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36632.pdf"&gt;Dremel Interactive Analysis of WebScaleDatasets&lt;/a&gt;”。为了弄清楚Apache Drill的运行机制，这篇论文是一定要先仔细研读的，否则就只能像我之前那样仅仅将其作为CSV或者JSON的SQL查询工具使用了，而不能真正发挥其强大的性能优势。&lt;/p&gt;
&lt;p&gt;简单说Dremel是Google的“交互式”数据分析系统，可以组建成规模上千的集群，处理PB级别的数据。虽然MapReduce也可以处理这样规模的数据，但它所需要的时间相对比较长，适合数据的批处理，而不适合交互式查询的场景，Dremel正是这样的一个有力补充。&lt;/p&gt;
&lt;p&gt;Dremel有2个显著特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可以在秒级别的时间查询PB级别的数据。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据模型是嵌套(nested)的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这正是其他数据库、查询引擎的痛点所在，也正是我们需要着重了解的地方。&lt;/p&gt;
&lt;h2&gt;数据模型&lt;/h2&gt;
&lt;p&gt;Dremel使用的数据就是我们熟悉的Protocol Buffer格式，但通常情况我们都是作为序列化方法或者在RPC中传输等场景使用，较少用它来存放大量数据。对于没有接触过Protocol Buffer的读者，可以用JSON类比，二者结构很相似，一个不同是Protocol Buffer不支持JSON的map（或者说是dict、hashmap）。&lt;/p&gt;
&lt;p&gt;一个Protocol Buffer的 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;《Apache Drill学习笔记一：环境搭建和简单试用》提到过Apache Drill是受Google的Dremel系统启发而设计实现的，这出于Google公开于2010年的论文“&lt;a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36632.pdf"&gt;Dremel Interactive Analysis of WebScaleDatasets&lt;/a&gt;”。为了弄清楚Apache Drill的运行机制，这篇论文是一定要先仔细研读的，否则就只能像我之前那样仅仅将其作为CSV或者JSON的SQL查询工具使用了，而不能真正发挥其强大的性能优势。&lt;/p&gt;
&lt;p&gt;简单说Dremel是Google的“交互式”数据分析系统，可以组建成规模上千的集群，处理PB级别的数据。虽然MapReduce也可以处理这样规模的数据，但它所需要的时间相对比较长，适合数据的批处理，而不适合交互式查询的场景，Dremel正是这样的一个有力补充。&lt;/p&gt;
&lt;p&gt;Dremel有2个显著特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可以在秒级别的时间查询PB级别的数据。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据模型是嵌套(nested)的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而这正是其他数据库、查询引擎的痛点所在，也正是我们需要着重了解的地方。&lt;/p&gt;
&lt;h2&gt;数据模型&lt;/h2&gt;
&lt;p&gt;Dremel使用的数据就是我们熟悉的Protocol Buffer格式，但通常情况我们都是作为序列化方法或者在RPC中传输等场景使用，较少用它来存放大量数据。对于没有接触过Protocol Buffer的读者，可以用JSON类比，二者结构很相似，一个不同是Protocol Buffer不支持JSON的map（或者说是dict、hashmap）。&lt;/p&gt;
&lt;p&gt;一个Protocol Buffer的&lt;code&gt;Document.proto&lt;/code&gt;文件示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="no"&gt;Document&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;DocId&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="no"&gt;Links&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;Backward&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;Forward&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="no"&gt;Name&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="no"&gt;Language&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Country&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Url&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意的不是数据本身，而是数据的类型，或者说是数据的schema。但从中已经可以看出2个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型是可以嵌套的。&lt;/li&gt;
&lt;li&gt;同一种类型的数据是可以重复（repeated）和可选（optional）的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对如此复杂的数据做SQL查询看起来是很让人头疼的，我们自然想到先简化一下，从最简单的情况考虑。&lt;/p&gt;
&lt;p&gt;这种数据格式用数学方法严格表示是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dom&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="ss"&gt;A1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;[*|&lt;/span&gt;&lt;span class="sc"&gt;?]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;An&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;[*|&lt;/span&gt;&lt;span class="sc"&gt;?]&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起来有点复杂，但理解起来很容易。t（原文是希腊字母τ，但为了书写方便这里改成英文字母t）是一个数据类型的定义，而.proto文件就是定义一个或多个数据类型。t有两种可能（|和c语言一样是“或”的意思，一种是基本类型dom（如int、string、float等），另一种是使用递归方式定义的，即t可以由其他之前定义好的t组成，就像c中的结构体一样，与结构体不大相同的是，每个包含的t的值可以有多个（*，repeated，类似c中的数组），还可以是可选的（?，optional，之前那个数组可以不包含任何元素）。A1-An是这些t的命名（也就是A1是某个t类型的变量）。其实从这个定义中更容易看出之前总结的2个特点。&lt;/p&gt;
&lt;h2&gt;简单情况&lt;/h2&gt;
&lt;p&gt;现在我们来考虑简单的Protocol Buffer数据，以及如何查询。&lt;/p&gt;
&lt;p&gt;这是一个简化的&lt;code&gt;Document.proto&lt;/code&gt;，可以看到它只有一层结构，而且没有&lt;code&gt;repeated&lt;/code&gt;和&lt;code&gt;optional&lt;/code&gt;字段。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="no"&gt;Document&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;DocId&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Url&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Country&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;Code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而&lt;code&gt;Document&lt;/code&gt;的数据就是一张普通的二维表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;DocId&lt;/th&gt;
&lt;th&gt;Url&lt;/th&gt;
&lt;th&gt;Country&lt;/th&gt;
&lt;th&gt;Code&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10001&lt;/td&gt;
&lt;td&gt;http://1&lt;/td&gt;
&lt;td&gt;America&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10002&lt;/td&gt;
&lt;td&gt;http://2&lt;/td&gt;
&lt;td&gt;America&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10003&lt;/td&gt;
&lt;td&gt;http://3&lt;/td&gt;
&lt;td&gt;China&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10004&lt;/td&gt;
&lt;td&gt;http://4&lt;/td&gt;
&lt;td&gt;America&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10005&lt;/td&gt;
&lt;td&gt;http://5&lt;/td&gt;
&lt;td&gt;Japan&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10006&lt;/td&gt;
&lt;td&gt;http://6&lt;/td&gt;
&lt;td&gt;America&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出我们用二维的方式组织数据，但实际是数据在磁盘的地址是一维的，也就是我们需要按某种方式把它拼接成一维的数据。那最基本的方式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按行存：&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;10001&lt;/th&gt;
&lt;th&gt;http://1&lt;/th&gt;
&lt;th&gt;America&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;10002&lt;/th&gt;
&lt;th&gt;http://2&lt;/th&gt;
&lt;th&gt;America&lt;/th&gt;
&lt;th&gt;20&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;按列存：&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;10001&lt;/th&gt;
&lt;th&gt;10002&lt;/th&gt;
&lt;th&gt;1003&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;th&gt;http://1&lt;/th&gt;
&lt;th&gt;http://2&lt;/th&gt;
&lt;th&gt;http://3&lt;/th&gt;
&lt;th&gt;...&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们先考虑下对这个表进行&lt;code&gt;select&lt;/code&gt;，如&lt;code&gt;select Url, Code from Document;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果是按行存的话，每读一个&lt;code&gt;Url&lt;/code&gt;后，都需要跳到下一个&lt;code&gt;Url&lt;/code&gt;的位置，所有要查出的字段都不是连续存放的。而且因为有字符串这样的非定长字段（如果使用定长的预留空间，又会造成大量的空间浪费），不能通过简单计算就可以得到地址，查起来非常痛苦，效率自然不会很高。&lt;/p&gt;
&lt;p&gt;而按列存的情况就好很多，只需要找到第一个&lt;code&gt;Url&lt;/code&gt;和第一个&lt;code&gt;Code&lt;/code&gt;的首地址，然后顺序读取到结尾即可。不仅实现简单，而且磁盘顺序读取好比随机读取要快，加上更容易优化（比如把临近地址的数据预读到内存，连续的同类型数据更容易压缩存放），效率自然不可同日而语。&lt;/p&gt;
&lt;p&gt;那是不是所有情况都需要按列来存数据呢？显然不是。虽然按列读的情况比较多，但写入一般是按行写的，无论是追加、删除、修改，一般都是按行处理的。数据按列存的话，追加时需要把一行数据按字段拆开，分别插入到不同的地方，删除也是一样，修改更加痛苦。因为如果是类似字符串的不定长字段，按行存的话可以以&lt;strong&gt;行&lt;/strong&gt;为单位预留空间，而按列存的话需要以&lt;strong&gt;字段&lt;/strong&gt;为单位预留空间，或者使用更复杂的方法。想一想就要麻烦许多。&lt;/p&gt;
&lt;p&gt;数据库往往需要同时照顾到读和写的效率，简单的按行存或者按列存都存在明显的问题（包括下文提到的表join效率等问题），所以往往需要存储复杂的meta数据、添加各类索引、使用各种树型甚至图型结构，来在读和写之间谋得一个平衡点。&lt;/p&gt;
&lt;p&gt;而Dremel要轻松一些，因为它被设计成一个查询引擎，即使也有写入功能也不会过多考虑写入的效率，那么显然按列存是合适的。这样即使一张表字段很多，数据量很大，只要记录每个字段的类型以及对应数据的起始地址等少量信息，查起来就游刃有余。所以如果只是用来查一个巨大的二维表的后，并不是很难。&lt;/p&gt;
&lt;p&gt;但我们知道，平时使用的数据很难在一张二维表里表达清楚，往往需要多张表，互相还有关联，查询起来就需要各种join。数据量小还好，数据量一大，join效率直线下降，单表select再快也没用，这才是真正棘手的问题。&lt;/p&gt;
&lt;h2&gt;有嵌套数据的情况&lt;/h2&gt;
&lt;p&gt;Dremel的解决方法不是设法提高join的效率，而是换一种思路，使用嵌套的数据解决简单二维表表达能力太弱的缺点。&lt;/p&gt;
&lt;p&gt;再拿出之前的&lt;code&gt;Document.proto&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="no"&gt;Document&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;DocId&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="no"&gt;Links&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;Backward&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;int64&lt;/span&gt; &lt;span class="no"&gt;Forward&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="no"&gt;Name&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;group&lt;/span&gt; &lt;span class="no"&gt;Language&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Code&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Country&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="no"&gt;Url&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的数据如果用二维表来存放一般需要多张才能描述清楚，处理重复字段也比较痛苦，而一个Protocol Buffer类型就可以描述，但在磁盘的实际存放还是要动不少脑筋的。&lt;/p&gt;
&lt;p&gt;现在就需要搬出论文里的这张图了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="record-wise-vs-columnar-representation-of-nested-data" src="/images/015.png"&gt;&lt;/p&gt;
&lt;p&gt;虽然嵌套的数据比之前的二维表更加复杂，还是有按行存和按列存两种基本方法，而且正如我们之前提到的，为了查询效率，我们采用按列存的方法（图中的&lt;code&gt;column-oriented&lt;/code&gt;）。我们重点关注A、B、C、D、E这些树型关系如何存储。&lt;/p&gt;
&lt;p&gt;我们来准备一些符合&lt;code&gt;Document.proto&lt;/code&gt;的简单的数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ss"&gt;DocId&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="no"&gt;Links&lt;/span&gt;
    &lt;span class="ss"&gt;Forward&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;
    &lt;span class="ss"&gt;Forward&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;
    &lt;span class="ss"&gt;Forward&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;60&lt;/span&gt;
&lt;span class="no"&gt;Name&lt;/span&gt;
    &lt;span class="no"&gt;Language&lt;/span&gt;
        &lt;span class="ss"&gt;Code&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;en-us&amp;#39;&lt;/span&gt;
        &lt;span class="ss"&gt;Country&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;us&amp;#39;&lt;/span&gt;
    &lt;span class="no"&gt;Language&lt;/span&gt;
        &lt;span class="ss"&gt;Code&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;en&amp;#39;&lt;/span&gt;
        &lt;span class="ss"&gt;Url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;http://A&amp;#39;&lt;/span&gt;
&lt;span class="no"&gt;Name&lt;/span&gt;
    &lt;span class="ss"&gt;Url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;http://B&amp;#39;&lt;/span&gt;
&lt;span class="no"&gt;Name&lt;/span&gt;
    &lt;span class="no"&gt;Language&lt;/span&gt;
        &lt;span class="ss"&gt;Code&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;en-gb&amp;#39;&lt;/span&gt;
        &lt;span class="ss"&gt;Country&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;gb&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ss"&gt;DocId&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;
&lt;span class="no"&gt;Links&lt;/span&gt;
    &lt;span class="ss"&gt;Backward&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
    &lt;span class="ss"&gt;Backward&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;
    &lt;span class="ss"&gt;Forward&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt;
&lt;span class="no"&gt;Name&lt;/span&gt;
    &lt;span class="ss"&gt;Url&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;http://C&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;code&gt;DocId: 10&lt;/code&gt;和&lt;code&gt;DocId: 20&lt;/code&gt;是两个&lt;code&gt;Document&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Dremel是这样拆解数据的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="record-wise-vs-columnar-representation-of-nested-data" src="/images/016.png"&gt;&lt;/p&gt;
&lt;p&gt;可以看出每个需要存放实际数据的叶子节点都变成了一张二维表，但表中除了字段自身的值。如果是&lt;code&gt;repeated&lt;/code&gt;字段，则在表中增添行；如果是&lt;code&gt;optional&lt;/code&gt;字段，并且数据中不填充，则用&lt;code&gt;NULL&lt;/code&gt;代替（而不是去掉这一行）。但还出现了&lt;code&gt;r&lt;/code&gt;和&lt;code&gt;d&lt;/code&gt;，这两个又是什么东西，而且为何要记录&lt;code&gt;NULL&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;试想如果去掉上图中&lt;code&gt;r&lt;/code&gt;和&lt;code&gt;d&lt;/code&gt;两列，则每个二维表都变成了一个一维表（list），那么我们试图把数据还原回去，&lt;code&gt;DocId&lt;/code&gt;没问题，一定是属于两个&lt;code&gt;Document&lt;/code&gt;的。&lt;code&gt;Name.Url&lt;/code&gt;就出现了问题，因为&lt;code&gt;Name&lt;/code&gt;是&lt;code&gt;repeated&lt;/code&gt;的，我怎么知道这3个&lt;code&gt;Name.Url&lt;/code&gt;是全属于第一个&lt;code&gt;Document&lt;/code&gt;，还是其他情况呢？丢失的信息太多无法还原了。所有我们需要记录每个值是否是重复的以及在哪一层重复的（比如是在第一个&lt;code&gt;Name&lt;/code&gt;的第二个&lt;code&gt;Code&lt;/code&gt;，还是第二个&lt;code&gt;Name&lt;/code&gt;的第一个&lt;code&gt;Code&lt;/code&gt;）。有了这个信息，我们就可以根据之前的记录一个一个往上拼接来还原原始的数据结构。&lt;code&gt;r&lt;/code&gt;就是做这个的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;r&lt;/code&gt;是重复层次（Repetition Level）&lt;/strong&gt;，记录该列的值是在哪一个层次上重。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;r&lt;/code&gt;是0，则表示是第一个（非重复）的元素，如上图中的&lt;code&gt;DocId&lt;/code&gt;，两个DocId都是第一个元素，比较简单。但其他的字段就比较复杂了，如&lt;code&gt;Name.Language.Code&lt;/code&gt;，一共有五行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;en-us&lt;/code&gt;是第一个&lt;code&gt;Document&lt;/code&gt;（不同的&lt;code&gt;Document&lt;/code&gt;不算重复，不影响&lt;code&gt;r&lt;/code&gt;和&lt;code&gt;d&lt;/code&gt;的取值，只有&lt;code&gt;repeated&lt;/code&gt;类型的字段才算）里第一个&lt;code&gt;Name&lt;/code&gt;中的第一个&lt;code&gt;Language&lt;/code&gt;里的，重复还没有发生，所以&lt;code&gt;r&lt;/code&gt;是0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;en&lt;/code&gt;是第一个&lt;code&gt;Document&lt;/code&gt;里第一个&lt;code&gt;Name&lt;/code&gt;中第二个&lt;code&gt;Language&lt;/code&gt;里的，&lt;code&gt;Language&lt;/code&gt;发生了重复，在/Name/Language层次结构中处于第二层，所以&lt;code&gt;r&lt;/code&gt;是2。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;en-gb&lt;/code&gt;是第一个&lt;code&gt;Document&lt;/code&gt;里第三个&lt;code&gt;Name&lt;/code&gt;中第一个&lt;code&gt;Language&lt;/code&gt;里的，&lt;code&gt;Name&lt;/code&gt;发生了重复，在/Name/Language层次结构中处于第一层，所以&lt;code&gt;r&lt;/code&gt;是1。&lt;/li&gt;
&lt;li&gt;第一个&lt;code&gt;NULL&lt;/code&gt;是第一个&lt;code&gt;Document&lt;/code&gt;里第二个&lt;code&gt;Name&lt;/code&gt;中的，&lt;code&gt;Name&lt;/code&gt;发生了重复，在/Name/Language层次结构中处于第一层，所以&lt;code&gt;r&lt;/code&gt;是1。&lt;/li&gt;
&lt;li&gt;第二个&lt;code&gt;NULL&lt;/code&gt;是第二个&lt;code&gt;Document&lt;/code&gt;里第一个&lt;code&gt;Name&lt;/code&gt;中的，没有发生重复，所以&lt;code&gt;r&lt;/code&gt;是0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里例子中没有出现多个字段都发生重复的情况，如第二个&lt;code&gt;Name&lt;/code&gt;中的第二个&lt;code&gt;Language&lt;/code&gt;的&lt;code&gt;Code&lt;/code&gt;。如果是这种情况，那么&lt;code&gt;r&lt;/code&gt;取最大的，也就是最近发生重复的字段，这里例子中就是&lt;code&gt;Language&lt;/code&gt;的2。（&lt;strong&gt;待验证&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;之前还有个问题没有回答，为何要记录&lt;code&gt;NULL&lt;/code&gt;呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果把图中所有的&lt;code&gt;NULL&lt;/code&gt;都去掉，看会发生什么。 拿&lt;code&gt;Links.Backward&lt;/code&gt;举例，去掉第一行的&lt;code&gt;NULL&lt;/code&gt;后，我们读到第一个&lt;code&gt;Links.Backward&lt;/code&gt;，必然认为它是属于第一个&lt;code&gt;Document&lt;/code&gt;的，但实际数据中第一个&lt;code&gt;Document&lt;/code&gt;里没有&lt;code&gt;Links.Backward&lt;/code&gt;，完全搞错了。所以即使是&lt;code&gt;NULL&lt;/code&gt;也必须记录，为了后续的数据知道自己在哪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么有了&lt;code&gt;r&lt;/code&gt;后，是否信息就完善了呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们还是假设去掉&lt;code&gt;d&lt;/code&gt;的一列，试图还原数据。&lt;code&gt;DocId&lt;/code&gt;依然没问题，&lt;code&gt;Name.Url&lt;/code&gt;也没问题了，直接看&lt;code&gt;Name.Language.Country&lt;/code&gt;吧：&lt;/p&gt;
&lt;p&gt;读完第一行我们得到了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Document&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;us&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二行是个&lt;code&gt;NULL&lt;/code&gt;，是在第二层也就是&lt;code&gt;Language&lt;/code&gt;重复的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Document&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;us&amp;#39;&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第三行又是个&lt;code&gt;NULL&lt;/code&gt;，是在第一层也就是&lt;code&gt;Name&lt;/code&gt;重复的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Document&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;us&amp;#39;&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第四行是在第一层也就是&lt;code&gt;Name&lt;/code&gt;重复的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="no"&gt;Document&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;us&amp;#39;&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;
    &lt;span class="no"&gt;Name&lt;/span&gt;
        &lt;span class="no"&gt;Language&lt;/span&gt;
            &lt;span class="no"&gt;Country&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;gb&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看起来似乎没问题，不过对比原始数据发现第二个&lt;code&gt;Name&lt;/code&gt;不只没有&lt;code&gt;Country&lt;/code&gt;，连上层的&lt;code&gt;Language&lt;/code&gt;也没有。也就是单看&lt;code&gt;Name.Language.Country&lt;/code&gt;这个表，还是把数据还原错了。虽然把所有的表都还原出来，然后去掉所有的&lt;code&gt;NULL&lt;/code&gt;以及&lt;code&gt;NULL&lt;/code&gt;上边多余的部分，还是可以准确还原，但如果只是去查询某个字段，难道需要把其他所有字段全部分析一遍吗？另外没有发生重复的字段，具体是&lt;code&gt;required&lt;/code&gt;、&lt;code&gt;repeated&lt;/code&gt;、还是&lt;code&gt;optional&lt;/code&gt;的信息也丢了。（&lt;strong&gt;此处似乎还有其他问题&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;为了解决这个问题，&lt;code&gt;d&lt;/code&gt;被引入了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;d&lt;/code&gt;是定义层次（Definition Level）&lt;/strong&gt;，记录这个值是在哪一层被定义的。需要注意的是如果这个值是&lt;code&gt;required&lt;/code&gt;的，则层数不包括自身，否则如果是&lt;code&gt;repeated&lt;/code&gt;或&lt;code&gt;optional&lt;/code&gt;的，则包括自身。目的主要是区分是否是&lt;code&gt;required&lt;/code&gt;字段（&lt;strong&gt;但如何区分只有一行的&lt;code&gt;repeated&lt;/code&gt;和&lt;code&gt;optional&lt;/code&gt;呢？&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Document.Links.Backward&lt;/code&gt;的&lt;code&gt;d&lt;/code&gt;是2（&lt;code&gt;Document&lt;/code&gt;是0）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Document.Name.Language.Code&lt;/code&gt;也是2（因为&lt;code&gt;Code&lt;/code&gt;是&lt;code&gt;required&lt;/code&gt;的，所以不包括它自己）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于一般的数据，这个值看起来没什么意义（除了可以区分是否是&lt;code&gt;required&lt;/code&gt;字段），因为已经有值了，从根到它自身整条路径必然是存在的，但对于&lt;code&gt;NULL&lt;/code&gt;则不同，&lt;code&gt;d&lt;/code&gt;可以说明这个&lt;code&gt;NULL&lt;/code&gt;是在哪一层定义的，也就是解决我们之前还原&lt;code&gt;Name.Language.Country&lt;/code&gt;数据遇到的问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;r&lt;/code&gt;和&lt;code&gt;d&lt;/code&gt;这两个值还是需要好好理解一下，而且还有一些没弄清楚的细节，以及具体查询的复杂逻辑，只能后续继续学习了。&lt;/p&gt;
&lt;p&gt;因为种种原因，这一系列学习笔记最近可能不会更新了。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.yankay.com/google-dremel-rationale/"&gt;Google Dremel 原理 - 如何能3秒分析1PB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36632.pdf"&gt;Dremel Interactive Analysis of WebScaleDatasets.pdf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>Apache Drill 学习笔记一：环境搭建和简单试用</title><link href="/apache-drill-xue-xi-bi-ji-yi-huan-jing-da-jian-he-jian-dan-shi-yong.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/apache-drill-xue-xi-bi-ji-yi-huan-jing-da-jian-he-jian-dan-shi-yong.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;Apache Drill是一个低延迟的分布式海量数据（涵盖结构化、半结构化以及嵌套数据）交互式查询引擎，使用ANSI SQL兼容语法，支持本地文件、HDFS、HBase、MongoDB等后端存储，支持Parquet、JSON、CSV、TSV、PSV等数据格式。受Google的Dremel启发，Drill满足上千节点的PB级别数据的交互式商业智能分析场景。&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;Drill可以安装在单机或者集群环境上，支持Linux、Windows、Mac OS X系统。简单起见，我们在Linux单机环境（CentOS 6.3）搭建以供试用。&lt;/p&gt;
&lt;p&gt;准备安装包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jdk 7：&lt;a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html"&gt;jdk-7u75-linux-x64.tar.gz&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;Drill：&lt;a href="http://getdrill.org/drill/download/apache-drill-0.8.0.tar.gz"&gt;apache-drill-0.8.0.tar.gz&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在$WORK（/path/to/work）目录中安装 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;Apache Drill是一个低延迟的分布式海量数据（涵盖结构化、半结构化以及嵌套数据）交互式查询引擎，使用ANSI SQL兼容语法，支持本地文件、HDFS、HBase、MongoDB等后端存储，支持Parquet、JSON、CSV、TSV、PSV等数据格式。受Google的Dremel启发，Drill满足上千节点的PB级别数据的交互式商业智能分析场景。&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;Drill可以安装在单机或者集群环境上，支持Linux、Windows、Mac OS X系统。简单起见，我们在Linux单机环境（CentOS 6.3）搭建以供试用。&lt;/p&gt;
&lt;p&gt;准备安装包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jdk 7：&lt;a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html"&gt;jdk-7u75-linux-x64.tar.gz&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;Drill：&lt;a href="http://getdrill.org/drill/download/apache-drill-0.8.0.tar.gz"&gt;apache-drill-0.8.0.tar.gz&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在$WORK（/path/to/work）目录中安装，将jdk和drill分别解压到java和drill目录中，并打软连以便升级：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;.
├── drill
│   ├── apache-drill -&amp;gt; apache-drill-0.8.0
│   └── apache-drill-0.8.0
├── init.sh
└── java
    ├── jdk -&amp;gt; jdk1.7.0_75
    └── jdk1.7.0_75
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;并添加一init.sh脚本初始化java相关环境变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;WORK&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/path/to/work&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;JAVA&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$WORK&lt;/span&gt;&lt;span class="s2"&gt;/java/jdk/bin/java&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;JAVA_HOME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$WORK&lt;/span&gt;&lt;span class="s2"&gt;/java/jdk&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;启动&lt;/h2&gt;
&lt;p&gt;在单机环境运行只需要启动bin/sqlline便可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; &lt;span class="nv"&gt;$WORK&lt;/span&gt;
$ . ./init.sh
$ ./drill/apache-drill/bin/sqlline -u jdbc:drill:zk&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;local&lt;/span&gt;
Drill log directory /var/log/drill does not exist or is not writable, defaulting to ...
Apr &lt;span class="m"&gt;06&lt;/span&gt;, &lt;span class="m"&gt;2015&lt;/span&gt; &lt;span class="m"&gt;12&lt;/span&gt;:47:30 AM org.glassfish.jersey.server.ApplicationHandler initialize
INFO: Initiating Jersey application, version Jersey: &lt;span class="m"&gt;2&lt;/span&gt;.8 &lt;span class="m"&gt;2014&lt;/span&gt;-04-29 &lt;span class="m"&gt;01&lt;/span&gt;:25:26...
sqlline version &lt;span class="m"&gt;1&lt;/span&gt;.1.6
&lt;span class="m"&gt;0&lt;/span&gt;: jdbc:drill:zk&lt;span class="o"&gt;=&lt;/span&gt;local&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;-u jdbc:drill:zk=local&lt;/code&gt;表示使用本机的Drill，无需启动ZooKeeper，如果是集群环境则需要配置和启动ZooKeeper并填写地址。启动后便可以在&lt;code&gt;0: jdbc:drill:zk=local&amp;gt;&lt;/code&gt;后敲入命令使用了。&lt;/p&gt;
&lt;h2&gt;试用&lt;/h2&gt;
&lt;p&gt;Drill的sample-data目录有Parquet格式的演示数据可供查询：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/apache-drill/sample-data/&lt;/span&gt;&lt;span class="n"&gt;nation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;parquet&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="n"&gt;limit&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+-------------+------------+-------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;N_NATIONKEY&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;N_NAME&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;N_REGIONKEY&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;N_COMMENT&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+-------------+------------+-------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ALGERIA&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;haggle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;carefully&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;ARGENTINA&lt;/span&gt;  &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;foxes&lt;/span&gt; &lt;span class="n"&gt;promise&lt;/span&gt; &lt;span class="n"&gt;sly&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;BRAZIL&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;alongside&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;CANADA&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;eas&lt;/span&gt; &lt;span class="n"&gt;hang&lt;/span&gt; &lt;span class="n"&gt;ironic&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sil&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;EGYPT&lt;/span&gt;      &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;           &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;above&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;carefull&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+-------------+------------+-------------+------------+&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.741&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里用的库名格式为dfs.`本地文件（Parquet、JSON、CSV等文件）绝对路径`。可以看出只要熟悉SQL语法几乎没有学习成本。但Parquet格式文件需要专用工具查看、编辑，不是很方便，后续再专门介绍，下文先使用更通用的CSV和JSON文件进行演示。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;$WORK/data&lt;/code&gt;中创建如下&lt;code&gt;test.csv&lt;/code&gt;文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="m"&gt;1101&lt;/span&gt;,SteveEurich,Steve,Eurich,16,StoreT
&lt;span class="m"&gt;1102&lt;/span&gt;,MaryPierson,Mary,Pierson,16,StoreT
&lt;span class="m"&gt;1103&lt;/span&gt;,LeoJones,Leo,Jones,16,StoreTem
&lt;span class="m"&gt;1104&lt;/span&gt;,NancyBeatty,Nancy,Beatty,16,StoreT
&lt;span class="m"&gt;1105&lt;/span&gt;,ClaraMcNight,Clara,McNight,16,Store
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后查询：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;csv&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;columns&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1101&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;SteveEurich&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Steve&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Eurich&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;16&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;StoreT&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1102&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;MaryPierson&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Mary&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Pierson&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;16&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;StoreT&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1103&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;LeoJones&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Leo&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Jones&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;16&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;StoreTem&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1104&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;NancyBeatty&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Nancy&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Beatty&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;16&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;StoreT&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1105&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ClaraMcNight&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Clara&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;McNight&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;16&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Store&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.082&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到结果和之前的稍有不同，因为CSV文件没有地方存放列列名，所以统一用&lt;code&gt;columns&lt;/code&gt;代替，如果需要具体制定列则需要用&lt;code&gt;columns[n]&lt;/code&gt;，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;],&lt;/span&gt; &lt;span class="n"&gt;columns&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;csv&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$0&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$1&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1101&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Eurich&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1102&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Pierson&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1103&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Jones&lt;/span&gt;      &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1104&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;Beatty&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1105&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;McNight&lt;/span&gt;    &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CSV文件格式比较简单，发挥不出Drill的强大优势，下边更复杂的功能使用和Parquet更接近的JSON文件进行演示。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;$WORK/data&lt;/code&gt;中创建如下&lt;code&gt;test.json&lt;/code&gt;文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;ka1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kb1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;1.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kc1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;vc11&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kd1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;ka2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;kb2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;10.1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;kc2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;vc1010&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;ka1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kb1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;2.2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kc1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;vc22&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kd1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;ka2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;kb2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;20.2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;kc2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;vc2020&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;ka1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kb1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;3.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kc1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;vc33&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;quot;kd1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;ka2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;kb2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;30.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;quot;kc2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;vc3030&amp;quot;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到这个JSON文件内容是有多层嵌套的，结构比之前那个CSV文件要复杂不少，而查询嵌套数据正是Drill的优势所在。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;json&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;ka1&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;kb1&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;kc1&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;kd1&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;1.1&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc11&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ka2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kb2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;10.1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kc2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;vc1010&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;}]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;2.2&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc22&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ka2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kb2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;20.2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kc2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;vc2020&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;}]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;3.3&lt;/span&gt;        &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc33&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;[{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;ka2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kb2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;30.3&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kc2&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;vc3030&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;}]&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+------------+------------+&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.098&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;select *&lt;/code&gt;只查出第一层的数据，更深层的数据只以原本的JSON数据呈现出来，我们显然不应该只关心第一层的数据，具体怎么查完全随心所欲：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ka1&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="n"&gt;avg&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kd1&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;].&lt;/span&gt;&lt;span class="n"&gt;kb2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;json&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$0&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$1&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;20.2&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.136&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以通过&lt;code&gt;kd1[0]&lt;/code&gt;来访问嵌套到第二层的这个表。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;kc1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kd1&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;].&lt;/span&gt;&lt;span class="n"&gt;kc2&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;json&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;kd1&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;].&lt;/span&gt;&lt;span class="n"&gt;kb2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;10.1&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;ka1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;    &lt;span class="n"&gt;kc1&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$1&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc11&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc1010&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.181&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;创建view：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;tmpview&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;kd1&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;].&lt;/span&gt;&lt;span class="n"&gt;kb2&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;json&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;     &lt;span class="n"&gt;ok&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;  &lt;span class="n"&gt;summary&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;tmpview&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt; &lt;span class="n"&gt;successfully&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;dfs.tmp&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;schema&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+------------+&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.055&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;

&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;tmpview&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$0&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;10.1&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;20.2&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="mf"&gt;30.3&lt;/span&gt;       &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.193&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以把嵌套的第二层表打平（整合kd1[0]..kd1[n]）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;jdbc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;drill&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;zk&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;kddb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;kdtable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;kc2&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="n"&gt;flatten&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kd1&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;kdtable&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/path/to/work/drill/data/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;json&lt;/span&gt;&lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;kddb&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt;   &lt;span class="n"&gt;EXPR$0&lt;/span&gt;   &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc1010&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc2020&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;vc3030&lt;/span&gt;     &lt;span class="o"&gt;|&lt;/span&gt;
&lt;span class="o"&gt;+------------+&lt;/span&gt;
&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;rows&lt;/span&gt; &lt;span class="n"&gt;selected&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.083&lt;/span&gt; &lt;span class="n"&gt;seconds&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用细节上和mysql还是有所不同的，另外涉及到多层表的复杂逻辑，要想用得得心应手还需要仔细阅读官方文档并多多练习。这次先走马观花了，之后会深入了解语法层面的特性。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://cwiki.apache.org/confluence/display/DRILL/Apache+Drill+in+10+Minutes"&gt;Apache Drill in 10 Minutes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cwiki.apache.org/confluence/display/DRILL/Analyzing+Yelp+JSON+Data+with+Apache+Drill"&gt;Analyzing Yelp JSON Data with Apache Drill&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>从 Cygwin 迁移到 MSYS2 的原因和步骤</title><link href="/cong-cygwin-qian-yi-dao-msys2-de-yuan-yin-he-bu-zou.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/cong-cygwin-qian-yi-dao-msys2-de-yuan-yin-he-bu-zou.html</id><summary type="html">&lt;h2&gt;为什么从cygwin迁移到msys2&lt;/h2&gt;
&lt;p&gt;习惯Linux后，再使用Windows的话，cygwin基本是必须的。&lt;strong&gt;但cygwin有一些痛点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有一个好用的包管理工具，无论是官方的setup.exe，还是第三方的几个apt-cyg，都存在使用不方便和功能不全的问题：&lt;ul&gt;
&lt;li&gt;setup.exe选包很累人&lt;/li&gt;
&lt;li&gt;apt-cyg和它的依赖得额外安装&lt;/li&gt;
&lt;li&gt;cygwin的已安装软件数据库不区分是直接安装的还是被依赖的包，一旦装上想等卸载就只能自己手动分辨了&lt;/li&gt;
&lt;li&gt;apt-cyg不支持软件升级操作，我自己加上了这个功能（&lt;a href="https://github.com/goreliu/apt-cyg"&gt;goreliu/apt-cyg&lt;/a&gt;），虽然基本能用，但还是存在一些问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cygwin的软件打包方式不方便，并且为官方软件仓库提交新的包需要走加邮件列表、发邮件、确认、上传等诸多流程&lt;/li&gt;
&lt;li&gt;cygwin里不少软件的版本还是比较老的，比如git还是2.1.4版本的，升级缓慢（一个好消息是python和ruby最近几天升级到最新版本了，之前还是python 2.7.8/3.2.2、ruby 2.0.0，盼了好久）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;而msys2基本上解决了这些问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用从archlinux移植过来的pacman，功能完整，使用方便&lt;/li&gt;
&lt;li&gt;PKGBUILD好写，用过archlinux的话无学习成本 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;h2&gt;为什么从cygwin迁移到msys2&lt;/h2&gt;
&lt;p&gt;习惯Linux后，再使用Windows的话，cygwin基本是必须的。&lt;strong&gt;但cygwin有一些痛点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;没有一个好用的包管理工具，无论是官方的setup.exe，还是第三方的几个apt-cyg，都存在使用不方便和功能不全的问题：&lt;ul&gt;
&lt;li&gt;setup.exe选包很累人&lt;/li&gt;
&lt;li&gt;apt-cyg和它的依赖得额外安装&lt;/li&gt;
&lt;li&gt;cygwin的已安装软件数据库不区分是直接安装的还是被依赖的包，一旦装上想等卸载就只能自己手动分辨了&lt;/li&gt;
&lt;li&gt;apt-cyg不支持软件升级操作，我自己加上了这个功能（&lt;a href="https://github.com/goreliu/apt-cyg"&gt;goreliu/apt-cyg&lt;/a&gt;），虽然基本能用，但还是存在一些问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cygwin的软件打包方式不方便，并且为官方软件仓库提交新的包需要走加邮件列表、发邮件、确认、上传等诸多流程&lt;/li&gt;
&lt;li&gt;cygwin里不少软件的版本还是比较老的，比如git还是2.1.4版本的，升级缓慢（一个好消息是python和ruby最近几天升级到最新版本了，之前还是python 2.7.8/3.2.2、ruby 2.0.0，盼了好久）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;而msys2基本上解决了这些问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用从archlinux移植过来的pacman，功能完整，使用方便&lt;/li&gt;
&lt;li&gt;PKGBUILD好写，用过archlinux的话无学习成本，为官方源提交新包可以直接在github发PR&lt;/li&gt;
&lt;li&gt;msys2里的软件总体是要比cygwin新的（一个特例，最近cygwin的ruby升级到了最新的2.2，而msys2的还是2.1）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;迁移的麻烦&lt;/h2&gt;
&lt;p&gt;我几个月前就在垂涎msys2，但因为&lt;strong&gt;几个麻烦的问题&lt;/strong&gt;，每次都作罢：
1. cygwin是可以使用acl选项挂载文件系统的，这种情况下chmod基本可用（虽然也有些问题），而msys2只能使用noacl选项挂载，chmod基本无法工作（只能修改第一个w），每个用户都有文件的读权限，是否有执行权限根据文件扩展名和内容决定。直接的影响就是使用git时无法使本地文件权限和远程的一致。
2. 我使用的一些软件cygwin里有，而msys2里没有，比如w3m、dig、atool、bvi、cygstart。
3. 有些软件支持直接在cygwin编译，而在msys2编译的话需要打patch。&lt;/p&gt;
&lt;p&gt;之前主要是阻塞在第1个问题上了，查了好久如何开启acl，无果。今天突然想到是否可以让git忽略本机权限，果然有方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git config core.filemode false
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外还有.ssh目录无法修改成700的麻烦，好在我不需要在msys2开sshd，可以不考虑这个。那么权限的文件基本就没有了。&lt;/p&gt;
&lt;p&gt;第2个问题就相对好处理了，自己编译打包了bviplus、atool、w3m、cygutils（里边有cygstart）等，因为之前在archlinux就经常自己打包，轻车熟路，PKGBUILD见https://github.com/goreliu/my-MSYS2-Packages。Dig不好编译，但有现成的可以&lt;a href="http://ftp.isc.org/isc/bind9/"&gt;下载&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;第3个问题只是稍微麻烦些，可以写个脚本搞定，基本不用考虑。&lt;/p&gt;
&lt;p&gt;折腾了一下午，终于迁移了过了，删掉了cygwin。&lt;/p&gt;
&lt;h2&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从&lt;a href="http://sourceforge.net/projects/msys2/"&gt;官网&lt;/a&gt;下载最新的安装包，安装到c:\msys64。&lt;/li&gt;
&lt;li&gt;将之前cygwin的home目录直接替换到msys64/home&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkpasswd &amp;gt; /etc/passwd; mkgroup &amp;gt; /etc/group&lt;/code&gt;，和cygwin里一样&lt;/li&gt;
&lt;li&gt;注释掉/etc/fstab中的那一行，保留/cygdrive目录，以和cygwin一致（可选）&lt;/li&gt;
&lt;li&gt;修改/etc/etc/pacman.d/mirrorlist.*，改成国内地址，如http://mirror.bit.edu.cn/msys2/&lt;/li&gt;
&lt;li&gt;使用pacman安装需要的软件&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在文件浏览器的邮件添加Open MSYS2 here的菜单：&lt;/p&gt;
&lt;p&gt;Windows Registry Editor Version 5.00&lt;/p&gt;
&lt;p&gt;[HKEY_CLASSES_ROOT\Directory\Background\shell\open_msys2]
@="Open MSYS2 here"&lt;/p&gt;
&lt;p&gt;[HKEY_CLASSES_ROOT\Directory\Background\shell\open_msys2\command]
@="c:\msys64\usr\bin\mintty.exe /bin/sh -lc 'cd \"$(cygpath \"%V\")\"; exec zsh'"&lt;/p&gt;
&lt;p&gt;[HKEY_CLASSES_ROOT\Folder\shell\open_msys2]
@="Open MSYS2 here"&lt;/p&gt;
&lt;p&gt;[HKEY_CLASSES_ROOT\Folder\shell\open_msys2\command]
@="c:\msys64\usr\bin\mintty.exe /bin/sh -lc 'cd \"$(cygpath \"%V\")\"; exec zsh'"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建指向&lt;code&gt;C:\msys64\usr\bin\mintty.exe /usr/bin/zsh --login&lt;/code&gt;的快捷方式，并绑定快捷键&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;设置&lt;code&gt;export MSYS="winsymlinks:lnk"&lt;/code&gt;关键变量，不然打软连直接变成了复制&lt;/li&gt;
&lt;li&gt;在需要忽略本地文件权限的git repo目录运行&lt;code&gt;git config core.filemode false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从&lt;a href="http://ftp.isc.org/isc/bind9/"&gt;isc.org&lt;/a&gt;下载windows版本的bind，包含host、dig等命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone git@github.com:goreliu/my-MSYS2-Packages.git&lt;/code&gt;，进入需要的目录，运行 &lt;code&gt;makepkg&lt;/code&gt;和&lt;code&gt;pacman -U xxx.tar.xz&lt;/code&gt;安装自己打的包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后环境就和之前的cygwin没有什么区别了。&lt;/p&gt;</content></entry><entry><title>带权轮询算法</title><link href="/dai-quan-lun-xun-suan-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/dai-quan-lun-xun-suan-fa.html</id><summary type="html">&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;有Q1、Q2、……、Qn n个队列，每个队列有一个权值W1、W2、……、Wn，需要每次从其中一个队列取出一个元素，使得从不同队列取出的元素数量比例服从权值的比例。&lt;/p&gt;
&lt;h3&gt;解释&lt;/h3&gt;
&lt;p&gt;这正是网络流量调度场景中的“带权轮询调度”（Weighted Round-Robin Scheduling，WRR），有现成的算法可用。&lt;/p&gt;
&lt;p&gt;为了简单起见，先考虑最简单的情况，令 W1 = W2 = ... = Wn，那么“带权轮询调度”退化成“轮询调度”（Round-Robin Scheduling，RR），RR实现很简单，然后考虑权值不同的情况。&lt;/p&gt;
&lt;h3&gt;实现（python代码）&lt;/h3&gt;
&lt;h4&gt;RR&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# count
N = 3

# Round-Robin Scheduling
def rr_select():
    last = N - 1
    while True:
        current = (last …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h3&gt;问题&lt;/h3&gt;
&lt;p&gt;有Q1、Q2、……、Qn n个队列，每个队列有一个权值W1、W2、……、Wn，需要每次从其中一个队列取出一个元素，使得从不同队列取出的元素数量比例服从权值的比例。&lt;/p&gt;
&lt;h3&gt;解释&lt;/h3&gt;
&lt;p&gt;这正是网络流量调度场景中的“带权轮询调度”（Weighted Round-Robin Scheduling，WRR），有现成的算法可用。&lt;/p&gt;
&lt;p&gt;为了简单起见，先考虑最简单的情况，令 W1 = W2 = ... = Wn，那么“带权轮询调度”退化成“轮询调度”（Round-Robin Scheduling，RR），RR实现很简单，然后考虑权值不同的情况。&lt;/p&gt;
&lt;h3&gt;实现（python代码）&lt;/h3&gt;
&lt;h4&gt;RR&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# count
N = 3

# Round-Robin Scheduling
def rr_select():
    last = N - 1
    while True:
        current = (last + 1) % N
        last = current
        yield current

rr_test = rr_select()
for i in range(1000):
    print(rr_test.__next__())
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;N是队列的个数，0到N-1数字代表这N个队列。&lt;/p&gt;
&lt;p&gt;RR会依次从每个队列取出元素，很简单无需过多叙述。&lt;/p&gt;
&lt;h4&gt;WRR&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# count
N = 3

weight = (60, 30, 10)

# 最大公约数
def gcd(nums):
    m = nums[0]
    for n in nums[1:]:
        while n != 0:
            m, n = n, m % n
    return m

# Weighted Round-Robin Scheduling
def wrr_select():
    current = N - 1
    current_weight = 0

    while True:
        current = (current + 1) % N
        if current == 0:
            current_weight -= gcd(weight)
            if current_weight &amp;lt;= 0:
                current_weight = max(weight)
        if weight[current] &amp;gt;= current_weight:
            yield current

wrr_test = wrr_select()
for i in range(1000):
    print(wrr_test.__next__())
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个算法需要解释一下。&lt;/p&gt;
&lt;p&gt;先看一下取前10个元素的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;current_weight     从哪些队列取出了元素
60                 0
50                 0
40                 0
30                 0 1
20                 0 1
10                 0 1 2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也就是每次&lt;code&gt;for i in (0, 1, 2)&lt;/code&gt;的小周期内，当&lt;code&gt;current_weight &amp;gt; weight[i]&lt;/code&gt;时，就把&lt;code&gt;i&lt;/code&gt;选出来。当&lt;code&gt;current_weight&lt;/code&gt;等于&lt;code&gt;0&lt;/code&gt;了，就再从头开始，这算一个大周期。一个大周期包含&lt;code&gt;max(weight)/gcd(weight)&lt;/code&gt;个小周期。&lt;/p&gt;
&lt;p&gt;那如何证明这样取是符合权值比例的？&lt;/p&gt;
&lt;p&gt;可以看到每个小周期中，都是要从权值最大的队列里拿走一个元素的，可以看作拿权值最大的那个作为基准，然后权值较小的直接拿它对比。那仅看权值为10的便可，10是60的1/6，把60分6分，只有1份是应该给10的，所以60知道降到10才满足10的条件。权值30的同理。&lt;/p&gt;
&lt;p&gt;其实max(weight)和gcd(weight)都可以选择别的，但选它们两个可以满足最细粒度的平均，即每取出任意10个连续的中间结果，就必然服从权值比例，可以认为是最优的。&lt;/p&gt;
&lt;h3&gt;随机性考虑&lt;/h3&gt;
&lt;p&gt;WRR的运行结果是固定的，如果需要考虑随机性的话，需要再做一些额外工作。简单的话可以先对队列的顺序做随机，但这样实际的顺序还是固定的。可以按实际需要频繁暂存一定（随机）数量的结果，再随机处理后依次输出。&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.163.com/s_u/blog/static/1330836720105233102894/"&gt;轮询调度算法(Round-Robin Scheduling)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.163.com/tianle_han/blog/static/661782620119165645590/"&gt;带权值轮询算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.xuebuyuan.com/126515.html"&gt;IPVS的调度算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Weighted_round_robin"&gt;Weighted round robin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>更好地使用 WSL 终端环境</title><link href="/geng-hao-di-shi-yong-wsl-zhong-duan-huan-jing.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/geng-hao-di-shi-yong-wsl-zhong-duan-huan-jing.html</id><summary type="html">&lt;p&gt;Windows 10 中包含了一个 WSL （ Windows Subsystem for Linux ）子系统，我们可以在其中运行未经修改过的原生 Linux ELF 可执行文件。利用它我们可以做很多事情，对开发人员和普通用户都是如此。当然对开发人员的吸引力更大一些，因为这意味着在一些情况，不再需要使用 Linux 虚拟机、双系统、 Cygwin/MSYS2 了。&lt;/p&gt;
&lt;p&gt;当前版本（ 14901.1000 ） Windows 10 中的 WSL 功能已经比较完善了，和刚出来时不可同日而语，也不再是一个没有实用价值的玩具了（最初的版本连 zsh 和 tmux 等最基本的工具都无法运行，基本没有可用性。但如果现在依然说 WSL 不可用，就有失偏颇了）。但对不想折腾的普通用户来说，用户体验并不好。比如中文显示有问题，不支持中文输入，只支持 16 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Windows 10 中包含了一个 WSL （ Windows Subsystem for Linux ）子系统，我们可以在其中运行未经修改过的原生 Linux ELF 可执行文件。利用它我们可以做很多事情，对开发人员和普通用户都是如此。当然对开发人员的吸引力更大一些，因为这意味着在一些情况，不再需要使用 Linux 虚拟机、双系统、 Cygwin/MSYS2 了。&lt;/p&gt;
&lt;p&gt;当前版本（ 14901.1000 ） Windows 10 中的 WSL 功能已经比较完善了，和刚出来时不可同日而语，也不再是一个没有实用价值的玩具了（最初的版本连 zsh 和 tmux 等最基本的工具都无法运行，基本没有可用性。但如果现在依然说 WSL 不可用，就有失偏颇了）。但对不想折腾的普通用户来说，用户体验并不好。比如中文显示有问题，不支持中文输入，只支持 16 种颜色，不能隐藏滚动条，不兼容某些命令的输出，不能定制主题和一些其他按键相关配置等。&lt;/p&gt;
&lt;p&gt;用过 Cygwin/MSYS2 的朋友都清楚有个名叫 &lt;a href="http://mintty.github.io/"&gt;mintty&lt;/a&gt; 的终端模拟器，体积小巧配置简单，功能也够用，如果能直接用 mintty 作为 WSL 的终端模拟器，用户体验就好很多了。&lt;a href="https://github.com/goreliu/wsl-terminal"&gt;wsl-terminal&lt;/a&gt; 让这成为可能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="https://raw.githubusercontent.com/wiki/goreliu/wsl-terminal/images/wsl-terminal.png"&gt;&lt;/p&gt;
&lt;p&gt;wsl-terminal 支持如下功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优秀的兼容性（中文显示/输入、 24 位颜色、命令输出等都正常了）。&lt;/li&gt;
&lt;li&gt;体积小巧，压缩包仅 1.7 M 多，解压后不到 10 M 。&lt;/li&gt;
&lt;li&gt;配置简单， mintty 可以直接在标题栏右键配置， wsl-terminal 的配置文件也很简单。&lt;/li&gt;
&lt;li&gt;可以直接在资源管理器右键打开终端模拟器并定位到当前目录。&lt;/li&gt;
&lt;li&gt;可以将 .sh/.py/.pl 脚本关联到用 wsl-terminal 运行。&lt;/li&gt;
&lt;li&gt;可以将文本文件关联到用 wsl-terminal 里的 vim 运行。&lt;/li&gt;
&lt;li&gt;支持 tmux ，可以在 tmux 里打开新目录，恢复已有的 tmux 会话等。&lt;/li&gt;
&lt;li&gt;支持在 WSL 里直接运行 Windows 程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 https://github.com/goreliu/wsl-terminal/releases 下载 7z 格式的发布包。&lt;/li&gt;
&lt;li&gt;解压后，直接运行 open-wsl.exe 即可在当前目录打开（可以关联到快捷键）。&lt;/li&gt;
&lt;li&gt;可以运行 &lt;code&gt;tools/add-open-wsl-here-menu.js&lt;/code&gt; 在资源管理器右键菜单里添加一个 &lt;code&gt;Open WSL Here&lt;/code&gt; 菜单（&lt;code&gt;tools/remove-open-wsl-here-menu.js&lt;/code&gt; 删除菜单）。&lt;/li&gt;
&lt;li&gt;可以修改 .sh/.py/.pl/.php 等各种脚本的打开方式为 run-wsl-file.exe ，双击就可以打开。如果需要看结果的话，记得脚本最后加个 sleep 或者 read 。&lt;/li&gt;
&lt;li&gt;可以修改文本文件的打开方式为 vim.exe ，双击就可以用 WSL 里的 vim 打开编辑。&lt;/li&gt;
&lt;li&gt;如果想做 WSL 里边运行 Windows 的软件，运行 outbash-daemon.js ，然后把 bin 里的 wrun 、wstart 、wcmd 复制到 /usr/local/bin （可以直接运行 install_cbwin.sh ），然后 wstart notepad 就可以打开记事本了。cbwin 使用文档： https://github.com/xilun/cbwin&lt;/li&gt;
&lt;li&gt;如果需要使用 tmux，在编辑文件里启用 use_tmux 即可。&lt;/li&gt;
&lt;/ol&gt;</content></entry><entry><title>关于好玩、有用和技术含量之我见</title><link href="/guan-yu-hao-wan-you-yong-he-ji-zhu-han-liang-zhi-wo-jian.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/guan-yu-hao-wan-you-yong-he-ji-zhu-han-liang-zhi-wo-jian.html</id><summary type="html">&lt;p&gt;前几天闲来无事买来个树莓派玩。并不是想用来做什么，甚至没想到要怎么玩，更多是因为一种“情怀”吧，关于 Linux 的。我大概从 08 年开始用桌面 Linux，一直到 15 年换成 Windows（开始时用虚拟机装 Linux，后来改用 Cygwin/MSYS2，就很少用了。再后来 Win 10 有了 WSL，我把虚拟机也删了）。但对我来说，Windows 是用的而不是玩的，甚至 WSL 基本已经能满足所有关于 Linux 的实用性功能后，我还是感觉 WSL 是用的而不是玩的。那我为什么不用虚拟机来玩 Linux呢？理论上，虚拟机可以满足所有我折腾 Linux 的功能性需求，只是有一点，感觉不一样。面对运行在虚拟机里的 Linux …&lt;/p&gt;</summary><content type="html">&lt;p&gt;前几天闲来无事买来个树莓派玩。并不是想用来做什么，甚至没想到要怎么玩，更多是因为一种“情怀”吧，关于 Linux 的。我大概从 08 年开始用桌面 Linux，一直到 15 年换成 Windows（开始时用虚拟机装 Linux，后来改用 Cygwin/MSYS2，就很少用了。再后来 Win 10 有了 WSL，我把虚拟机也删了）。但对我来说，Windows 是用的而不是玩的，甚至 WSL 基本已经能满足所有关于 Linux 的实用性功能后，我还是感觉 WSL 是用的而不是玩的。那我为什么不用虚拟机来玩 Linux呢？理论上，虚拟机可以满足所有我折腾 Linux 的功能性需求，只是有一点，感觉不一样。面对运行在虚拟机里的 Linux，我完全没有玩的欲望，就好像它是阶下囚一样。我想在一个单独设备安装 Linux 来玩，即使什么都不做，只是时不时 ssh 上去更新一下软件包，或者看看日志。&lt;/p&gt;
&lt;p&gt;我本来以为买回来玩两天就会感觉没什么意思，然后就放着吃灰了，但实际情况要好一些。我没有把树莓派接到显示器，也没有安装图形界面软件，全部操作都在电脑、手机或者 iPad ssh 进行。然后我就想给树莓派加一块屏幕或者连接显示器有什么意义呢？如果我需要显示一些东西，或者通过图形界面来输入一些东西，我可以写一个网页，然后用浏览器访问。说干就干，我用来了将近两天的时间，寻找最容易的实现方法（我对前端的了解还停留在多年前的简单 Html 和 JavaScript 常识），最后经过各种查找、试验、比较后，确定使用 Python（主体语言） + Flask（后端） + Vue.js（前端逻辑） + Flask-SocketIO（前后端间 WebSocket 通信） + Bootstrap-vue（前端界面），验证了我想要的功能是可以很容易实现的，并且感慨现在对于对前端几乎零基础的开发人员来说，写一个简单的看起来还像是个网站的东西还是非常容易的，就是选型比较麻烦，需要各种权衡用什么框架或者库。&lt;/p&gt;
&lt;p&gt;但写完了 Demo 后，我的热情就褪去了大半，不错，技术上是能实现的，但我想做什么呢？我本来想先做一个简单的网页，在手机可以实时查看树莓派的运行状态，并且可以发送命令获取执行结果。但这有什么意义呢？直接 ssh 上去就可以了。获取传感器的数据，以及发送控制指令？我想了想，我的房间里实在没有什么需要用传感器获取的数据，获取些温度、湿度、气压、光照、气流、声音、照片、视频等等，有什么意义呢？盯着手机屏幕看或者自动发送到微博来自嗨？想控制些什么呢？小车、飞行器、机械手臂或者其他各种华而不实的玩具做什么呢？实用的东西多半早有成型并且成本低廉的产品了。并且那些玩具中多数没有什么技术含量，硬件基本买来连上（最多动一下电烙铁）就好，虽然看起来可能很唬人，软件的逻辑基本都比较简单，而且有很多现成的库或者算法，需要自己写的代码往往不多。而且其中很多东西都有很多人玩过了，轮子已经遍地都是了。&lt;/p&gt;
&lt;p&gt;我这几天经常去网上查还有什么关于树莓派的创意玩法，没有找到吸引我的东西。在我即将让树莓派吃灰时，我突然想到一个问题，如果我只是想好玩，为什么要考虑有没有用呢？为什么要考虑有没有技术含量呢？为什么要考虑有没有前人玩过呢？&lt;/p&gt;
&lt;p&gt;我想到小孩子玩一个像弹珠之类简单的东西都可以玩一下午，甚至一个暑假，它有用吗，有技术含量吗，没有前人玩过吗？但这些都不妨碍他玩得开心。而很多成年人，能接触到的东西要比小孩子多很多，但为什么找一个真正好玩的东西反而更难了？一个很大的原因就是很多成年人往往不是纯粹地找一个好玩的东西，而是又要好玩，又要好用，又要有技术含量并且没有过时，甚至还要没有其他人玩过的，那这样能找到的可能性就大大降低了。&lt;/p&gt;
&lt;p&gt;然后我就想到很多人经常玩甚至沉溺于各种电子游戏的人，之前我总是不能真正理性地看待这些人，但现在想，他们中很多人纯粹地找到了好玩的东西，不过多考虑其他因素，沉浸进去，并且得到了快乐，如果没有因此失去更多东西，不是很好的事情吗？为什么要用是不是有用、是不是有技术含量、是不是别人都玩过的角度来看呢？&lt;/p&gt;
&lt;p&gt;同样地，如果我不考虑是不是有用、是不是有技术含量、是不是之前已经有人做过了，单纯地以玩的心态来玩树莓派，是不是就更容易找到我喜欢的玩法呢？至少思路会远比之前广阔。&lt;/p&gt;
&lt;p&gt;或许我只是把树莓派接上电源放在桌子上，时不时 ssh 上去随便敲些命令，只要自己开心，又有什么问题呢？也许慢慢我就会发现 pstree 里的进程越来越多了，或者接口上连的东西越来越多了，甚至我的生活越来越离不开它了。&lt;/p&gt;</content></entry><entry><title>进入 WSL 环境的多种方法比较</title><link href="/jin-ru-wsl-huan-jing-de-duo-chong-fang-fa-bi-jiao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/jin-ru-wsl-huan-jing-de-duo-chong-fang-fa-bi-jiao.html</id><summary type="html">&lt;p&gt;Windows 10 中包含了一个 WSL（Windows Subsystem for Linux）子系统，我们可以在其中运行未经修改过的原生 Linux ELF 可执行文件。利用它我们可以做很多事情，对开发人员和普通用户都是如此。当然对开发人员的吸引力更大一些，因为这意味着在一些情况，不再需要使用 Linux 虚拟机、双系统、Cygwin/MSYS2 了。&lt;/p&gt;
&lt;p&gt;当前版本（14901.1000）Windows 10 中的 WSL 功能已经比较完善了，和刚出来时不可同日而语，也不再是一个没有实用价值的玩具了（最初的版本连 zsh 和 tmux 等最基本的工具都无法运行，基本没有可用性。但如果现在依然说 WSL 不可用，就有失偏颇了）。但对不想折腾的普通用户来说，用户体验并不好。其实我们可以做一些优化，最终效果是在仅损失少量可接受的代价的前提下，达到接近完美的体验。本文主要将进入 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Windows 10 中包含了一个 WSL（Windows Subsystem for Linux）子系统，我们可以在其中运行未经修改过的原生 Linux ELF 可执行文件。利用它我们可以做很多事情，对开发人员和普通用户都是如此。当然对开发人员的吸引力更大一些，因为这意味着在一些情况，不再需要使用 Linux 虚拟机、双系统、Cygwin/MSYS2 了。&lt;/p&gt;
&lt;p&gt;当前版本（14901.1000）Windows 10 中的 WSL 功能已经比较完善了，和刚出来时不可同日而语，也不再是一个没有实用价值的玩具了（最初的版本连 zsh 和 tmux 等最基本的工具都无法运行，基本没有可用性。但如果现在依然说 WSL 不可用，就有失偏颇了）。但对不想折腾的普通用户来说，用户体验并不好。其实我们可以做一些优化，最终效果是在仅损失少量可接受的代价的前提下，达到接近完美的体验。本文主要将进入 WSL 环境的多种方式，以及简单比较不同方式之间的优缺点。&lt;/p&gt;
&lt;h2&gt;直接运行 bash&lt;/h2&gt;
&lt;p&gt;最简单直接的方法是 &lt;code&gt;Win + R&lt;/code&gt; 输入 bash 直接进入。但这样右键（很可能）不可用，复制粘贴很麻烦（需要在标题栏右键菜单中选择编辑）。而先进入 cmd 或者 powershell 后，再运行 bash，这样复制和粘贴进方便了很多。尤其是先进入 powershell 再运行 bash，可以鼠标选择复制，右键直接粘贴。我们可以直接 &lt;code&gt;Win + R&lt;/code&gt; 输入 &lt;code&gt;powershell -c bash ~&lt;/code&gt; 进入。但从 powershell 进入会有额外的问题，一些程序的显示可能会出现异常。&lt;/p&gt;
&lt;p&gt;直接运行 bash 的好处是性能最好，资源占用最低，交互（比如在资源管理器打开 bash 并定位到当前目录，或者直接双击 .sh 脚本用 bash 运行等）也更容易实现。但有一个严重的问题，就是无法输入中文，显示中文也会出现重叠或者截断的情况。此外还有复制粘贴麻烦，而且只支持 16 种颜色等问题。可定制性也很弱，这样的终端用户体验上很差的。如果只给我这样一个环境使用，即使所有的 Linux 软件都能正常运行，我也是没办法接受的。这恐怕也是 WSL 最让人诟病的地方，第一印象就不是很好。&lt;/p&gt;
&lt;h2&gt;使用 wsl-terminal&lt;/h2&gt;
&lt;p&gt;wsl-terminal 是专门为 WSL 准备的终端模拟器，主体是 mintty，另外整合了一些工具，使用起来非常方便，也是目前用户体验最好的，大小也只有 1M 多，推荐使用。使用方法见官方主页，地址：https://github.com/goreliu/wsl-terminal。 &lt;/p&gt;
&lt;p&gt;实现方面，这个方法是由在 WSL 里启动 sshd，然后使用 ssh 客户端登录的方法改进的。它的运行机制和 ssh 有很大的的区别。mintty 会运行 wslbridge，wslbridge 包含两个程序，wslbridge.exe 和 wslbridge-backend。从文件名可以看出来，前者是 Windows 程序，后者是 Linux 程序。wslbridge.exe 会在一个隐藏窗口运行 bash.exe 进入 WSL 环境，在其中运行相同目录下的 wslbridge-backend。wslbridge.exe 和 wslbridge-backend 之间会建立三个 tcp 连接，也就是将 stdin、stdout、stderr 分别通过三个 tcp 连接联系起来，连接建立后就不再监听任何端口了。而 mintty 就是一个终端模拟器，对它来说 wslbridge 和 ssh 没有什么区别。&lt;/p&gt;
&lt;p&gt;性能上，在我这里用 wslbridge 和 ssh 执行命令的速度是差不多的，前者稍微快一点，不明显。资源占用上，前者占优。&lt;/p&gt;
&lt;p&gt;使用的方便程度上，明显 wslbridge 占优。不再需要启动 sshd，配置信任关系等。另外 wslbridge 会自动将当前路径传递进去，不需要自己转换路径然后拼接 cd 命令，这样方便了许多。而且可以直接通过参数传递环境变量。我之前写的几个脚本减少了数十行。&lt;/p&gt;
&lt;h2&gt;使用 ConEmu 等终端模拟器&lt;/h2&gt;
&lt;p&gt;ConEmu（包括基于 ConEmu 修改的 cmder） 等终端模拟器也已经开始适配 WSL 环境，使用它复制粘贴更加方便（可以鼠标选择时直接复制，右键直接粘贴），也能输入中文了。但中文显示还是有问题（但比直接运行 bash.exe 要好一些），比如一个中文字符要比两个英文字符宽（在 vim 等地方），输入中文然后退格删除会删除到前边的字符（在 bash、zsh 等地方）。另外 ConEmu 更漂亮，界面上的功能更多（比如支持标签页，可以配置很多东西等）。除此之外和直接运行 bash 是一样的，比如颜色支持上。另外这个环境对 Linux 命令输出显示的兼容性不如直接运行 bash，某些命令的输出是有问题的（比如 top 命令中的反色显示会丢失）。&lt;/p&gt;
&lt;p&gt;另外和 ConEmu 类似的是使用 Cygwin/MSYS2 的 mintty -e winpty bash。这个和 ConEmu 的问题类似，中文显示输入、颜色等地方同样存在问题。并且我实际测试时发现 mintty -e winpty bash 比 mintty -e ssh 127.0.0.1 还要慢，基本上没有什么优势。winpty 和 wslbridge 是同一个人写的，不需要考虑使用 winpty 了。&lt;/p&gt;
&lt;h2&gt;在 WSL 中开启 sshd，ssh 上去使用&lt;/h2&gt;
&lt;p&gt;（和 mintty + wslbridge 相比，在本机访问的话，ssh 基本上已经没有什么优势了。把 Cygwin/MSYS2 裁剪成 ssh 客户端，也不需要折腾了，相关内容我就不删了。） &lt;/p&gt;
&lt;p&gt;还有一种办法是在 WSL 中开启 sshd，使用 ssh 客户端登录上去使用，就像使用本地 Linux 虚拟机或者 VPS 那样。&lt;/p&gt;
&lt;p&gt;目前 ssh 上去的环境是没有任何问题的，包括中文显示输入、颜色、命令输出等。但这样也有一些问题，比如需要一个常驻的 sshd（可以使用更轻量级的 dropbear），并且使用起来不是很方便，尤其是在涉及交互的场景（比如在资源管理器创建一个 .sh 脚本，然后用 WSL 执行），需要写若干辅助的脚本。启动速度也比直接运行 bash 要慢，但如果选择轻量级的 ssh 客户端的话，使用起来还是比较容易接受的。&lt;/p&gt;
&lt;p&gt;在 ssh 客户端的选择上，首先如果不是一直开着，secureCRT、XShell 之类比较重量级的 ssh 客户端是不大合适了，启动比较慢，体积比较大，资源占用也多，有点大材小用了。PuTTY 是一个选择，在启动速度、资源占用、文件体积上都比较出色，但功能上就存在一些问题。比如我想在资源管理器任意一个目录运行 PuTTY，并且在 WSL 中定位到当前目录，或者执行一个临时拼凑出的命令，就比较难实现（也不是完全实现不了，比如可以每次都修改一次注册表，或者通过临时文件传递路径和命令）。另外 PuTTY 的官方版本不支持 24-bit 颜色，虽然有其他版本支持，但 PuTTY 的修改版很混乱，很难找一个各方面都很出色的版本。PuTTY 的易用性也存在问题，比如会话的载入和保存功能，很多人都会在这上面吃亏，丢失了已经填好的配置，配置信任关系比较麻烦，，基本上不上网搜索是很难仅从设置界面看明白是怎么用的，加密方法的支持也不完善。&lt;/p&gt;
&lt;p&gt;其实还有一个容易被大家忽略的选择，是在 Cygwin/MSYS2 中的 mintty 使用 ssh。不过也难怪，安装 Cygwin 或者 MSYS2 都是比较麻烦的，而且至少会占用几百兆空间。但其实如果只裁剪一个最小的环境当成 ssh 客户端使用，仅需要不到 10M 的空间（压缩后只有 3M 左右，其中还包括了维护用的 dash、ls、cat、rm 等命令），比起 PuTTY 的 500K 自然大了不少，但比起 secureCRT、XShell 等还是要轻量级一些的。mintty 界面简洁，配置方便，中文显示输入、颜色支持上没有任何问题。更重要的是直接用 ssh 命令非常灵活，可以临时拼凑命令然后执行， 使用和 Linux 下相同的方式建立信任关系等。并且 mintty 启动快，资源占用少，虽然每次都要运行 ssh 登陆，但速度也是可以接受了。不支持标签页的问题，可以用在 WSL 里运行 tmux 来解决，这样启动 mintty 还会更快一些，而且 mintty 退出后环境还在保持。&lt;/p&gt;
&lt;p&gt;裁剪 Cygwin/MSYS2 的办法：&lt;/p&gt;
&lt;p&gt;这里以 MSYS2 为例，简单讲下如何把几百兆的 MSYS2 裁剪成不到 10M 的 ssh 客户端。&lt;/p&gt;
&lt;p&gt;安装 MSYS2 后，用 &lt;code&gt;pacman -S openssh&lt;/code&gt; 安装 openssh，其他的基本不需要额外安装了。&lt;/p&gt;
&lt;p&gt;然后再另一个目录（这里以 &lt;code&gt;c:\sshclient&lt;/code&gt; 为例，这个目录在哪不重要，使用的时候是可以随意移动的）下创建 5 个目录：dev、etc、tmp、usr、home。&lt;/p&gt;
&lt;p&gt;将 MSYS2 中 &lt;code&gt;/etc/passwd&lt;/code&gt; 文件放置到 &lt;code&gt;c:\sshclient\etc&lt;/code&gt; 下，可以修改下这个文件，只保留直接当前使用的用户名，shell 也改成自己用的 shell（比如最轻量的 dash），home 目录也设置好。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;c:\sshclient\usr&lt;/code&gt; 目录下创建 &lt;code&gt;bin&lt;/code&gt;，然后把 MSYS2 中 &lt;code&gt;/usr/bin&lt;/code&gt; 里的这些文件复制过去：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cat.exe
cygwin-console-helper.exe
dash.exe
ls.exe
mintty.exe
msys-2.0.dll
msys-asn1-8.dll
msys-com_err-1.dll
msys-crypt-0.dll
msys-crypto-1.0.0.dll
msys-gcc_s-seh-1.dll
msys-gssapi-3.dll
msys-heimbase-1.dll
msys-heimntlm-0.dll
msys-hx509-5.dll
msys-iconv-2.dll
msys-intl-8.dll
msys-krb5-26.dll
msys-roken-18.dll
msys-sqlite3-0.dll
msys-ssp-0.dll
msys-wind-0.dll
msys-z.dll
rm.exe
ssh.exe
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要记的只有 mintty.exe、ssh.exe、dash.exe、cygwin-console-helper.exe，这些 dll 文件可以根据错误提示来拷贝，其他命令根据自己的喜好。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;c:\sshclient\home\username\.ssh&lt;/code&gt; 里写好 ssh 的配置文件，就大功告成了。运行 mintty，输入 /usr/bin/ssh 127.0.0.1 即可。但要想好用还需要写一些额外的工具，比如用右键菜单在指定的目录打开 、将 .sh 脚本的打开方式改成 mintty、用 WSL 里的 vim 编辑资源管理器中选定的文件等。&lt;/p&gt;
&lt;p&gt;最后截图纪念一下。显示的是 Arch Linux 系统，因为我把默认的 Ubunt 14.04 的文件全部换成 Arch Linux 的了，而且运行良好（安装方式：https://github.com/Microsoft/BashOnWindows/issues/8#issuecomment-240026910）。另外可以注意到左下角的窗口，wcmd 可以直接运行 Windows 的 ipconfig 命令，这得益于 &lt;a href="https://github.com/xilun/cbwin"&gt;cbwin&lt;/a&gt; 项目，虽然是使用的是在 Windows 运行一个守护进程，监听 127.0.0.1 的某一个端口，然后 WSL 中的 wcmd、wrun、wstart 命令通过 TCP 发送命令和采集结果，速度上还是可以接受的，运行命令或者图形界面软件都没有问题。在微软官方没有支持在 WSL 里直接运行 Windows 软件的情况下，是一个不错的替代方式。它要明显比在 Windows 下开 SSH Server 要快，而且使用起来更方便。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/028.png"&gt;&lt;/p&gt;</content></entry><entry><title>让 MSYS2 支持 cygstart</title><link href="/rang-msys2-zhi-chi-cygstart.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/rang-msys2-zhi-chi-cygstart.html</id><summary type="html">&lt;p&gt;Cygwin中有一个很有用的工具，&lt;code&gt;cygstart&lt;/code&gt;，可以使用默认的程序打开任意文件，以及使用超级管理员运行命令（&lt;code&gt;cygstart --action=runas&lt;/code&gt;）等。但msys2每个这个命令，使用超级管理员运行命令的功能几乎没有替代品。&lt;/p&gt;
&lt;p&gt;但后来我想到既然msys2是从cygwin改的，应该也能编译出来&lt;code&gt;cygstart&lt;/code&gt;，折腾一番后果然可以。&lt;/p&gt;
&lt;p&gt;首先需要一个popt，PKGBUILD：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;# Maintainer: Gore Liu &amp;lt;goreliu@126.com&amp;gt;&lt;/span&gt;

&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;popt&lt;/span&gt;
&lt;span class="n"&gt;pkgver&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;1.16&lt;/span&gt;
&lt;span class="n"&gt;pkgrel&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;
&lt;span class="n"&gt;pkgdesc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A commandline option parser&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;arch&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;i686&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="n"&gt;x86_64&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://rpm5.org&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;license&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;custom&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//rpm5.org/files/${pkgname}/${pkgname …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;Cygwin中有一个很有用的工具，&lt;code&gt;cygstart&lt;/code&gt;，可以使用默认的程序打开任意文件，以及使用超级管理员运行命令（&lt;code&gt;cygstart --action=runas&lt;/code&gt;）等。但msys2每个这个命令，使用超级管理员运行命令的功能几乎没有替代品。&lt;/p&gt;
&lt;p&gt;但后来我想到既然msys2是从cygwin改的，应该也能编译出来&lt;code&gt;cygstart&lt;/code&gt;，折腾一番后果然可以。&lt;/p&gt;
&lt;p&gt;首先需要一个popt，PKGBUILD：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;# Maintainer: Gore Liu &amp;lt;goreliu@126.com&amp;gt;&lt;/span&gt;

&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;popt&lt;/span&gt;
&lt;span class="n"&gt;pkgver&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;1.16&lt;/span&gt;
&lt;span class="n"&gt;pkgrel&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;
&lt;span class="n"&gt;pkgdesc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A commandline option parser&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;arch&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;i686&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="n"&gt;x86_64&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://rpm5.org&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;license&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;custom&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//rpm5.org/files/${pkgname}/${pkgname}-${pkgver}.tar.gz)&lt;/span&gt;
&lt;span class="n"&gt;sha1sums&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;cfe94a15a2404db85858a81ff8de27c8ff3e235e&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${srcdir}/${pkgname}-${pkgver}&amp;quot;&lt;/span&gt;
  &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;

  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;grep&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="err"&gt;$&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;poptconfig&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;wc&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ne&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt;
      &lt;span class="n"&gt;exit&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
  &lt;span class="n"&gt;fi&lt;/span&gt;
  &lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/^&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;poptconfig&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;

  &lt;span class="n"&gt;make&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${srcdir}/${pkgname}-${pkgver}&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;DESTDIR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;${pkgdir}&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt;
  &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Dm644&lt;/span&gt; &lt;span class="n"&gt;COPYING&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${pkgdir}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;share&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;licenses&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;LICENSE&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后就是包含cygstart的cygutils，PKGBUILD：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;# Maintainer: Gore Liu &amp;lt;goreliu@126.com&amp;gt;&lt;/span&gt;

&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;cygutils&lt;/span&gt;
&lt;span class="n"&gt;pkgver&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;1.4.14&lt;/span&gt;
&lt;span class="n"&gt;pkgrel&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;pkgdesc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;A collection of simple cygwin utilities&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;arch&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;i686&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="n"&gt;x86_64&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://cygutils.fruitbat.org/cygutils-package/index.html&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;license&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;custom&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;depends&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;popt&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;source&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://mirror.bit.edu.cn/cygwin/x86_64/release/cygutils/${pkgname}-${pkgver}-1-src.tar.bz2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;sha1sums&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;f9f5ae35ba61aa6efccf9581c2b019c26ea6671a&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${srcdir}&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;tar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;xf&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pkgver&lt;/span&gt;&lt;span class="p"&gt;}.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xz&lt;/span&gt;
  &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pkgver&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;configure&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;
  &lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;stricmp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;strcasecmp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;src&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lpr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Printer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cc&lt;/span&gt;

  &lt;span class="n"&gt;make&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;package&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${srcdir}/${pkgname}-${pkgver}&amp;quot;&lt;/span&gt;
  &lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;DESTDIR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;${pkgdir}&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt;
  &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Dm644&lt;/span&gt; &lt;span class="n"&gt;COPYING&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${pkgdir}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;share&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;licenses&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;pkgname&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;LICENSE&lt;/span&gt;
  &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="n"&gt;find&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exe&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="n"&gt;cp&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;${pkgdir}&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
  &lt;span class="n"&gt;done&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;依次保存为PKGBUILD文件，运行&lt;code&gt;makepkg&lt;/code&gt;，然后使用&lt;code&gt;pacman auto -U *.pkg.*&lt;/code&gt;就可以了。&lt;/p&gt;
&lt;p&gt;更多的msys2包，https://github.com/goreliu/my-MSYS2-Packages。官方的repo对于msys2分支的PKGBUILD要求很苛刻，基本不收，之后自己维护了。如果有朋友有其他的PKGBUILD，可以一起维护。&lt;/p&gt;</content></entry><entry><title>使用 wsl terminal 更好地体验 Win 10 WSL 终端环境</title><link href="/shi-yong-wsl-terminal-geng-hao-di-ti-yan-win-10-wsl-zhong-duan-huan-jing.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/shi-yong-wsl-terminal-geng-hao-di-ti-yan-win-10-wsl-zhong-duan-huan-jing.html</id><summary type="html">&lt;p&gt;WSL 从最初功能不全 bug 遍地都是，到现在除了少数几个比较顽固的 bug 外，基本足以正常使用了。但自带终端模拟器的体验依然非常糟糕，而且在可以预期的未来都不会有太大的长进了。我是从去年 8 月开始开发 &lt;a href="https://goreliu.github.io/wsl-terminal/"&gt;wsl-terminal&lt;/a&gt;（&lt;a href="https://goreliu.github.io/wsl-terminal/README.zh_CN.html"&gt;中文页面&lt;/a&gt;）的，期间因为想不到可以添加什么功能而搁置了比较长时间。最近心血来潮，添加了很多实用功能，用户体验也会上升很多。&lt;/p&gt;
&lt;p&gt;希望有在使用的朋友可以多反馈下意见建议，如果之前没有尝试过，也可以体验一下，软件是一个 1.6 MB 的压缩包，解压后即可使用，不会往系统中写入任何东西（如果想添加到开始菜单或者右键菜单，可以使用 tools 中的工具）。&lt;/p&gt;
&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;用于 Windows Subsystem for Linux (WSL) 的终端模拟器，基于 &lt;a href="http://mintty.github.io/"&gt;mintty&lt;/a&gt; 和 &lt;a href="https://github.com/rprichard/wslbridge"&gt;wslbridge&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;截图&lt;/h3&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/030.png"&gt;&lt;/p&gt;
&lt;p&gt;查看&lt;a href="https://github.com/goreliu/wsl-terminal/wiki/Screenshots"&gt;更多截图&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;用法 …&lt;/h3&gt;</summary><content type="html">&lt;p&gt;WSL 从最初功能不全 bug 遍地都是，到现在除了少数几个比较顽固的 bug 外，基本足以正常使用了。但自带终端模拟器的体验依然非常糟糕，而且在可以预期的未来都不会有太大的长进了。我是从去年 8 月开始开发 &lt;a href="https://goreliu.github.io/wsl-terminal/"&gt;wsl-terminal&lt;/a&gt;（&lt;a href="https://goreliu.github.io/wsl-terminal/README.zh_CN.html"&gt;中文页面&lt;/a&gt;）的，期间因为想不到可以添加什么功能而搁置了比较长时间。最近心血来潮，添加了很多实用功能，用户体验也会上升很多。&lt;/p&gt;
&lt;p&gt;希望有在使用的朋友可以多反馈下意见建议，如果之前没有尝试过，也可以体验一下，软件是一个 1.6 MB 的压缩包，解压后即可使用，不会往系统中写入任何东西（如果想添加到开始菜单或者右键菜单，可以使用 tools 中的工具）。&lt;/p&gt;
&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;用于 Windows Subsystem for Linux (WSL) 的终端模拟器，基于 &lt;a href="http://mintty.github.io/"&gt;mintty&lt;/a&gt; 和 &lt;a href="https://github.com/rprichard/wslbridge"&gt;wslbridge&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;截图&lt;/h3&gt;
&lt;p&gt;&lt;img alt="screenshot" src="/images/030.png"&gt;&lt;/p&gt;
&lt;p&gt;查看&lt;a href="https://github.com/goreliu/wsl-terminal/wiki/Screenshots"&gt;更多截图&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;用法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从&lt;a href="https://github.com/goreliu/wsl-terminal/releases"&gt;这里&lt;/a&gt;下载最新版本并解压。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;open-wsl.exe&lt;/code&gt; 可以在当前目录打开一个 WSL 终端模拟器（wsl-terminal 需要放置在本地的 NTFS 分区上，&lt;a href="https://github.com/rprichard/wslbridge#building-wslbridge"&gt;原因&lt;/a&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行 &lt;code&gt;tools/1-add-open-wsl-terminal-here-menu.js&lt;/code&gt; (&lt;a href="https://github.com/goreliu/wsl-terminal/blob/master/README.zh_CN.md#工具"&gt;帮助&lt;/a&gt;) 来添加一个 &lt;code&gt;Open wsl-terminal Here&lt;/code&gt; 右键菜单到资源管理器上 (运行 &lt;code&gt;tools/1-remove-open-wsl-terminal-here-menu.js&lt;/code&gt; 可以将其删除）。 如果你使用 Total Commander, 可以参考 &lt;a href="https://github.com/goreliu/wsl-terminal/wiki/Use-wsl-terminal-with-Total-Commander"&gt;在 Total Commander 中使用 wsl-terminal&lt;/a&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;run-wsl-file.exe&lt;/code&gt; 可以在 wsl-terminal 里运行任何 &lt;code&gt;.sh&lt;/code&gt; （以及任何其他的可执行文件，比如 &lt;code&gt;.py&lt;/code&gt; &lt;code&gt;.pl&lt;/code&gt; 文件) 脚本文件，你可以在文件打开方式里设置使用它来打开文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vim.exe&lt;/code&gt; 可以使用 WSL 中的 vim 打开任何文件 (在 wsl-terminal 中)，支持在打开方式中配置。如果你使用其他编辑器，可以把 &lt;code&gt;vim.exe&lt;/code&gt; 重命名成  &lt;code&gt;emacs.exe&lt;/code&gt; &lt;code&gt;nvim.exe&lt;/code&gt;  &lt;code&gt;nano.exe&lt;/code&gt; 等等，会调用对应的编辑器打开。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;快捷键&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Alt + Enter&lt;/code&gt;: 全屏&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Alt + F2&lt;/code&gt;: 新建窗口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Alt + F3&lt;/code&gt;: 搜索文本&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ctrl + [Shift] + Tab&lt;/code&gt;: 切换窗口&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ctrl + =+/-/0&lt;/code&gt;: 缩放&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ctrl + Click&lt;/code&gt;: 打开光标处的文件、目录名或者网址&lt;/p&gt;
&lt;h3&gt;命令行参数&lt;/h3&gt;
&lt;h4&gt;open-wsl&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;用法&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;wsl&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="err"&gt;选项&lt;/span&gt;&lt;span class="o"&gt;]...&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;激活在运行的&lt;/span&gt; &lt;span class="n"&gt;wsl&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;terminal&lt;/span&gt; &lt;span class="err"&gt;窗口。&lt;/span&gt;
      &lt;span class="err"&gt;如果&lt;/span&gt; &lt;span class="n"&gt;use_tmux&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;，会&lt;/span&gt; &lt;span class="n"&gt;attach&lt;/span&gt; &lt;span class="err"&gt;到正在运行的&lt;/span&gt; &lt;span class="n"&gt;tmux&lt;/span&gt; &lt;span class="err"&gt;会话上。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;运行一个&lt;/span&gt; &lt;span class="n"&gt;login&lt;/span&gt; &lt;span class="n"&gt;shell&lt;/span&gt;&lt;span class="err"&gt;（如果&lt;/span&gt; &lt;span class="n"&gt;use_tmux&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="err"&gt;则失效）。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;command&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;运行&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt; &lt;span class="err"&gt;中的命令。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;进入到&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt; &lt;span class="err"&gt;目录中，&lt;/span&gt;&lt;span class="n"&gt;WSL&lt;/span&gt; &lt;span class="err"&gt;目录（例如&lt;/span&gt; &lt;span class="sr"&gt;/home/&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="err"&gt;）。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;W&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;进入到&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt; &lt;span class="err"&gt;目录中，&lt;/span&gt;&lt;span class="n"&gt;Windows&lt;/span&gt; &lt;span class="err"&gt;目录（例如&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;:\&lt;/span&gt;&lt;span class="n"&gt;Users&lt;/span&gt;&lt;span class="o"&gt;\&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="n"&gt;distro&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;切换发行版。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;options&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;传递额外的选项给&lt;/span&gt; &lt;span class="n"&gt;wslbridge&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;options&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;传递额外的选项给&lt;/span&gt; &lt;span class="n"&gt;mintty&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;显示帮助信息。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;-B&lt;/code&gt; 和 &lt;code&gt;-b&lt;/code&gt; 后可以添加的选项，请参考 &lt;a href="https://github.com/goreliu/wsl-terminal/wiki/mintty-params"&gt;mintty 参数&lt;/a&gt; 和 &lt;a href="https://github.com/rprichard/wslbridge#usage"&gt;wslbridge 参数&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;cmdtool（在 WSL 中运行）&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;用法&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;cmdtool&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="err"&gt;选项&lt;/span&gt;&lt;span class="o"&gt;]...&lt;/span&gt;
  &lt;span class="n"&gt;wcmd&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;使用&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;exe&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="err"&gt;运行&lt;/span&gt; &lt;span class="n"&gt;Windows&lt;/span&gt; &lt;span class="err"&gt;程序。&lt;/span&gt;
  &lt;span class="n"&gt;wstart&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;使用&lt;/span&gt; &lt;span class="n"&gt;cmd&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;exe&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="err"&gt;运行&lt;/span&gt; &lt;span class="n"&gt;Windows&lt;/span&gt; &lt;span class="err"&gt;程序。&lt;/span&gt;
  &lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;检查更新，如果有更新可以直接升级。&lt;/span&gt;
  &lt;span class="n"&gt;killall&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;杀死所有的&lt;/span&gt; &lt;span class="n"&gt;WSL&lt;/span&gt; &lt;span class="err"&gt;进程。&lt;/span&gt;
  &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;cbwin&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;安装&lt;/span&gt; &lt;span class="n"&gt;cbwin&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
  &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;dash&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;安装&lt;/span&gt; &lt;span class="n"&gt;Cygwin&lt;/span&gt; &lt;span class="err"&gt;中的&lt;/span&gt; &lt;span class="n"&gt;dash&lt;/span&gt;&lt;span class="err"&gt;（用于调试）。&lt;/span&gt;
  &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;busybox&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;安装&lt;/span&gt; &lt;span class="n"&gt;Cygwin&lt;/span&gt; &lt;span class="err"&gt;中的&lt;/span&gt; &lt;span class="n"&gt;busybox&lt;/span&gt;&lt;span class="err"&gt;（用于调试）。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;工具&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tools&lt;/code&gt; 目录下的工具：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件名&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1-add-open-wsl-terminal-here-menu.js&lt;/td&gt;
&lt;td&gt;添加 &lt;code&gt;Open wsl-terminal Here&lt;/code&gt; 右键菜单到资源管理器上。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1-remove-open-wsl-terminal-here-menu.js&lt;/td&gt;
&lt;td&gt;移除 &lt;code&gt;Open wsl-terminal Here&lt;/code&gt; 右键菜单。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2-add-wsl-terminal-dir-to-path.js&lt;/td&gt;
&lt;td&gt;将 &lt;code&gt;wsl-terminal&lt;/code&gt; 目录添加到 &lt;code&gt;Path&lt;/code&gt; 环境变量里。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2-remove-wsl-terminal-dir-from-path.js&lt;/td&gt;
&lt;td&gt;从 &lt;code&gt;Path&lt;/code&gt; 环境变量中移除 &lt;code&gt;wsl-terminal&lt;/code&gt; 目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3-write-distro-guids-to-config-file.js&lt;/td&gt;
&lt;td&gt;将所有发行版的 guid 写入到配置文件 &lt;code&gt;etc/wsl-terminal.conf&lt;/code&gt; 中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4-create-start-menu-shortcut.js&lt;/td&gt;
&lt;td&gt;创建一个开始菜单快捷方式，指向 &lt;code&gt;open-wsl -C ~&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4-create-start-menu-shortcut-login-shell.js&lt;/td&gt;
&lt;td&gt;创建一个开始菜单快捷方式，指向 &lt;code&gt;open-wsl -l&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4-remove-all-start-menu-shortcuts.js&lt;/td&gt;
&lt;td&gt;移除所有 wsl-terminal 的开始菜单快捷方式。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;双击 &lt;code&gt;.js&lt;/code&gt; 文件即可运行。如果 &lt;code&gt;.js&lt;/code&gt; 文件被某个编辑器关联上了，可以修改打开方式为 &lt;code&gt;Microsoft (R) Windows Based Script Host&lt;/code&gt;，或者在 &lt;code&gt;tools&lt;/code&gt; 目录运行一个 &lt;code&gt;cmd.exe&lt;/code&gt;，然后用 &lt;code&gt;wscript xxx.js&lt;/code&gt; 运行对应文件。&lt;/p&gt;
&lt;h3&gt;配置文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;etc/wsl-terminal.conf&lt;/code&gt; 是 wsl-terminal 的配置文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[config]&lt;/span&gt;
&lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;窗口标题&amp;quot;&lt;/span&gt;
&lt;span class="na"&gt;shell&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;bash&lt;/span&gt;
&lt;span class="na"&gt;use_tmux&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;0&lt;/span&gt;
&lt;span class="c1"&gt;;icon=&lt;/span&gt;
&lt;span class="c1"&gt;;distro_guid=&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;etc/themes/&lt;/code&gt; 目录下的是主题文件，&lt;a href="https://github.com/goreliu/wsl-terminal/wiki/Use-themes"&gt;使用主题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;etc/minttyrc&lt;/code&gt; 是 mintty 的配置文件， &lt;a href="https://github.com/mintty/mintty/wiki/Tips"&gt;mintty 帮助&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;升级&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;wsl-terminal&lt;/code&gt; 里打开 &lt;code&gt;open-wsl.exe&lt;/code&gt;，然后运行 &lt;code&gt;./cmdtool update&lt;/code&gt;  可以检查 wsl-terminal 的最新版本然后升级。如果下载速度过慢，可以先使用其他方法从&lt;a href="https://github.com/goreliu/wsl-terminal/releases"&gt;发布页面&lt;/a&gt;下载 &lt;code&gt;wsl-terminal-v{version}.7z&lt;/code&gt; 文件，然后将其放入到 &lt;code&gt;wsl-terminal&lt;/code&gt; 目录，然后运行 &lt;code&gt;./cmdtool update&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该工具依赖 &lt;code&gt;wget&lt;/code&gt; 和 &lt;code&gt;7z&lt;/code&gt; 命令（安装方法。Ubuntu: &lt;code&gt;apt install wget p7zip-full&lt;/code&gt;, Archlinux: &lt;code&gt;pacman -S wget p7zip&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;升级过程不会覆盖配置文件，&lt;code&gt;etc/wsl-terminal.conf&lt;/code&gt; 和 &lt;code&gt;etc/minttyrc&lt;/code&gt; 会被放置到 &lt;code&gt;etc/wsl-terminal.conf.pacnew&lt;/code&gt; 和 &lt;code&gt;etc/minttyrc.pacnew&lt;/code&gt;。升级后 &lt;code&gt;bin&lt;/code&gt; 目录会残余一些 &lt;code&gt;.bak&lt;/code&gt; 文件，因为这些文件还在运行，不能被删除。下一次升级时，会将之前的 &lt;code&gt;.bak&lt;/code&gt; 文件全部删除，你也可以等那些进程退出后手删除那些文件。&lt;/p&gt;
&lt;h3&gt;使用 tmux&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在 WSL 里安装 tmux。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;etc/wsl-terminal.conf&lt;/code&gt; 中设置 &lt;code&gt;use_tmux=1&lt;/code&gt;。如果版本号低于 &lt;code&gt;0.8.1&lt;/code&gt;，还需要添加 &lt;code&gt;attach_tmux_locally=1&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加如下代码到 &lt;code&gt;~/.bashrc&lt;/code&gt;（如果配置的是 &lt;code&gt;shell=bash&lt;/code&gt;）或者 &lt;code&gt;~/.zshrc&lt;/code&gt;（如果配置的是 &lt;code&gt;shell=zsh&lt;/code&gt;）：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[[ -z &amp;quot;$TMUX&amp;quot; &amp;amp;&amp;amp; -n &amp;quot;$USE_TMUX&amp;quot; ]] &amp;amp;&amp;amp; {
    [[ -n &amp;quot;$ATTACH_ONLY&amp;quot; ]] &amp;amp;&amp;amp; {
        tmux a 2&amp;gt;/dev/null || {
            cd &amp;amp;&amp;amp; exec tmux
        }
        exit
    }

    tmux new-window -c &amp;quot;$PWD&amp;quot; 2&amp;gt;/dev/null &amp;amp;&amp;amp; exec tmux a
    exec tmux
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后 &lt;code&gt;open-wsl&lt;/code&gt; 就会使用 tmux 了。&lt;/p&gt;
&lt;h3&gt;切换发行版&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;open-wsl -d distro&lt;/code&gt; （在 &lt;code&gt;cmd.exe&lt;/code&gt; 里运行）来切换发行版：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 列出所有发行版
&amp;gt; wslconfig /l
Legacy (默认)
Ubuntu

# 使用 Ubuntu（会运行 wslconfig /s Ubuntu 然后打开 wsl-terminal）
&amp;gt; open-wsl -d Ubuntu

# Ubuntu 已经是默认的发行版了
&amp;gt; wslconfig /l
Ubuntu (默认)
Legacy
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你不想修改默认的发行版，可以在 &lt;code&gt;etc/wsl-terminal.conf&lt;/code&gt; 里设置 &lt;code&gt;distro_guid&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;运行 &lt;code&gt;tools/3-write-distro-guids-to-config-file.js&lt;/code&gt;（&lt;a href="https://github.com/goreliu/wsl-terminal/blob/master/README.zh_CN.md#工具"&gt;帮助&lt;/a&gt;），然后会有窗口弹出结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;result has been written to ..\etc\wsl-terminal.conf:

; Legacy
;distro_guid={12345678-1234-5678-0123-456789abcdef}

; Ubuntu
;distro_guid={47a89313-4300-4678-96ae-e53c41a79e03}

remove the ; before distro_guid to use the distro.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以去掉 distro_guid 前边的 ; 来使用对应的发行版。&lt;/p&gt;
&lt;p&gt;如果你想通过命令行将 distro_guid 传递给 &lt;code&gt;open-wsl&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# 将 distro guid 传递给 wslbridge
&amp;gt; open-wsl -b &amp;quot;--distro-guid {47a89313-4300-4678-96ae-e53c41a79e03}&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/goreliu/wsl-terminal/wiki/FAQ"&gt;常见问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/goreliu/wsl-terminal/wiki/TODO"&gt;开发计划&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;编译&lt;/h3&gt;
&lt;p&gt;确保已经在 WSL 里安装了这些 &lt;code&gt;wget&lt;/code&gt; &lt;code&gt;tar&lt;/code&gt; &lt;code&gt;xz&lt;/code&gt; &lt;code&gt;gzip&lt;/code&gt; &lt;code&gt;p7zip&lt;/code&gt; (安装方法。Ubuntu: &lt;code&gt;apt install wget tar xz-utils gzip p7zip-full&lt;/code&gt;, Archlinux: &lt;code&gt;pacman -S wget tar xz gzip p7zip&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;运行 &lt;code&gt;build.bat&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;许可&lt;/h3&gt;
&lt;p&gt;MIT&lt;/p&gt;</content></entry><entry><title>树莓派和其他 arm 开发板的本质区别</title><link href="/shu-mei-pai-he-qi-ta-arm-kai-fa-ban-de-ben-zhi-qu-bie.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/shu-mei-pai-he-qi-ta-arm-kai-fa-ban-de-ben-zhi-qu-bie.html</id><summary type="html">&lt;p&gt;我第一次听说树莓派时，并没有对它产生任何兴趣，因为对我来说这并不是一款新产品。在更早之前，我玩过 arm11 的开发板（S3C6410 系列），虽然和树莓派还是有区别的，比如体积更大、没有 HDMI 接口、自带触摸屏、价钱比树莓派稍贵等等，但我当时认为没有本质的不同，甚至性能和性价比上也不相上下。更重要的是，因为用户体验差和工作的原因，我的那块开发板在最初折腾几天后我就很少再用了，并且在两年前卖掉了。因此我对 arm 开发板的印象并不好，所以在之后的时间，我也没有关注树莓派的更新换代。&lt;/p&gt;
&lt;p&gt;&lt;img alt="我的那个 arm 开发板长这样，另外上边有块触摸屏" src="/images/029.jpg"&gt;&lt;/p&gt;
&lt;p&gt;几年之后，我又突然对树莓派感兴趣。我慢慢发现我当时的想法错了，因为那个错误的想法，我一直和本可以吸引我兴趣的树莓派失之交臂。&lt;/p&gt;
&lt;p&gt;树莓派的定位并不是一块用来做嵌入式开发的开发板，而是一个廉价并且高性价比的可以在一定程度取代 PC 并且硬件接口更丰富的软件开发和使用平台。有人可能会问，树莓派有 GPIO 接口，可以接很多硬件，怎么会是一个软件开发平台呢？那么我要问你 PC 有 USB 接口，可以接很多硬件，它是一个硬件开发平台吗？树莓派的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;我第一次听说树莓派时，并没有对它产生任何兴趣，因为对我来说这并不是一款新产品。在更早之前，我玩过 arm11 的开发板（S3C6410 系列），虽然和树莓派还是有区别的，比如体积更大、没有 HDMI 接口、自带触摸屏、价钱比树莓派稍贵等等，但我当时认为没有本质的不同，甚至性能和性价比上也不相上下。更重要的是，因为用户体验差和工作的原因，我的那块开发板在最初折腾几天后我就很少再用了，并且在两年前卖掉了。因此我对 arm 开发板的印象并不好，所以在之后的时间，我也没有关注树莓派的更新换代。&lt;/p&gt;
&lt;p&gt;&lt;img alt="我的那个 arm 开发板长这样，另外上边有块触摸屏" src="/images/029.jpg"&gt;&lt;/p&gt;
&lt;p&gt;几年之后，我又突然对树莓派感兴趣。我慢慢发现我当时的想法错了，因为那个错误的想法，我一直和本可以吸引我兴趣的树莓派失之交臂。&lt;/p&gt;
&lt;p&gt;树莓派的定位并不是一块用来做嵌入式开发的开发板，而是一个廉价并且高性价比的可以在一定程度取代 PC 并且硬件接口更丰富的软件开发和使用平台。有人可能会问，树莓派有 GPIO 接口，可以接很多硬件，怎么会是一个软件开发平台呢？那么我要问你 PC 有 USB 接口，可以接很多硬件，它是一个硬件开发平台吗？树莓派的 GPIO 接口，和 PC 的 USB 接口，没有本质的区别，都是用来连接硬件的，只是接口更底层一些。&lt;/p&gt;
&lt;p&gt;那么这样看，我之前用的 arm11 开发板，是否也是软件开发平台呢？答案是否定的，这要看目标用户。我们可以把目标用户简单分为三类：硬件开发者、软件开发者和使用者。硬件开发者主要是设计、改良硬件和为新老硬件编写驱动程序等等，软件开发者主要是在现有的硬件下开发软件（通常不包括驱动程序），使用者使用现有硬件和软件而不进行开发。&lt;/p&gt;
&lt;p&gt;我之前使用的 arm11 开发板，主要的目标用户是硬件开发者和软件开发者（可以不严谨地统称为嵌入式开发者），几乎没有使用者，因为对于没有开发经验的人，用户体验是很差的。而树莓派的主要目标用户是软件开发者（和嵌入式开发者有重叠但并不多）和使用者，用户体验很好，但几乎没有硬件开发者，因为树莓派的硬件相对比较封闭，不销售单独的 SoC 和其他芯片，硬件资料也并不是很完善，在硬件层面很难 DIY（对很底层的软件开发者也存在类似的问题）。&lt;/p&gt;
&lt;p&gt;那么目标用户的不同，就导致树莓派虽然看起来很像其他的 arm 开发板，基本也能用和其他的 arm 开发板一样的方式使用，性质却有很大的不同。&lt;/p&gt;
&lt;p&gt;这也解释了为什么很多嵌入式行业的软硬件开发者并不喜欢或者看好树莓派，甚至对它很不屑，而很多对嵌入式了解很少的开发者以及使用者会对树莓派趋之若鹜。&lt;/p&gt;
&lt;p&gt;那么我为什么会对树莓派感兴趣，而对之前那块 arm 开发板无感呢？最主要的问题并不是用户体验差，而是软件方面的配套环境不完善。最重要的是 Linux 内核版本支持。官方只提供低版本的 Linux 内核（2.6 系列），如果用这个内核来配合最新的发行版使用，几乎是不可能的，会遇到许多问题，一方面是这个内核缺少很多最新发行版使用的特性，另一方面是很多硬件方面的支持不只是替换内核文件和内核模块的事情（比如有些工具也需要移植），替换起来也麻烦。如果想使用更新版本的内核，需要打各种补丁以及自行修改代码，虽然硬件的资料比较齐全，理论上可以实现，但即使是经验丰富的嵌入式开发者也很难搞定，也没有人做好了提供给别人使用。这就导致几乎只能使用官方提高的老旧 Linux 镜像（或者其他古老版本的发行版）。而这个 Linux 环境几乎毫无用户体验可言，最新版本的软件很难安装上（几乎都需要自己编译，而且容易出现编译错误），常见的 USB 外设（比如摄像头、无线网卡、蓝牙）也很难驱动起来（运气好的话，可以从其他地方找来驱动代码，修复很可能出现的编译错误）。&lt;/p&gt;
&lt;p&gt;而树莓派的软件环境是很好的，基本可以使用最新的 Linux 内核和发行版（比如 Archlinux），并且有很多人为这个平台开发软件，用户体验有质的提升。即使是对嵌入式开发一窍不通的开发者或者使用者，也可以用树莓派做他们想做的事情。&lt;/p&gt;
&lt;p&gt;另外我发现一个有趣的事情，折腾树莓派的人群（至少在国内），和（曾经的） Linux 桌面用户群体很相似（我曾经混迹于 Linux 桌面用户社区，很多人折腾桌面美化、系统配置、工具优化、写小脚本等等，玩 Linux 而不是用 Linux），他们主要是使用者，可能稍微会一些脚本或者其他编程语言，但并没有独立开发完整应用程序的能力和意向。这和嵌入式开发者人群是很不同的。&lt;/p&gt;
&lt;p&gt;综上，树莓派和其他 arm 开发板的本质区别在于目标用户不同。树莓派的目标用户主要是软件开发者和使用者，而其他 arm 开发板的主要用户是硬件开发者和软件开发者。这也是树莓派能够吸引更多用户的一个重要原因。&lt;/p&gt;</content></entry><entry><title>我关于树莓派性能低的看法</title><link href="/wo-guan-yu-shu-mei-pai-xing-neng-di-de-kan-fa.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-guan-yu-shu-mei-pai-xing-neng-di-de-kan-fa.html</id><summary type="html">&lt;p&gt;树莓派被广为诟病的一个地方就是性能低（这里以树莓派 3b 为准，更早产品的性能确实不能满足很多场景的需求），性能包括 CPU、GPU、网络传输、USB 传输、SD 卡读写等诸多方面。很多人希望有一款高性能的树莓派，价格贵也没关系。我开始时也是这么想的，到处找和树莓派差不多但性能更好的设备，但找来找去没发现更满意的，有的接口太少，有的软件环境太糟糕，有的资料太少没有成熟的社区，各有各的问题。但我慢慢发现自己陷入到一个性能误区里。我需要更高的性能来做什么呢？如果不把需求明确了，那就很难找到能让自己满意的设备。&lt;/p&gt;
&lt;p&gt;于是我开始想树莓派有哪些优势，适合使用者哪些场景。然后我得出了一个结论，如果认为树莓派性能太差，那绝大多数情况都是选型时出了明显的问题。&lt;/p&gt;
&lt;p&gt;那些树莓派不适合的场景以及更优选择：&lt;/p&gt;
&lt;p&gt;1、用来当路由器&lt;/p&gt;
&lt;p&gt;不适原因：CPU/GPU、接口、软件平台资源浪费，网络性能不足。
更优选择：同价位（或者更便宜）的路由器。&lt;/p&gt;
&lt;p&gt;2、NAS&lt;/p&gt;
&lt;p&gt;不适原因：接口、软件平台资源浪费，网络性能 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;树莓派被广为诟病的一个地方就是性能低（这里以树莓派 3b 为准，更早产品的性能确实不能满足很多场景的需求），性能包括 CPU、GPU、网络传输、USB 传输、SD 卡读写等诸多方面。很多人希望有一款高性能的树莓派，价格贵也没关系。我开始时也是这么想的，到处找和树莓派差不多但性能更好的设备，但找来找去没发现更满意的，有的接口太少，有的软件环境太糟糕，有的资料太少没有成熟的社区，各有各的问题。但我慢慢发现自己陷入到一个性能误区里。我需要更高的性能来做什么呢？如果不把需求明确了，那就很难找到能让自己满意的设备。&lt;/p&gt;
&lt;p&gt;于是我开始想树莓派有哪些优势，适合使用者哪些场景。然后我得出了一个结论，如果认为树莓派性能太差，那绝大多数情况都是选型时出了明显的问题。&lt;/p&gt;
&lt;p&gt;那些树莓派不适合的场景以及更优选择：&lt;/p&gt;
&lt;p&gt;1、用来当路由器&lt;/p&gt;
&lt;p&gt;不适原因：CPU/GPU、接口、软件平台资源浪费，网络性能不足。
更优选择：同价位（或者更便宜）的路由器。&lt;/p&gt;
&lt;p&gt;2、NAS&lt;/p&gt;
&lt;p&gt;不适原因：接口、软件平台资源浪费，网络性能、USB 传输性能不足，并且预算太低。
更优选择：专用 NAS、x86 平台的台式机（可以选择二手的性价比更高，可以选择小机箱更省空间）、中高端家用路由器（如果要求不高）。&lt;/p&gt;
&lt;p&gt;3、接电视（或者显示器）看视频&lt;/p&gt;
&lt;p&gt;不适原因：接口、软件平台资源浪费，网络性能、GPU 性能、USB 传输性能不足。
更优选择：同价位的安卓盒子、稍贵的电脑棒、小机箱主机（如果要求较高）。&lt;/p&gt;
&lt;p&gt;4、学习 Linux&lt;/p&gt;
&lt;p&gt;不适原因：整体浪费，并且太麻烦。
更优选择：在电脑里运行 Linux 虚拟机，或者安装 Linux 实体机。&lt;/p&gt;
&lt;p&gt;5、跑消耗性能的软件&lt;/p&gt;
&lt;p&gt;不适原因：接口、软件平台资源浪费，各种性能不足，对口软件资源不足，太麻烦，预算太低。
更优选择：根据自己的应用场景，选择对应价位的 x86 台式机（可以选择二手的节省预算，可以选择小机箱节省空间）。&lt;/p&gt;
&lt;p&gt;6、接外设后替代电脑或者平板&lt;/p&gt;
&lt;p&gt;不适原因：各种性能不足，接口浪费，太麻烦，预算太低。
更优选择：根据实际情况选择对应价位的笔记本、台式机、平板电脑等。&lt;/p&gt;
&lt;p&gt;7、作为游戏机（玩复古的模拟器游戏除外）&lt;/p&gt;
&lt;p&gt;不适原因：游戏少，软件平台资源浪费，各种性能不足，接口浪费，预算太低。
更优选择：根据实际情况选择对应价位的游戏机或者台式机。&lt;/p&gt;
&lt;p&gt;8、依赖树莓派的接口或者平台，但同时需要跑消耗性能的软件&lt;/p&gt;
&lt;p&gt;不适原因：各种性能不足，预算太低。
更优选择：树莓派 + 对应价位的 x86 台式机（可以选择二手的节省预算，可以选择小机箱节省空间）。树莓派用来完成硬件操控、数据收集、数据简单处理、将数据通过网络传输给台式机。需要消耗性能的软件在台式机运行。&lt;/p&gt;
&lt;p&gt;9、看起来树莓派可以满足需求，但性能还差一些&lt;/p&gt;
&lt;p&gt;不适原因：性能不足，预算太低。
更优选择：可以同 8。也可以选择更贵的类似树莓派的的设备（比如微软的 UP board 系列），但平台生态环境并不是和树莓派一致（虽然硬件接口基本兼容），并且性价比不高（拿 UP board 来说，它的处理器是 Atom Z8350，价格要 1000 出头。但这个价位的 Z8350 电脑棒只有 500 多，电脑棒 + 树莓派 才 700 多，要比 UP board 性价比更高。而且如果配合使用，并没必要使用性能并不高的 Z8350），需要根据实际情况选择。&lt;/p&gt;
&lt;p&gt;10、用于组成批量出售的商业设备产品&lt;/p&gt;
&lt;p&gt;不适原因：成本太高，芯片不能单独购买，硬件资料不够开放。
更优选择：根据实际情况选择其他可以单独购买、有足够资料的硬件。&lt;/p&gt;
&lt;p&gt;总结起来分两种情况：&lt;/p&gt;
&lt;p&gt;1、不需要树莓派独有的功能，那么不需要考虑使用树莓派。
2、需要树莓派独有的功能，但性能太低，可以考虑树莓派加其他设备配合使用。&lt;/p&gt;
&lt;p&gt;有人可能会说，用一台设备解决所有需求，要比用两台设备更节省预算，因为资源利用率更高。但实际情况是恰好相反的。如果你只有一个需求，可能很容易找到一个 150 元的设备可以满足。如果你有另一个需求，也可能很容易找到另一个 150 元的设备可以满足。但如果你想要找到一台设备同时满足这两个需求，那可能至少要花 500 元。如果你又有第三个需求，同样地，单独满足这个需求的设备可能只需要 150 元，但同时满足这三个需求的设备，可能至少需要 1000。如果你有第四个需求呢？那么很可能你没办法找到同时满足那四个需求的设备了，因为这些需求很可能是互斥的（比如性能高和功耗低），花多少钱也没处买。&lt;/p&gt;
&lt;p&gt;所以把需求拆开单独找可以满足的设备，然后配合使用，往往可以节省预算。&lt;/p&gt;
&lt;p&gt;那么树莓派适用怎样的场景呢？&lt;/p&gt;
&lt;p&gt;1、作为一个低能耗的 Linux 家用服务器，用于运行硬件性能可以满足的软件，提供各种服务（比如网络相关、文件相关、视频音频相关）。&lt;/p&gt;
&lt;p&gt;2、连接硬件用来做数据采集、监控、分析、发布等事情。&lt;/p&gt;
&lt;p&gt;3、作为类似小车、飞行器、机器人、智能家居等智能设备的控制中心。&lt;/p&gt;
&lt;p&gt;4、作为一个电脑的轻量级替代物，用于一些简单的场景，或者用来作软件开发启蒙，适合预算不足以买电脑的用户（主要是孩子）。这个是树莓派的最初目的。&lt;/p&gt;
&lt;p&gt;5、用于大中小学的教育。&lt;/p&gt;
&lt;p&gt;6、用于搭建原型产品。&lt;/p&gt;
&lt;p&gt;7、单纯地用来玩（折腾）而不是使用。&lt;/p&gt;
&lt;p&gt;可以看到，在这些场景中，树莓派的性能完全不成问题。不把全部需求集中在一个设备上，选择的范围就很广了。&lt;/p&gt;</content></entry><entry><title>我和 Linux 的故事</title><link href="/wo-he-linux-de-gu-shi.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/wo-he-linux-de-gu-shi.html</id><summary type="html">&lt;p&gt;我最早接触Linux是2006年，那时还是高中。当时我对Windows下的破解技术很感兴趣，那个时候看雪论坛很火，里边有很多破解教程，我就经常下载到电子词典里看。其中有一本书破解方面的书第一部分讲的是在Linux下破解，比如将scanf的缓冲区溢出漏洞，漏洞利用程序是用Perl写的（而Windows下破解基本都用GUI的工具，比如Ollydbg，我电子词典只能看文本文件，没有截图看起来很费事），后边还有很多ShellCode相关内容。我就去查了下Linux相关内容，虽然不是很感兴趣，但也感觉比较新鲜。&lt;/p&gt;
&lt;p&gt;后来，我们教室安装了投影用的电脑，因为我对电脑比较熟悉，钥匙在我这。于是我经常没事就折腾，突然就想起了之前听说的Linux。第一次安装使用的发行版是很多人没听说过的ThizLinux，至于为什么是ThizLinux，原因很简单。当时我去电脑店问有没有Linux光盘，老板找了4张光盘出来，其中3张是Ret Hat的3张，另1张是ThizLinux。我一想反正就是装来玩的，1张比3张便宜，就它了吧（没从网上下载镜像的原因是当时u盘还没有流行，而且价钱很贵，我高三时买了个2G的u盘花了将近200块，而当时我只有一个128M的mp3可以用来存文件）。因为当时没有自己的电脑，但我们教室用了投影的电脑，我去网吧下了一个免安装版（因为电脑有还原卡，每次都安装很麻烦，如果安装后需要重启更没法用）的VMWare，装上了这个ThizLinux。&lt;/p&gt;
&lt;p&gt;但教室的电脑毕竟不方便，尤其是不能上网，简单体验一下各个预装软件也就作罢。印象比较深的是桌面环境是KDE …&lt;/p&gt;</summary><content type="html">&lt;p&gt;我最早接触Linux是2006年，那时还是高中。当时我对Windows下的破解技术很感兴趣，那个时候看雪论坛很火，里边有很多破解教程，我就经常下载到电子词典里看。其中有一本书破解方面的书第一部分讲的是在Linux下破解，比如将scanf的缓冲区溢出漏洞，漏洞利用程序是用Perl写的（而Windows下破解基本都用GUI的工具，比如Ollydbg，我电子词典只能看文本文件，没有截图看起来很费事），后边还有很多ShellCode相关内容。我就去查了下Linux相关内容，虽然不是很感兴趣，但也感觉比较新鲜。&lt;/p&gt;
&lt;p&gt;后来，我们教室安装了投影用的电脑，因为我对电脑比较熟悉，钥匙在我这。于是我经常没事就折腾，突然就想起了之前听说的Linux。第一次安装使用的发行版是很多人没听说过的ThizLinux，至于为什么是ThizLinux，原因很简单。当时我去电脑店问有没有Linux光盘，老板找了4张光盘出来，其中3张是Ret Hat的3张，另1张是ThizLinux。我一想反正就是装来玩的，1张比3张便宜，就它了吧（没从网上下载镜像的原因是当时u盘还没有流行，而且价钱很贵，我高三时买了个2G的u盘花了将近200块，而当时我只有一个128M的mp3可以用来存文件）。因为当时没有自己的电脑，但我们教室用了投影的电脑，我去网吧下了一个免安装版（因为电脑有还原卡，每次都安装很麻烦，如果安装后需要重启更没法用）的VMWare，装上了这个ThizLinux。&lt;/p&gt;
&lt;p&gt;但教室的电脑毕竟不方便，尤其是不能上网，简单体验一下各个预装软件也就作罢。印象比较深的是桌面环境是KDE（当时没有概念，后来回想的），鼠标点开软件后软件的图标在鼠标旁边一跳一跳的，里边有个叫Kate的文本编辑器可以选择很多编程语言高亮方案，其他的基本都记不得了。后来我也尝试安装了Ubuntu 7.10，好像是在网吧电脑的虚拟机，细节基本完全忘记了。直到高中毕业我有了自己的笔记本，买回来几天就装上了Ubuntu 8.04（预装的Windows XP还保留），自然那时是08年，Ubuntu已经比较火了，同时比较有名的桌面发行版就是Fedora。家里也没有网，所有十分不方便，我曾经去网吧把源里的deb包下到u盘里回来安装，但经常因为少下了依赖而安装不上，后来索性不折腾了。&lt;/p&gt;
&lt;p&gt;悲剧的是大一不让带电脑，我上学期就没有带。但悲剧地发现有同学带来电脑也没人管……那时我们专业有一个免费机房，但上不了网，我们周末经常去那玩（还有个收费机房，应该是一块钱一小时，比较大，印象最深的就是病毒猖狂，基本随便找个机器插上u盘，都无一幸免）。系统是Windows 2000的，我就想着弄个虚拟机装Linux。但试了几个都用不了，费了不少事找到了一个支持Windows 2000的Virtual PC。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当时的记录，下同
20081109
找到了
终于找到W2K下能用的V PC了,我都快放弃了.更让我激动的是找到一带gnu编译程序包的LINUX LIVE CD ISO,这样工具就全了,也不用再忍受计算中心病毒之苦了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有次我下了个Puppy Linux，然后用虚拟机体验了下，感觉这个发行版好小，里边工具却很多，挨个点开玩了玩。有次在大街上还看到有人卖Open Solaris的光盘，果断买了一张，结果发现真的可以启动起来，界面和Linux相差不大。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;20081107
光盘引导
学校那计算中心,我啥也不说了.今天却发现一个好办法,用光盘引导.虽然是solaris的,和linux的看上去差不多.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当时我还是对Windows更了解的，无论是使用上还是编程方面。但当时我作了一个决定，把平台全部切换的Linux，原因大概有这样几个吧：机房里的Windows系统病毒太猖狂，用起来非常难受；教材里C语言还使用VC 6.0开发编译，用起来不方便；机房里电脑里的软件都是盗版的，对盗版软件很反感等等。当时写了这样一篇文章（现在看来有点想笑）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;20081228
不得不考虑&lt;/p&gt;
&lt;p&gt;也许对于一般用户,用什么系统和软件并不十分重要,然而对于另一些人,则至关重要,因为这与发展方向密切相关.
想着最近发生的事,太多的要考虑,以至于我不知道从何谈起.&lt;/p&gt;
&lt;p&gt;还是熟悉的XP,不同的感觉,八年的驰骋,让许多人为之震撼,然而它又能撑多久?
技术的落后无法挽救,越来越大的阻力终会让现在只靠惯性运动的它.VISTA无法接任,唯有不远将来的WIN7.也许会吧,但真的很乐观吗?我们到时候还会很自然地说“走,上网下个深度的WIN7”吗?即使可以,我们还会这么舒服吗.雨林木风宣布止步了,其他的还会远吗?
更重要的是,学WIN底层和平台编程也许会很糟糕,会有变化吧.能不能用起呢?......
种种原因,我作以下决定:
将开发平台全部转至linux,放弃开发和学习基于WIN API的软件和技术.放弃对WINDOW下平台相关破解及逆向等技术的学习研究.放弃对其下病毒作技术性研究.放弃深入研究基于COM的脚本技术.拒绝研究.net平台,拒绝研究其内核和驱动.拒绝研究WINCE WM 平台相关技术.
上述决定很痛苦,因为我曾投入相当多精力,而今却要挥手离去.
我决定从寒假回校起以linux作为开发平台和主应用平台,用WIN作辅应用平台,并争取摆脱WIN.不再使用msoffice vc iis ie 等软件.只给WIN分30G以下大小的分区.
以后界面程序以QT库应用为主......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以及这篇：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;20090206
盗版的反思&lt;/p&gt;
&lt;p&gt;盗版，忘记了最初接触是什么时候了，印象中有一个小插曲。在看一些台湾教程时，常看作者提到过“D版光盘“，当时不太理解，还以为光盘还分ABCD四等呢，后来才知道其实就是“盗版光盘“。也许是因为今年发生挺多和盗版相关的事（从番茄花园，到XP黑屏，到微软产品降价……）吧，应该人们对这个词已经不陌生了，然而仅是知道这个词是不行的。
　　打开你的电脑，或者到网吧、机房或是一些小公司看看，看看什么是盗版吧。拿我几个月前的电脑来说吧（因为那时的比现在的更有特点）。打开电脑，Windows xp系统就启动了，这个系统也有点来头。深度技术Ghost xp6.5，应该是我高三下学期在电脑小店买的，安过多少次我也记不清了，而且每次安后我都要进行一系列麻烦的设置，直到我没有看着不顺眼的地方。里边有我常用的软件（其实有些很少用，但看起来舒服），如Office2003，Foxit Reader，Autocad 2004，Photoshop6.0，VC++6.0，WinRar3.71，3dmax8.0，Mathematica5，VMwareWorkstation6.0，玩转手机，一直感觉挺不错的，虽然我知道这些都是盗版的，而且其价格不菲。我也习惯上网下载软件时找“……破解版”“……特别版”之类的，而且因为有几个喜欢的软件一直找不到破解版的而十分郁闷。我想有许多人都也都是这么想吧，会认为怎么会有人傻到花几千甚至几万去买一个软件回来。但当真冷静想这些时，不由得有些怕了。
　　我写过软件，当然知道一个能让crackers为了破解它而不择手段的软件是多么艰辛；我也学过破解软件，当然明白破解一个用商业加密技术保护的软件有多么困难。然而他们都没有错，一个为了谋生，为了计算机相关领域的发展；另一个则更为高尚，他们为了软件的普及，付出那么多却很少在乎个人利益（如果不信去网上找一找相关资料吧），如果没有他们，中国恐怕二十年之后电脑也不会这样普及（虽然硬件越来越便宜，但软件的价格成倍上涨，想想吧）。然而结果呢，我们看上去是占了便宜，而实质上则是主动放弃了一次又一次机会，使国内相关技术水平被落得越来越远。
　　前些日子在学校时，我打算下载一个XPsp3系统，但我在gougou翻了几十页也没找到一个能下载的连接，这不禁让我心为之一震，当然我知道如果想下一定可以找到，但我也知道迟早有一天会找不到的。系统这样，软件又有什么区别，到那一天我们怎么办？尤其是一个学软件工程的人，到时候连操作系统都买不起，自己写一个吗，笑话。
　　再次打开VC++6.0感觉更加别扭了。如果不是书上用的是它，我无论如何都不会去用，我宁可用EditPlus +  gcc，而那个EditPlus也是盗版的，我无语。我不得不承认在Windows下，离开盗版的日子是没法过的。况且连系统都已经是盗版的了，又何必在乎那几个软件呢？
　　临回来时，我下了一个Window7测试版和一个Ubunbu衍生版，想试一试哪一个更好用，因为我还没有作好离开Windows的准备，同时也想体验新技术了。但一件事使我放弃了尝试Win7的打算。电脑又感染病毒了，一塌糊涂，手边也没有什么东西，害得我丢了许多东西。我受够Win下的病毒了，仅一个学期我的U盘就被感染不下几十回。我不怕病毒，尤其是那些一看就明白是怎么回事的病毒，我只是不想把时间和精力扔到那没有用的东西上。当然Linux下也会有，但至少我用不着提心掉胆地动不动就怀疑是不是又感染病毒了。
　　所以对我来说没有什么其它更好的选择了，我不想再用看着就别扭的Windows了，也不想弄其下独有的技术了，包括我我高中费尽心思学的Win32编程和平台软件破解，还有基于COM对象的脚本，等等。我突然发现离开了Windows，我几乎一无所有。但也许这样会轻松些。
　　但种种原因，我还离不开Windows，离不开盗版。mtk手机同步工具肯定是没有Linux版的了，U盘量产工具也一样吧，下学期还学什么3dmax，我都快疯了，放着专业课不学，学这种不可能用到的东西，还有我现在也不知道怎么能让它识别出摄像头，……。
　　慢慢的，我发现许多时候不用盗版的东西也能轻松地解决问题，我也习惯了这种方式。感觉一些事情挺好笑的，也挺正常的，分怎么看吧。前几天去书店看一看，还是那些书，盗版软件不可能不流行，或者说如果一个商业软件如果不被破解就永远不会流行起来。突然想来老师的那句话，我发现有人买盗版的OS/2，回去告诉他们，他们兴奋地蹦起来，OS/2终于有盗版的了！前几天我真的有兴看到os/2的界面了，的确，是图形界面的鼻祖。
　　不管怎样，感觉中国的软件事业的前景还是很堪忧的。一个几乎完全模仿别人的软件也会成为“国人的骄傲”，获得各种奖项，我无语。开源的东西到国内多半就变成商业的了，我也没什么可说的了。
　　如果有一天盗版会从中国消失，我想……，我应该不用想了，至少我在有生之年是看不到了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直到大一下学期，我终于有了自己的能上网的电脑了。立即将原来的Ubuntu 8.04改成Ubuntu 8.10，但当时用的是一个Ubuntu衍生版，貌似是以C开头的一个名字，镜像2G多，黑色调，源还是Ubuntu的。然后平时就使用Ubuntu，很少用Windows（忘了从什么时候开始把Windows删掉的）。当时的截图很难找到了，找了半天翻出来一个能看清的：
&lt;img alt="image" src="/images/017.jpg"&gt;
这张是当时用Dropbox时写了篇文章（ http://osily.lofter.com/post/161c56_3dfe4a  ）截的，鹦鹉螺文件浏览器。这个绿色的主题我用了一年以上，当时还自己将一些图标换成更好看的，现在看还是有些感情的。&lt;/p&gt;
&lt;p&gt;然后想起了输入法。Ubuntu预装的是SCIM，感觉不大好用。当时比较流行的是Fcitx，但感觉那个输入法状态条很丑（细细的，颜色惨白，最左边有一只小企鹅。几年之后这个状态栏变好看了。）有次突然发现一个新的输入法，叫yong（小小输入法）。装上后十分吃惊，又好用又美观，论坛里还有很多漂亮的皮肤。&lt;/p&gt;
&lt;p&gt;当时写的文章，开始：&lt;/p&gt;
&lt;p&gt;20091019
小小输入法
终于可以换个输入法了，fcitx用了一年多，不是因为它有多好，而是找不到比它更好的了。之前试了三四个输入法，不是太慢太大就是功能不全，有的兼容性还有问题……
昨天又重试了一下小小输入法，感觉有不少长进，终于可以换上了。感觉除了模糊拼音它没有，我再不需要别的功能了，另外平时很少用拼音，有没有也无所谓了。
首先界面上，这是我见得最好的，虽然界面并不能作为选择的第一标准，但常用的输入法，界面自然比其他软件重要的多，在这一点我实在无法忍受fcitx。它可以换皮肤，这在linux下似乎绝无仅有，因为这，我特意自己做了几个皮肤，但遇到点问题直到刚才才基本解决。
在我看来比较好的特点：
码表txt格式，易于修改。
用户词汇和主词库分开，易于备份。（fcitx就是合并的，很麻烦）
可以很容易地外挂词库，而且词库里只写词就可以了，而不用写码。
安装方便，还可以外挂。（当初安fcitx真是费劲，乱码问题都折腾我好久）
界面不错，设置方便。
体积很小，速度也可以。
跨平台。（虽然Windows下我想会用搜狗五笔……）
更新较快。（fcitx几年了也没把全角字符问题解决了，无语……）
论坛比较活跃。
这些对我来说就足够了，没什么太高要求了……
贴几个图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/018.jpg"&gt;
（有点像“绿色软件”，安装后只是把主程序链接到/usr/bin里，一些词库会拷到家目录。）
&lt;img alt="image" src="/images/019.jpg"&gt;
（这个功能可能需要完善一些……）&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/020.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/021.jpg"&gt;
&lt;img alt="image" src="/images/022.jpg"&gt;
前两个是自己从搜狗的改的。搜狗的皮肤真不少，如果能写个程序自动转换就好了……
状态条在这个主题下显示不正常，也不习惯用，就让它隐藏了，另外这让做皮肤轻松了许多。&lt;/p&gt;
&lt;p&gt;当时写的文章，结束&lt;/p&gt;
&lt;p&gt;还写了一个搜狗输入法皮肤转小小输入法皮肤的工具（http://osily.lofter.com/post/161c56_3dfe2c）。&lt;/p&gt;
&lt;p&gt;当时喜欢逛Ubuntu中文，有个子版块是Arch，开始时没注意，后来有次进去看了下，发现经常有人从Ubuntu转到Archlinux的。当时学校事情也比较少，平时也没事情做，就也尝试下Archlinux，那时是09年。先在Virtualbox安装，比较顺利，当时写的文章（博客周转了好几个地方，居然还能找到）：&lt;/p&gt;
&lt;p&gt;当时的文章，开始：&lt;/p&gt;
&lt;p&gt;20100108
安装archlinux
按这系列文章（dante.im/archlinux-on-virtualbox-note-2-setup）安装，果然十分顺利，虽然中间也遇到一些文章，还是比较方便地解决了。安gnome时下载了300M+的东西，又是在virtualbox里，用了不少时间，又因为中间有一次虚拟机出错，重下了一回，源不好用，中途换源，最后总算看到桌面了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/023.jpg"&gt;
&lt;img alt="image" src="/images/024.jpg"&gt;
尤其是这回分区和网络都没有出任何问题，配置文件也没有太大的改动，总体感觉并不难。总结起来，大致步骤：
1.启动后，以root登陆，运行/arch/setup运行安装程序：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/025.jpg"&gt;
2.进入1，选择cd，2可以先不管，3分区格式化，4选择包，5安装包，6设置系统，7安装grub，就完了。但也不像ubuntu那么容易，3就不好弄，可以看下http://antimalicious.blogspot.com/2009/04/archlinux.html
习惯就行了，也不算很难。
再就是7了，现在可以不设置太多，设置点基本信息，再就是设置下源，当然这些也可以在安装后在设置。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/026.jpg"&gt;
3.重启后以root登陆，不出意外就可以继续了，如果以lan联网不用设置就能上网，不然就要设置了。然后更新：
pacman –Sy 让pacman&lt;strong&gt;将本地的包数据库与远程的仓库进行同步&lt;/strong&gt;。
pacman -Su 是&lt;strong&gt;对系统自带的包进行更新。&lt;/strong&gt;
&lt;strong&gt;pacman -S xorg #提示没有这个包，但提示一些，安装就行&lt;/strong&gt;
&lt;strong&gt;pacman -S hal dbus&lt;/strong&gt;
&lt;strong&gt;/etc/rc.d/hal start&lt;/strong&gt;
&lt;strong&gt;startx&lt;/strong&gt;
&lt;strong&gt;这就进入了一个图形环境，非常简陋，有三个xterm，一个时钟如果鼠标键盘能用就没问题了。&lt;/strong&gt;
&lt;strong&gt;pacman -S gdm&lt;/strong&gt;
&lt;strong&gt;pacman -S gnome&lt;/strong&gt;
&lt;strong&gt;然后改/etc/rc.conf&lt;/strong&gt;
DAEMONS=(syslog-ng network netfs crond hal dbus gdm)
&lt;strong&gt;重启后如果正常就进入gdm里，登陆（以非root，之前要创建）就能进入gnome。&lt;/strong&gt;
&lt;strong&gt;再安几个软件试试，有的软件找不到，不知道是包名称错了，还是源没设置明白。但安装的包版本都比较高。&lt;/strong&gt;
&lt;strong&gt;因为没安装额外的包，感觉有点别扭，shell的补全奇差，但估计能设置好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当时的文章，结束。&lt;/p&gt;
&lt;p&gt;但在实体机安装就比较痛苦的，主要是显卡驱动非常麻烦，我的笔记本显卡是ati x2300，费了不少劲才把X启起来并把分辨率弄对，但用起来还是比Ubuntu卡（当时流行跑glxgears，结果一直比之前在Ubuntu的低）。安装折腾了我将近两天，然后发现使用也比Ubuntu麻烦，比如无线网卡驱动和蓝牙驱动折腾了我好几回，显卡驱动性能一直感觉有问题。装的是64位系统，但当时Archlinux是没有multilib的，如果想使用32位软件需要chroot等方法，十分不方便，而有几个软件是没有64位的。其他的小问题就想不起来了。但慢慢也习惯了，主要是感觉系统轻巧了不少。当时用Ubuntu时经常感觉系统预装的东西太多，想删一些，但包太多不知道都是什么功能，删错了就会出各种问题。而Archlinux预装的包很少，就不用考虑这个问题了。&lt;/p&gt;
&lt;p&gt;后来就感觉Gnome特别臃肿，而且看起来也没有Ubuntu的好看。有个印象特别深刻的事情是Gnome左上角的菜单上有几个我从来用不到的Avahi相关菜单项，看起来十分烦人，但没有办法单独卸载Avahi相关的东西。于是就慢慢不想用Gnome了。当时逛论坛很多人用轻量级WM，我也尝试了好多，基本能装上的都试过了。试了几个发现openbox不错，配上tint2，很简洁，资源占用也上，于是用来几个月。后来有看到很多人推荐平铺式WM，之前我用不习惯也不想记那么多快捷键，基本上装上看一眼就卸了，这次又重新装上试一试，发现dwm比较合我胃口。主要是体积小，印象深刻，代码一共不到2000行，编译后好像只有17K，内存占用也很少。于是用它取代了openbox和tint2，从此再也没换过，直到后来我不再使用Linux的GUI环境。&lt;/p&gt;
&lt;p&gt;期间也听人说Gentoo很好用，我也试了试，在Archlinux上编译，然后直接使用Archlinux自己的内核把Gentoo启动起来。因为当时我已经不需要编译Gnome之类的大家伙了（当时用的openbox），安装十分顺利，也直接切换了过去。&lt;/p&gt;
&lt;p&gt;当时写的笔记，开始：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;20100304

gentoo安装和使用体验

进行了将近一天的惊心动魄的升级后（很庆幸系统没有挂掉，而且感觉更快了），终于想静下心来把一个星期以来的安装、配置以及升级gentoo大致写出来，一是想纪念一下，另外也许对其他想用gentoo的朋友有一些参考价值。
我使用linux不算很长，大概用了一年半的ubuntu和一年的archlinux。用archlinux时逛论坛经常有人谈及gentoo，好像用gentoo的都是高手。当时感觉可笑，各各发行版区别都那么大吗，之前用ubuntu转到archlinux也就是显卡驱动那碰到点问题，其他都比较顺利，gentoo又能难到哪去呢？另外gentoo安装软件都是要编译的，我的本性能也不好，就想如果以后换了新的再考虑吧，所以中间虽然想了几次，但一定没有尝试。
一个星期前（2010 3月4号），我把mplayer和ffmpeg都手动升级下，发现编译起来有点纠结，mplayer需要ffmpeg的源码，但ffmpeg还要单独编译，后来让mplayer用ffmpeg的so后升级ffmpeg后mplayer居然挂了，重编了几回才弄好。系统里有好几个包都自己编译，主要是想去掉不用的依赖，但手动维护太麻烦了，于是又想到了gentoo。当时已经10点多了，于是想第二天开始着手。
废话完毕。

之前的硬盘分区就这样的：
/dev/sda1 ext4 6g /
/dev/sda2 2g 未使用
/dev/sda3 ntfs 30g
/dev/sda4 jfs 66g /home
其中/dev/sda2是以前的swap，但后来不用休眠功能后感觉swap意思不大，就不用了。其余的三个分区都比较重要，基本动不得，这给怎么装啊。想来想去，先用sda2试试吧，如果装不上就没事了，装上再进一步考虑吧。
于是把sda2格成了reiserfs（某人说这种格式好，但我从来没用过，正好体验一下）。下载 stage3-i686-20110301.tar.bz2 和portage-latest.tar.xz。（前一个文件一周一更新）（我用的32位）
国内的镜像有：
http://mirrors.163.com/gentoo/
http://mirrors.sohu.com/gentoo/
http://mirror.bjtu.edu.cn/gentoo/
http://mirrors.xmu.edu.cn/gentoo/
这两个文件可以在里边找。

把sda2挂在/media/z上，并把文件放进去：
sudo mount /dev/sda2 /media/z
sudo tar xvpf stage3-i686-20110301.tar.bz2 -C /media/z
sudo tar xvpf portage-latest.tar.xz -C /media/z/usr
准备chroot环境：
sudo mount -t proc none /media/z/proc
sudo mount -vt devpts devpts /media/z/dev/pts
sudo chroot /media/z/ /bin/bash
现在就chroot进去了，之后的操作如不特别说时都是在这个环境下进行的。

初始化环境变量：
env-update;source /etc/profile

修改/etc/make.conf，这个非常重要，最好首先改到位，不然之后有你受的（我就是，不得要领，改了多回，改完还要重编译各种东西）：
加入源：
GENTOO_MIRRORS=&amp;quot;http://mirror.bjtu.edu.cn/gentoo/&amp;quot;
SYNC=&amp;quot;rsync://mirror.bjtu.edu.cn/gentoo-portage&amp;quot;
上边那四个网站都有说明如何写这个。
MAKEOPTS=&amp;quot;-j3&amp;quot; #-jn，n是内核数加1，多线程编译用的，不设置也行
INPUT_DEVICES=&amp;quot;keyboard mouse synaptics&amp;quot; #键盘、鼠标、触摸板
#下面的是很重要的USE，开始时可以只用USE=&amp;quot;X gtk&amp;quot;，但最开始写好以前就省事了，不然以后会麻烦重重。
USE=&amp;quot;-pppd -alsa -fortran sse sse2 ssse3 mmx sdl v4l v4l2 oss oss4 X gtk unicode truetype jpeg png gif cairo zsh-completion fontconfig video opengl&amp;quot;
VIDEO_CARDS=&amp;quot;radeon&amp;quot; #这个至关重要，显卡驱动类型，具体请查看官方wiki，我的是ati x2300，只能用这个开源驱动。
#CCEPT_KEYWORDS=&amp;quot;~x86&amp;quot; #这个要注意，如果要用最新的软件，可以加上这行，但如果是第一次装，强烈不建议加，不然会提升安装难度
先改这些就差不多了。

改/etc/locale.gen,加（按照自已需要写）
en_US.UTF-8 UTF-8
zh_CN.UTF-8 UTF-8
zh_CN.GB2312 GB2312
zh_CN.GBK GBK
运行locale-gen

cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
修改/etc/conf.d/clock
CLOCK=&amp;quot;local&amp;quot;
TIMEZONE=&amp;quot;Asia/Shanghai&amp;quot;

改/etc/resolv.conf，把本机的/etc/resolv.conf内容写出其中，不然上不了网。
改/etc/fstab，这个也可以安装完内核再写，这个应该都会写。

查看网络是否正常（如果电脑联网了，resolv.conf也改了就可以上了），然后同步portage（如果portage-latest.tar.xz是刚下的也可以略过这步，但最好还是运行下吧）：
emerge --sync
安装内核源码：
emerge gentoo-sources
下边就开始编译内核了，如果有手动配置内核的经验强烈建议手动配置编译:
cd /usr/src/linux
make menuconfig
make; make modules_install
cp arch/x86/boot/bzImage /boot
，不然最好使用genkernel：
emerge genkernel
cd /usr/src/linux/
genkernel --menuconfig all

关于配置内核请上网自行查询，如果下一种方式实在不会也可以不配置，一般也能启动起来。
编译时间和很多因素有关，几十分钟到几小时不等。

用户相关：（osily是自己要创建的用户名）
passwd
useradd -m -G audio,cdrom,portage,usb,video,wheel,users -s /bin/bash osily
passwd osily

如果fstab之前没改好现在一定要改好，然后改自己系统的/boot/grub/menu.lst。
此处官方wiki写的很清楚，建议查看。

现在可以继续安装其他软件，如xorg-server，但最好还是重启看看能不能进去。
如果不能的话多半是内核（尤其是自己编译的内核）的问题，如果内核没问题，看看/boot/grub/menu.lst是不是有问题，多改几回。
如果可以正常进去的话，可以直接在这继续编译，但最好还是返回原来的系统继续。

可以写个类似这样的脚本：
#!/bin/bash
sudo mount /dev/sda2 /media/z/
sudo mount -t proc none /media/z/proc
sudo mount -vt devpts devpts /media/z/dev/pts
sudo chroot /media/z/ /bin/bash

运行就可以进去chroot环境，如果进去环境变量不正常运行：
env-update;source /etc/profile
然后就是安装需要的东西了，主要看自己了，比如dhcpcd、sudo、vim……，一般的工具直接
emerge xxx就可以了，emerge的具体用法网上查吧。
但如果你想要桌面环境的话，最好按以下的步骤：
安装点基本工具后，直接安装xorg-server，注意前提/etc/make.conf里显卡和输入设备等变量一定是正确的。
这会安装许多东西，基本要用一个小时以上，耐心等待吧。
安装完后：（xorg-x11和驱动相关，请查看官网wiki相关部分，这部好像可以省略，记不清了）
eselect opengl set xorg-x11
如果安装好了，可以先重启试试，进去后，运行startx，这是很刺激的一刻了，如果显示找不到xterm找不到什么的，恭喜你，显卡驱动基本正常了，不然就会有各种稀奇古怪的问题&amp;amp;……&amp;amp;×……&amp;amp;……%×&amp;amp;，那么也恭喜你，在接下来的时间你将对安装显卡驱动、写xorg.conf等有深刻而透彻的了解。
如果是前者，你可以回去继续安装其他东西，如xterm（最好安装完再重启下看看是不是正常，如果不正常，那么你可以回过头处理显卡驱动问题了）、openbox甚至gnome、kde。下文再说。
如果是后者或者刚才的xterm显示分辨率不对、鼠标键盘触摸板不能用，那么你要折腾一会了，虽然之前安装内核没有难到你，这里很可能让足够纠结甚至放弃。

这也是我安装过程中最混乱的地方，已经没法清晰地回忆了，因为这的问题我先后重装了4次，（第一次因为2g空间不够，2、3次都因为X段错误，非常纠结），而且其中改了几回显卡驱动类似，重编译了多回。
如果是X段错误，看出错信息是不是加载某个so出的错，如果是可以先把那个so移到别的地方重试。如果不是段错误，可能是xorg.conf有问题，有的驱动是不需要这个问题的，默认也是没有了，所以如果有先删掉试试，不行的话用
X -configure
生成一个新的再
X -config xorg.conf.new
尝试
如果不行的话，还很有可能是内核没配置的问题，这往往比较麻烦，可以先仔细阅读官网wiki，不行再去linuxsir等论坛去找找或者问问。重编译内核后最好把和X相关的包也重编译下（有许多……）。
再有很可能是你选择的驱动不支持你的显卡，比如老的ati显卡很多都不能用现在的闭源驱动。这样可以试试其他的，改/etc/make.conf，然后必须把相关的包重新编译。
还有其他的可能吧……
如果xterm能进去了，但鼠标键盘等不能用，保证/etc/make.conf正确的话，安装xf86-input-evdev，如果
xf86-input-keyboard xf86-input-mouse xf86-input-synaptics 没有的话说明/etc/make.conf没写对，这时安装上这几个包也未必好用，可能要重新编译更多包。
这个问题应该是比较好解决的。
如果分辩率不正常，首先要确认用的不是xf86-video-vesa的驱动（按我的流程不会安装到这个包），如果是那很可以分辨率就不调不正常了。然后还是显卡驱动安装问题，还有xorg.conf，上网多找找吧。
显卡驱动问题如果一时解决不了的话，可能会拖很长时间，甚至直到放弃，或者你甘愿不用图形界面。

如果以上都正常了，gentoo离你就很近了。
接下来主要部署桌面环境，推荐比较轻量的，(如openbox、fluxbox、fvwm、dwm、awesome等），可以配合面板（tint2、bmpanel、pypanel等），不然要花很长时间编译。
安装完后就按自己的需要进行配置了。

现在还没有涉及的问题主要还有：声卡、网卡、摄像头等设备的驱动，以及触摸板不正常等。

如果触摸板用手指点无反应，但手指移动有反应，试试：
synclient TapButton1=1
如果横向滚动不能用：
synclient HorizEdgeScroll=1
其他问题请查询synclient用法
要把上边的命令放在启动脚本里，如是.xinitrc，确保它能在进入X前被调用。

声卡问题，如果用alsa的话，genkernel默认编译的内核包含了alsa驱动，应该就要以正常使用了，如果没包含就要有点麻烦。
如果内核包含了oss驱动（这是旧版本的），可能也可以正常用，但效果应该不好，能忍就算了吧。
如果都没有的话如果内核启用的声卡支持（menuconfig里有一层的里边是alsa和oss，它的上一层要选上），你可以选择安装alsa或者oss驱动，个人推荐用oss4，它音质比较好，占用资源少（我试和内核的alsa里比mplayer放mp3时cpu占用省了一半）。但安装oss4不是很容易，因为它不在portage里，要用layman，还要能连接国外网。alsa没装过，官网wiki有详细说明。
如果现在就要安装oss4，也好：
emerge layman
layman -a oss-overlay
然后再/etc/make.conf里加一句：
source /var/lib/layman/make.conf
然后
emerge oss或者emerge oss-devel
如果网络没问题的话应该正常安装。
要保证/usr/src/linux指向的是当前用的内核
然后/etc/init.d/oss start，一般要等几分钟因为要编译内核模块，如果成功了基本就可以用了，可以试试osstest，不成功的话问题就麻烦了，很可能你要重新编译内核了，看是不是有什么漏选或多选了。在此处我重编译了一次内核，因为之前把alsa编译进去了。
如果解决不了还是多读官网wiki，不行再逛论坛或者问别人。
但总体声卡驱动安装还是比较容易的。

然后你可能发现无线网卡没驱动起来，运行
ifconfig -a
找不到无线网卡，那么恭喜你又基本又需要重编译内核了。
而且要先确实自己网卡的型号(lspci|grep net)，然后去menuconfig选项里找，如果没有的话可能要再安装驱动。我的是Atheros，调整选项重编译内核可以了。不行的话还是看官网wiki，上过说的比较清楚，各论坛也有许多相关的贴子。

摄像头的话看/dev/video0是否存在，如果不存在，那么你应该猜到了，再调整选项重编译一回内核吧。其实应该只重编一回把驱动问题都解决了，不然真是痛苦啊。关于怎么改选项wiki和论坛也有……

如果你还有其他一些东西（如麦克风）无法驱动，解决的办法是类似的。

注意，即使你用的genkernel编译的内核也很可能少各种驱动，所以如果对内核选项不了解的话基本就寸步难行了。但如果感觉某个设备可以先不用的话可以先学习点基础东西再回过来处理。

如果你的各种驱动都正常了，那么基本问题都解决了，剩下的问题一般不会很难如果你不想再折腾了。

你可以安装上所有自己需要的东西，而且安装过程一般不会出什么问题，除了时间比较长。
你可以好好熟悉gentoo的和配置文件和启动流程，按自己的方式修改。
再有就是熟悉emerge和其他相关命令是非常必要的，但这也许比你想象的复杂，开始我想到相关命令和archlinux的一一对应起来，但发现这是不大可能的，二者差别很大，你必须从头认识和了解。

网上有些资料是过时的，你很可能发现上边说的某个文件系统里根本就没有，但到现在应该有足够的能力解决这样的问题了。

如果没有什么其他的需求，就可以正常用了。

如果你想启用~ARCH，那么在升级时还要折腾一番，而且如果准备不充分很可以把辛辛苦苦配好的系统弄得一团糟甚至挂掉。
如果你准备好了要用~ARCH的软件（更新，但出bug的几率更高），在/etc/make.conf（32位的）里加：
ACCEPT_KEYWORDS=&amp;quot;~x86&amp;quot;
然后选择合适的时间进行系统升级：
gentoo的升级尤其是大幅度升级不想某些发行版是一条命令的事，要做好充足的准备。
如果你想用新的gcc编译包，可以先升级gcc （注意，编译gcc要1G以上的空间，具体我也不清楚，如果/var/tmp是内存虚拟的一定要看看够不够2G或更多，如果没有还是先用硬盘吧）：
emerge -u gcc
但这条命令我没用，当时我感觉安装和升级是一个概念，就直接用了
emerge gcc 我不大清楚结果是不是一样的。
但这并不会直接升级gcc，而不是两个gcc并存，而且默认是之前那个，要手动调整成后一个：
gcc-config -l
gcc-config i686-pc-linux-gnu-4.5.2 #选择后一个版本
然后最要先升级python（我开始没有这么做，出了不少麻烦）
不想有些发行版python2和python3是分两个包，gentoo里这是一个包，现在如果你要把python2.6升级到2.7，直接
emerge -u python，它会安装python2.7但不会马上卸了2.6，此时的操作非常重要：
不要忙着去升级其他包而要先把python的问题解决明白了，不然你可以自己感受下~~
先把python2.7设成默认的python2
eselect python list
eselect python set --python2 num #num是上面输出的行号
python-updater
这将会用不少时间，其中会升级一些包。
如果没有错误，那么可以升级其他包了：
emerge -uDN system
同样要用许多时间，如果中间出错了只是按实质情况解决了。如果有的包提示python语句错误很可能是有的用python2但写的是#!/usr/bin/python，这样的话要先手动按之前的方法把默认python改成python2：
eselect python list
eselect python set num
一般就能解决。

之后可以升级其他包：
emerge -uDN world

这个运行之后还没有完，一定要注意：
清除没有用的包
emerge --depclean
检查依赖
revdep-rebuild
更新配置文件
dispatch-conf

更新配置文件时要注意，不要把自己有用的配置给覆盖了，或者留下了不兼容的旧配置文件，了解清楚再选择。

注意在整个升级前要把USE确定好，不要在升级中改USE，不然要能要重编译许多包。

整个升级要用挺长时间，如果要中断可以用ctrl+c，恢复再用之前的命令，如果要关机就要注意，系统完全可以启动不正常，如分区不能正常挂载、X不能启动、声音不正常等，要有能力处理这些问题，但有些问题是要等升级完才能完全解决的，所以先临时处理下就行。

升级中一些低层的包有较大改动，如openrc，这样配置文件会有不小的改变，要了解清楚再作改动。

如果升级圆满成功，那折腾基本告一段落了，可以去做自己喜欢做的事了。

其中许多细节记不大清了，许多东西也是参考了网上的许多资料。
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当时的笔记，结束。&lt;/p&gt;
&lt;p&gt;除了安装软件需要编译慢了些，其他的还好，于是决定改用Gentoo。后来也用自己编译的内核替换掉了Archlinux的，甚至为了缩小内核体积，反复修改配置编译，最后缩到大概1M多，没有initrd。&lt;/p&gt;
&lt;p&gt;当时的截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/027.jpg"&gt;&lt;/p&gt;
&lt;p&gt;可能看不清，是openbox+tint2，uname -a的结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux localhost 2.6.36-gentoo-r5 $1 SMP Mon Mar 7 15:09:30 CST 2011 i686 Intel(R) Pentium(R) Dual CPU T2390 @ 1.86GHz  GNU/Linux&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但用了大概两个月，感觉Gentoo没有人们说的那么好。当时写的东西找不到了，现在回想大概有这样几个问题：
1. USE的定制不够细。当时在Archlinux，我为了精简软件包的大小，手段是否苛刻，像vim、mplayer、ffmpeg等比较大依赖比较多的包，我全部自己修改PKGBUILD去掉自己不需要的依赖重新编译，基本上缩得不能再小了。而Gentoo的USE虽然能定制，但不能这么细地定制。而且我发现ebuild文件没有PKGBUILD好写，索性也不想改了。
2. 系统里有很多没有被Portage跟踪的文件，也就是说很多文件是查不到属于哪个包的，这对有洁癖的我是很难接受的，Archlinux绝大多数文件都是属于某个包的，除了少数安装或者运行时产生的配置文件或者pyc之类文件，不仅量很少，也与已有的包相关。
3. 系统配置没有Archlinux方便。当时Archlinux还是rc.conf一统天下，/etc下的其他配置文件很少需要改，修改配置十分方便。而Gentoo就要改好几个文件，甚至还有/usr下的文件。
4. Archlinux的netcfg（现在的netctl）是否方便，而Gentoo网络的配置就比较繁琐了，现在我已经想不起来怎么配了。
5. 安装软件包太慢，我笔记本性能也不是很好，发热严重。像firefox之类大软件源里有bin包，但我用了一阵发现bin包的质量普遍堪忧，比如我遇到过依赖的so文件和系统中的so版本不兼容，也无法使用USE，和自己编译的完全不是一个体验。
6. 最重要的问题，我没有发现对我来说Gentoo的优势。USE对我的吸引力很少，同一软件的多版本共存也是，因为我从来都是追最新版本。&lt;/p&gt;
&lt;p&gt;于是我又换回了Archlinux，还好当时没有删。从此我再没有更换过发行版，最多偶尔用Live CD试用体验一下。&lt;/p&gt;
&lt;p&gt;再然后就开始工作了。上学时我几乎不使用虚拟机（当折腾过wine，折腾过好多次，至今还感觉不适不想提起），在学校基本没有什么是Linux搞不定的。当工作后发现一个麻烦的问题，需要使用一个只要Windows版本的聊天软件，虽然也有Web版，但Web版功能过于简略（我开始时还是用Web版的，但比如关了浏览器聊天记录就再也找不回来了，功能上也有严重缺失，最后不用了），只好用Virtualbox装个XP虚拟机（除了那个聊天软件，偶尔也需要用下Word、Excel等。有个插曲是之前用永中Office，但它有个bug，保存出来的文件可以再也打不开了，被坑一次后我再也不敢用了。Openoffice对doc文档的支持很成问题，完全走了样没法用。Wps的Linux版本已经是后来的事情了。）。&lt;/p&gt;
&lt;p&gt;然后这个虚拟机对我来说就如鲠在喉，特别不爽。比如占用大量的内存，当时电脑内存是4G的，平时工作都需要开着虚拟机（里边一直运行的聊天软件也不是省油的灯，偶尔需要开MS Office等）、浏览器（Firefox）、邮件客户端（Thunderbird）、终端模拟器（Xterm），有时浏览器页面开多了内存就不足了。界面切换也比较麻烦，当时还是用的dwm，第一个桌面是Xterm和Firefox，第二个桌面是Thundervird，第三个桌面是Virtualbox。Xterm和Firefox是用Ctrl+Tab切换，3个桌面是用Win+数字切换。但进了Virtualbox后，Win键就被XP占用了，得按下右Ctrl才能再用Win+数字切换到其他桌面。虽然习惯了也能用，但还是不爽。我们是有一个笔记本加一台显示器（22寸），开始时我只有显示器，因为同时看显示器和笔记本屏幕（12.5寸）不是很方便，高度也不好调节。后来因为Virtualbox切换麻烦，加上经常没有及时看到聊天软件的消息，把Virtualbox的窗口放到笔记本屏幕上了，这样稍微好了些。&lt;/p&gt;
&lt;p&gt;工作后的另一个改变，是很少再折腾桌面Linux了，时间原因还是其次，主要是没兴趣了。所以经典的软件搭配（dwn+Firefox+Zsh+Tmux+Xterm+工作后新加的Thunderbird）一直用到最后我也没再换。但并不是没有问题，前三个还好，Xterm的主要问题是不支持实时调节字体大小，和使用Tmux时rz、sz没法使用。字体大小平时是不需要调节的，但接投影演示时是需要的，只能去改配置文件重启，比较麻烦。更麻烦的是rz、sz，因为我们登陆服务器要经中转机，直接scp文件是不行的，比较方便的办法就是rz、sz（C-Kermit是支持的，直接用ssh不支持），或者走Samba（在Linux用比较麻烦），或者自己在服务器搭Http Server（更麻烦）。所以需要传文件时，需要另开一个不进Tmux的Xterm，有时一着急就容易忘，直接把Tmux的一个Tab卡死，有时那个Tab是很重要的，比如有重要的history，或者中转了好几个机器才进去的，就非常麻烦）。&lt;/p&gt;
&lt;p&gt;直到14年，当时我对桌面Linux已经没什么热情了，我才想是不是可以改用Windows。当时只是试一试，但没想到不到两周的时间，我已经完全适应了在Windows下工作，另外装了Cygwin（后来改成Msys2）和Virtualbox中的Archlinux。一般的操作在Cygwin都是可以完成的，用起来和原生Linux相差不多，如果不频繁启动新进程，性能上也没有明显差距。而运行着Archlinux的Virtualbox内存占用通常不到50M（里边看使用了23M左右）。内存问题完全解决，再没出现浏览器开了过多页面内存不足的情况。Xterm改成了Xshell+mintty。连接中转机统一使用Xshell，不得不说Xshell还是很好用的，虽然多数功能我都用不到。而本地的Cygwin和Archlinux都用mintty，我感觉比Xterm好用。&lt;/p&gt;
&lt;p&gt;这里提下我为什么坚守Xterm，而不要Urxvt和各种基于vte的终端模拟器。基本上我见过的都尝试过了，Urxvt的问题是字体方面，怎么调整都别扭，不是字体间距有问题，就是有些全角字符显示有问题，而对我来说，相比Xterm几乎没有什么优势，资源占用还更多。而基于vte的终端模拟器有一个共同的问题，就是在里边用Tmux时，下边的色块显示有问题，这个不大好形容，不影响功能，但看起来十分别扭，我多次试图解决都无功而返。而且vte本身的主要问题是能配置的东西太少，没记错的话背景颜色都没法改，比Xterm功能还有少很多。而基于vte的家伙一个比一个臃肿，那些功能都不是我想要的，有因为vte那个共性的问题，我最多尝试来其中某个一两天时间就又放弃了。另外一个值得一提的是mlterm，看起来很漂亮，配置也比较方便。但有一个致命的问题，一时想不起来了，好像是无法快捷地复制，要不就和中文有关，或者有个什么致命的bug，说数次尝试都发现问题犹在而无法使用。最后发现能用的只有Xterm。但Xterm也有几个问题，除了之前说的不能实时更改字体大小，还有配置文件比较麻烦，经常需要上网各种搜，然后改一下重启一下Xterm（有时为了调整字体和字体间距需要改好多次效果才可以接受），不能配置成右键用来粘贴（印象中是这样，可能记错了），复制好像也存在问题（后来好像在配置文件里配的某个快捷键是复制，或者选择直接复制，想不起来了），命令输出内容过多时需要滚动好久等等。而这些问题mintty都没有。&lt;/p&gt;
&lt;p&gt;关于和Windows的其他事情需要以后再单独写了。&lt;/p&gt;</content></entry><entry><title>[译] 11 个用而有趣的 Linux 终端彩蛋</title><link href="/yi-11-ge-yong-er-you-qu-de-linux-zhong-duan-cai-dan.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-11-ge-yong-er-you-qu-de-linux-zhong-duan-cai-dan.html</id><summary type="html">&lt;p&gt;这里有一些很酷的Linux终端彩蛋，其中的每一个看上去并没有实际用途，但很有趣。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_01-100587352-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;只工作不玩耍……&lt;/h3&gt;
&lt;p&gt;当我们使用命令行工作时，Linux是功能和实用性最好的操作系统之一。想要执行一个特殊任务？可能一个程序或者脚本就可以帮你搞定。但就像一本书中说到的，只工作不玩耍聪明的孩子也会变傻。下边是我最喜欢的可以在终端做的没有实际用途的、傻傻的、恼人的、可笑的事情。&lt;/p&gt;
&lt;h3&gt;让终端成为一个有态度的人&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第一步）敲入&lt;code&gt;sudo visudo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第二步）在“Defaults”末尾（文件的前半部分）添加一行“Defaults insults”。&lt;/li&gt;
&lt;li&gt;第三步）保存文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“我刚才对电脑做了什么？”你可能这样问自己。一定是美妙的事情吧。现在，在sudo命令提示提示下输出错误的口令，你的电脑就会呼唤你的名字。我最喜欢的一句：“听好了，煎饼一样的脑子，我没有时间听你胡说八道了。”&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_02-100587353-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;apt-get moo&lt;/h3&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_03-100587354-orig.png"&gt;&lt;/p&gt;
&lt;p&gt;你看过这张截图？那就是运行&lt;code&gt;apt-get moo&lt;/code&gt;（在基于Debian的系统）的结果。对，就是它了。不要对它抱太多幻想 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;这里有一些很酷的Linux终端彩蛋，其中的每一个看上去并没有实际用途，但很有趣。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_01-100587352-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;只工作不玩耍……&lt;/h3&gt;
&lt;p&gt;当我们使用命令行工作时，Linux是功能和实用性最好的操作系统之一。想要执行一个特殊任务？可能一个程序或者脚本就可以帮你搞定。但就像一本书中说到的，只工作不玩耍聪明的孩子也会变傻。下边是我最喜欢的可以在终端做的没有实际用途的、傻傻的、恼人的、可笑的事情。&lt;/p&gt;
&lt;h3&gt;让终端成为一个有态度的人&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第一步）敲入&lt;code&gt;sudo visudo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第二步）在“Defaults”末尾（文件的前半部分）添加一行“Defaults insults”。&lt;/li&gt;
&lt;li&gt;第三步）保存文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“我刚才对电脑做了什么？”你可能这样问自己。一定是美妙的事情吧。现在，在sudo命令提示提示下输出错误的口令，你的电脑就会呼唤你的名字。我最喜欢的一句：“听好了，煎饼一样的脑子，我没有时间听你胡说八道了。”&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_02-100587353-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;apt-get moo&lt;/h3&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_03-100587354-orig.png"&gt;&lt;/p&gt;
&lt;p&gt;你看过这张截图？那就是运行&lt;code&gt;apt-get moo&lt;/code&gt;（在基于Debian的系统）的结果。对，就是它了。不要对它抱太多幻想，你会失望的，我不骗你。但是这是Linux世界最被人熟知的彩蛋之一。所以我把它包含进来，并且放在前排，然后我也就不会收到5千封邮件，指责我把它遗漏了。&lt;/p&gt;
&lt;h3&gt;aptitude moo&lt;/h3&gt;
&lt;p&gt;更有趣的是将moo应用到aptitude上。敲入&lt;code&gt;aptitude moo&lt;/code&gt;（在Ubuntu及其衍生版），你对&lt;code&gt;moo&lt;/code&gt;可以做什么事情的看法会有所变化。你还还会知道更多事情，尝试重新输入这条命令，但这次添加一个&lt;code&gt;-v&lt;/code&gt;参数。这还没有结束，试着添加更多&lt;code&gt;v&lt;/code&gt;，一次添加一个，直到抓狂的aptitude给了你想要的东西。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_04-100587355-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;Arch: 将吃豆人放入pacman&lt;/h3&gt;
&lt;p&gt;这里有一个只为Arch爱好者准备的彩蛋。Pacman包管理工具已经很棒了，但我们可以让它变得更棒。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步）打开“/etc/pacman.conf”文件。&lt;/li&gt;
&lt;li&gt;第二步）在“# Misc options”部分，去掉“Color”前的“#”。&lt;/li&gt;
&lt;li&gt;第三步）添加“ILoveCandy”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在我们使用pacman安装新软件包时，进度条里会出现一个小吃豆人。真应该默认就这样的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_05-100587356-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;Cowsay!&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;aptitude moo&lt;/code&gt;的输出格式很漂亮，但我想你苦于不能自由自在地使用。输入&lt;code&gt;cowsay&lt;/code&gt;，它会做到你想做的事情。你可以让牛说任何你喜欢的东西。而且不只可以用牛，还可以用Calvin、Beavis和Ghostbusters logo的ASCII的艺术，输入&lt;code&gt;cowsay -l&lt;/code&gt;可以得到所有可用的参数。它是Linux世界的强大工具。像很多其他命令一样，你可以使用管道把其他程序的输出输送给它，比如&lt;code&gt;fortune | cowsay&lt;/code&gt;，让这头牛变成哲学家。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_06-100587358-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;变成3l33t h@x0r&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nmap&lt;/code&gt;并不是我们平时经常使用的基本命令。但如果你想蹂躏&lt;code&gt;nmap&lt;/code&gt;的话，比如像人一样看起来像l33t。在任何&lt;code&gt;nmap&lt;/code&gt;命令后添加&lt;code&gt;-oS&lt;/code&gt;（比如&lt;code&gt;nmap -oS - google.com&lt;/code&gt;）。现在你的&lt;code&gt;nmap&lt;/code&gt;已经处于标准叫法是“&lt;a href="http://nmap.org/book/output-formats-script-kiddie.html"&gt;脚本玩具模式&lt;/a&gt;”的模式了。Angelina Jolie和Keanu Reeves会为此骄傲的。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_07-100587359-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;获得所有的Discordian日期&lt;/h3&gt;
&lt;p&gt;如果你们曾经坐在一起思考，“嗨！我想使用无用但异想天开的方式来书写今天的日期……”试试运行&lt;code&gt;ddate&lt;/code&gt;。结果类似于“Today is Setting Orange, the 72nd day of Discord in the YOLD 3181”，这会让你的服务树日志平添不少趣味。&lt;/p&gt;
&lt;p&gt;注意：在技术层面，确实有一个&lt;a href="http://en.wikipedia.org/wiki/Discordian_calendar"&gt;Discordian Calendar&lt;/a&gt;，理论上被&lt;a href="http://en.wikipedia.org/wiki/Discordianism"&gt;Discordianism&lt;/a&gt;追随者所使用。这意味着我可能得罪某些人。或者不会，我不确定。不管怎样，&lt;code&gt;ddate&lt;/code&gt;是一个方便的工具。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_08-100587360-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;我可以在任何地方看到颜色！&lt;/h3&gt;
&lt;p&gt;厌倦了老旧的文本？想向世界展示出自己的个性？使用&lt;code&gt;lolcat&lt;/code&gt;。安装它，然后在任何地方使用。它可以接收任何文本，然后将其转换成美轮美奂的彩虹效果。可以使用&lt;code&gt;fortune | lolcat&lt;/code&gt;体验。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_09-100587361-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;蒸汽机车&lt;/h3&gt;
&lt;p&gt;在你的终端显示蒸汽机车的ASCII图形。如果你需要它，安装并运行&lt;code&gt;sl&lt;/code&gt;命令。&lt;code&gt;sl -l&lt;/code&gt;可以看到一个袖珍版本的。或者，如果你真想在上边花费更多时间，运行&lt;code&gt;sl -h&lt;/code&gt;。这会显示一个完整的或者，还包括乘客车厢。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_10-100587362-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;将任何文本逆序输出&lt;/h3&gt;
&lt;p&gt;将任何文本使用管道输送给&lt;code&gt;rev&lt;/code&gt;命令，它就会将文本内容逆序输出。&lt;code&gt;fortune | rev&lt;/code&gt;会给你好运。当然，这不意味着rev会将幸运（fortune）转换成不幸。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_11-100587364-orig.png"&gt;&lt;/p&gt;
&lt;h3&gt;Matrix依然很酷，不是吗？&lt;/h3&gt;
&lt;p&gt;想让你的终端显示滚动的文字、l33t和Matrix电影中的坠落数码？&lt;code&gt;cmatrix&lt;/code&gt;是你的朋友。你甚至可以用它输出不同的颜色，非常华丽。使用&lt;code&gt;man cmatrix&lt;/code&gt;学习使用方法。或者使用更好的方法，“man cmatrix | lolcat”。这确实是你在Linux终端可以做的最没实际用途却又精彩的事情了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="http://images.techhive.com/images/article/2015/05/slide_12-100587366-orig.png"&gt;&lt;/p&gt;
&lt;p&gt;以上就是全部内容了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://www.networkworld.com/article/2926630/linux/11-pointless-but-awesome-linux-terminal-tricks.html&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://www.networkworld.com/author/Bryan-Lunduke/"&gt;Bryan Lunduke&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="https://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 20 个为桌面用户准备的令人惊叹的 Docker 容器</title><link href="/yi-20-ge-wei-zhuo-mian-yong-hu-zhun-bei-de-ling-ren-liang-tan-de-docker-rong-qi.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-20-ge-wei-zhuo-mian-yong-hu-zhun-bei-de-ling-ren-liang-tan-de-docker-rong-qi.html</id><summary type="html">&lt;p&gt;大家好，今天我们会列出一些运行在Docker容器中的很棒的桌面软件，我们可以在自己的桌面系统中运行它们。Docker 是一个开源项目，提供了一个可以打包、装载和运行任何应用的轻量级容器的开放平台。它没有语言支持、框架和打包系统的限制，从小型的家用电脑到高端服务器，在何时何地都可以运行。它可以使部署和扩展web应用程序、数据库和后端服务像搭积木一样容易，而不依赖特定技术栈或提供商。它主要是由开发、运维工程师使用的，因为它简单、快速和方便，可以用来测试和辅助开发他们产品，但是我们也可以在桌面环境使用Docker，这样一些桌面程序可以开箱即用。&lt;/p&gt;
&lt;p&gt;下边是20个非常棒的桌面软件docker镜像，我们可以使用Docker来运行。&lt;/p&gt;
&lt;h3&gt;1. Lynx&lt;/h3&gt;
&lt;p&gt;Lynx是一个一直以来最受欢迎的文本界面网页浏览器，很多Linux用户都很熟悉它。它应该是现在还在日常和开发环境中被使用的最古老的网页浏览器了。可以使用如下命令运行Lync。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
--name lynx &lt;span class="se"&gt;\&lt;/span&gt;
jess/lynx
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. Irssi&lt;/h3&gt;
&lt;p&gt;Irssi是一个非常棒的文本界面IRC客户端。可以使用如下命令运行Irssi。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker run -it --name my-irssi -e TERM -u $(id -u …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;大家好，今天我们会列出一些运行在Docker容器中的很棒的桌面软件，我们可以在自己的桌面系统中运行它们。Docker 是一个开源项目，提供了一个可以打包、装载和运行任何应用的轻量级容器的开放平台。它没有语言支持、框架和打包系统的限制，从小型的家用电脑到高端服务器，在何时何地都可以运行。它可以使部署和扩展web应用程序、数据库和后端服务像搭积木一样容易，而不依赖特定技术栈或提供商。它主要是由开发、运维工程师使用的，因为它简单、快速和方便，可以用来测试和辅助开发他们产品，但是我们也可以在桌面环境使用Docker，这样一些桌面程序可以开箱即用。&lt;/p&gt;
&lt;p&gt;下边是20个非常棒的桌面软件docker镜像，我们可以使用Docker来运行。&lt;/p&gt;
&lt;h3&gt;1. Lynx&lt;/h3&gt;
&lt;p&gt;Lynx是一个一直以来最受欢迎的文本界面网页浏览器，很多Linux用户都很熟悉它。它应该是现在还在日常和开发环境中被使用的最古老的网页浏览器了。可以使用如下命令运行Lync。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
--name lynx &lt;span class="se"&gt;\&lt;/span&gt;
jess/lynx
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. Irssi&lt;/h3&gt;
&lt;p&gt;Irssi是一个非常棒的文本界面IRC客户端。可以使用如下命令运行Irssi。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker run -it --name my-irssi -e TERM -u $(id -u):$(id -g) \
-v $HOME/.irssi:/home/user/.irssi:ro \
-v /etc/localtime:/etc/localtime:ro \
irssi
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3. Chrome&lt;/h3&gt;
&lt;p&gt;Chrome是一个令人惊叹的图形界面网页浏览器，由Google开发，它基于开源的Chromium项目。Google Chrome是一个被广泛使用的、快速安全的网页浏览器，经常上网的人会非常熟悉它。我们可以使用如下命令在Docker中运行Chrome。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
--net host &lt;span class="se"&gt;\&lt;/span&gt;
--cpuset &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
--memory 512mb &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;unix&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/Downloads:/root/Downloads &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/.config/google-chrome/:/data &lt;span class="se"&gt;\&lt;/span&gt;
-v /dev/snd:/dev/snd --privileged &lt;span class="se"&gt;\&lt;/span&gt;
--name chrome &lt;span class="se"&gt;\&lt;/span&gt;
jess/chrome
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;4. Tor浏览器&lt;/h3&gt;
&lt;p&gt;Tor浏览器是一个支持匿名访问的网页浏览器。它让我们可以自由地在网络世界遨游，或者浏览被特定组织或者网络服务提供商封锁的网站。它会阻止别人通过监视我们的网络连接来窃取我们在网络上的一举一动以及我们的确切位置。运行如下命令运行Tor浏览器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;unix&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-v /dev/snd:/dev/snd --privileged &lt;span class="se"&gt;\&lt;/span&gt;
--name tor-browser &lt;span class="se"&gt;\&lt;/span&gt;
jess/tor-browser
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;5. Firefox浏览器&lt;/h3&gt;
&lt;p&gt;Firefox浏览器是一个自由开源的网页浏览器，它由Mozilla基金会开发。它使用Gecko和SpiderMonkey引擎。Firefox浏览器有很多新特性，并且它以性能和安全性著称。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -d &lt;span class="se"&gt;\&lt;/span&gt;
--name firefox &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
kennethkl/firefox
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;6. Rainbow Stream&lt;/h3&gt;
&lt;p&gt;Rainbow Stream是一个文本界面的Twitter客户端，有实时显示tweetstream、搜索、喜欢和更多其他特性，可以直接在终端使用。使用如下命令运行Rainbow Stream。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /etc/localtime:/etc/localtime &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/.rainbow_oauth:/root/.rainbow_oauth &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/.rainbow_config.json:/root/.rainbow_config.json &lt;span class="se"&gt;\&lt;/span&gt;
--name rainbowstream &lt;span class="se"&gt;\&lt;/span&gt;
jess/rainbowstream
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;7. Gparted&lt;/h3&gt;
&lt;p&gt;Gparted是一个用来给磁盘分区的开源软件。现在可以在Docker容器里享受分区的乐趣了。可以使用如下命令运行gparted。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;unix&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
--device /dev/sda:/dev/sda &lt;span class="se"&gt;\ &lt;/span&gt;&lt;span class="c1"&gt;# 将设备挂载为分区&lt;/span&gt;
--name gparted &lt;span class="se"&gt;\&lt;/span&gt;
jess/gparted
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;8. GIMP图片编辑器&lt;/h3&gt;
&lt;p&gt;GIMP（Gnu Image Manipulation Program）是一个令人惊叹的Linux图片编辑软件。它是一个可以自由分发的可以处理照片修正、图像合成和图像创作等任务的工具。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
--rm -e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
jarfil/gimp-git
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;9. Thunderbird&lt;/h3&gt;
&lt;p&gt;Thunderbird是一个自由开源的电子邮件软件，它由Mozilla基金会开发和维护。它有众多一个电子邮件软件应该具有的功能。Thunderbird非常易于安装和定制。使用如下命令在Docker中运行Thunderbird。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -d &lt;span class="se"&gt;\&lt;/span&gt;
-e DISPLAY &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix:ro &lt;span class="se"&gt;\&lt;/span&gt;
-u docker &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/docker-data/thunderbird:/home/docker/.thunderbird/ &lt;span class="se"&gt;\&lt;/span&gt;
yantis/thunderbird thunderbird
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;10. Mutt&lt;/h3&gt;
&lt;p&gt;Mutt是一个文本界面的电子邮件客户端，有很多很酷的功能，如彩色支持，IMAP、POP3、SMTP支持，邮件存储支持等。 使用如下命令运行Mutt。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /etc/localtime:/etc/localtime &lt;span class="se"&gt;\&lt;/span&gt;
-e GMAIL -e GMAIL_NAME &lt;span class="se"&gt;\&lt;/span&gt;
-e GMAIL_PASS -e GMAIL_FROM &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/.gnupg:/home/user/.gnupg &lt;span class="se"&gt;\&lt;/span&gt;
--name mutt &lt;span class="se"&gt;\&lt;/span&gt;
jess/mutt
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;11. Skype&lt;/h3&gt;
&lt;p&gt;Skype是一个支持文字、语音和视频的即时通讯软件，它不是开源的，但在Linux下可以运行的很好。我们同样可以在Docker中运行Skype，使用如下命令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix:ro &lt;span class="se"&gt;\&lt;/span&gt;
-v /dev/snd:/dev/snd --privileged &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;unix&lt;/span&gt;&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
tianon/skype
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;12. Cathode&lt;/h3&gt;
&lt;p&gt;Cathode是一个漂亮并且高度可定制的终端模拟器，灵感来自古典计算机。使用如下命令运行Cathode。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;unix&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
--name cathode &lt;span class="se"&gt;\&lt;/span&gt;
jess/1995
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;13. LibreOffice&lt;/h3&gt;
&lt;p&gt;LibreOffice是一个功能强大的办公套件，它是自由开源的，现在由The Document基金会维护。它有干净的界面和强大的功能，让我们释放创造力和提升生产力。LibreOffice将数个应用程序集成在一起，是市面上最强大的自由并且开源的办公套件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$docker run \
-v $HOME/Documents:/home/libreoffice/Documents:rw \
-v /tmp/.X11-unix:/tmp/.X11-unix \
-e uid=$(id -u) -e gid=$(id -g) \
-e DISPLAY=unix$DISPLAY --name libreoffice \
chrisdaish/libreoffice
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;14. Spotify&lt;/h3&gt;
&lt;p&gt;Spotify可以即时访问数百万的歌曲，从经典老歌到最新单曲。可以使用如下命令在Docker中听我们最喜欢的歌曲。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;unix&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-v /dev/snd:/dev/snd --privileged &lt;span class="se"&gt;\&lt;/span&gt;
--name spotify &lt;span class="se"&gt;\&lt;/span&gt;
jess/spotify
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;15. Audacity&lt;/h3&gt;
&lt;p&gt;Audacity是一个自由开源的跨平台软件，用来录制和编辑音频。Audacity可以用来做所有类型音频（例如podcast）的后期处理，如归一化、调整、淡入淡出。使用如下命令来运行Audacity。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run --rm &lt;span class="se"&gt;\&lt;/span&gt;
-u &lt;span class="k"&gt;$(&lt;/span&gt;id -u&lt;span class="k"&gt;)&lt;/span&gt;:&lt;span class="k"&gt;$(&lt;/span&gt;id -g&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix:ro &lt;span class="se"&gt;\&lt;/span&gt;
-v /dev/snd:/dev/snd &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;:&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-w &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$HOME&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;unix&lt;/span&gt;&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-e HOME &lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="k"&gt;$(&lt;/span&gt;find /dev/snd/ -type c &lt;span class="p"&gt;|&lt;/span&gt; sed &lt;span class="s1"&gt;&amp;#39;s/^/--device /&amp;#39;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
knickers/audacity
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;16. Eclipse&lt;/h3&gt;
&lt;p&gt;Eclipse是一个集成开发环境。它包含基本的工作区和用来定制环境的可扩展插件系统。它在Java开发者中很流行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -v ~/workspace/:/home/eclipse/workspace/ &lt;span class="se"&gt;\&lt;/span&gt;
-e DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix:ro &lt;span class="se"&gt;\&lt;/span&gt;
-d leesah/eclipse
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;17. VLC媒体播放器&lt;/h3&gt;
&lt;p&gt;VLC是一个自由开源的跨平台多媒体播放器，可以播放本地文件、DVD、CD、VCD和各种流媒体。VLC由VideoLAN组织开发和维护。使用如下命令运行VLC。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -v&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="nv"&gt;$HOME&lt;/span&gt;/Documents:/home/vlc/Documents:rw &lt;span class="se"&gt;\&lt;/span&gt;
-v /dev/snd:/dev/snd --privileged &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;uid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;id -u&lt;span class="k"&gt;)&lt;/span&gt; -e &lt;span class="nv"&gt;gid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;id -g&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-e &lt;span class="nv"&gt;DISPLAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;unix&lt;span class="nv"&gt;$DISPLAY&lt;/span&gt; --name vlc &lt;span class="se"&gt;\&lt;/span&gt;
chrisdaish/vlc
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;18. Vim编辑器&lt;/h3&gt;
&lt;p&gt;Vim是一个高度可配置的文本界面文字编辑器，为高效的文本编辑而生。它是预装在多数UNIX系统中的vi编辑器的改进版本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -i -t --name my-vim -v ~/:/home/dev/src haron/vim
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;19. Inkscape&lt;/h3&gt;
&lt;p&gt;Inkscape是一个自由开源的矢量图形编辑器。它可以创建、编辑矢量图形，如插图、图示、线条艺术、图表、徽标以及更复杂的绘画。Inkscape使用的主要矢量图形格式是SVG 1.1版本。它也可以导入和导出一些其他的格式，但实际编辑使用的还是SVG格式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$docker build -t rasch/inkscape --rm .
$ docker run --rm -e DISPLAY \
-u inkscaper
-v /tmp/.X11-unix:/tmp/.X11-unix \
-v $HOME/.Xauthority:/home/inkscaper/.Xauthority \
--net=host rasch/inkscape
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;20. Filezilla&lt;/h3&gt;
&lt;p&gt;Filezilla是一个免费的FTP解决方案，支持FTP、SFTP、FTPS协议。它的客户端是一个功能强大的文件管理工具。它是一个很棒的高度可靠和易用的开源FTP解决方案。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ xhost +si:localuser:&lt;span class="k"&gt;$(&lt;/span&gt;whoami&lt;span class="k"&gt;)&lt;/span&gt;
$ docker run &lt;span class="se"&gt;\&lt;/span&gt;
-d &lt;span class="se"&gt;\&lt;/span&gt;
-e DISPLAY &lt;span class="se"&gt;\&lt;/span&gt;
-v /tmp/.X11-unix:/tmp/.X11-unix:ro &lt;span class="se"&gt;\&lt;/span&gt;
-u docker &lt;span class="se"&gt;\&lt;/span&gt;
-v /:/host &lt;span class="se"&gt;\&lt;/span&gt;
-v &lt;span class="nv"&gt;$HOME&lt;/span&gt;/docker-data/filezilla:/home/docker/.config/filezilla/ &lt;span class="se"&gt;\&lt;/span&gt;
yantis/filezilla filezilla
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;使用Docker运行桌面软件真的是很棒的体验。Docker是一个快速、简单的开发平台，适合从家里、办公室到生产环境里传送和开发软件的场景。使用Docker运行桌面软件是试用而不将其安装到自己实体机文件系统中的很酷的方法。如果你有任何问题、评论或者反馈，清写在下方的评论框中，让我们知道哪些是需要增加或者改进的。谢谢！享受Docker吧 :-)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://linoxide.com/how-tos/20-docker-containers-desktop-user/&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://linoxide.com/author/arunp/"&gt;Arun Pyasi&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 4 个可以发送完整电子邮件的命令行工具</title><link href="/yi-4-ge-ke-yi-fa-song-wan-zheng-dian-zi-you-jian-de-ming-ling-xing-gong-ju.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-4-ge-ke-yi-fa-song-wan-zheng-dian-zi-you-jian-de-ming-ling-xing-gong-ju.html</id><summary type="html">&lt;p&gt;今天的文章里我们会讲到一些使用Linux命令行工具来发送带附件的电子邮件的方法。它有很多用处，比如在应用程序所在服务器上，使用电子邮件发送一个文件过来，或者你可以在脚本中使用这些命令来做一些自动化操作。在本文的例子中，我们会使用foo.tar.gz文件作为附件。&lt;/p&gt;
&lt;p&gt;有不同的命令行工具可以发送邮件，这里我分享几个多数用户会使用的工具，如&lt;code&gt;mailx&lt;/code&gt;、&lt;code&gt;mutt&lt;/code&gt;和&lt;code&gt;swaks&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们即将呈现的这些工具都是非常有名的，并且存在于多数Linux发行版默认的软件仓库中，你可以使用如下命令安装：&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Debian / Ubuntu&lt;/strong&gt; 系统&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get install mutt
apt-get install swaks
apt-get install mailx
apt-get install sharutils
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在基于Red Hat的系统，如 &lt;strong&gt;CentOS&lt;/strong&gt; 或者 &lt;strong&gt;Fedora&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install mutt
yum install swaks
yum install mailx …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;今天的文章里我们会讲到一些使用Linux命令行工具来发送带附件的电子邮件的方法。它有很多用处，比如在应用程序所在服务器上，使用电子邮件发送一个文件过来，或者你可以在脚本中使用这些命令来做一些自动化操作。在本文的例子中，我们会使用foo.tar.gz文件作为附件。&lt;/p&gt;
&lt;p&gt;有不同的命令行工具可以发送邮件，这里我分享几个多数用户会使用的工具，如&lt;code&gt;mailx&lt;/code&gt;、&lt;code&gt;mutt&lt;/code&gt;和&lt;code&gt;swaks&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们即将呈现的这些工具都是非常有名的，并且存在于多数Linux发行版默认的软件仓库中，你可以使用如下命令安装：&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Debian / Ubuntu&lt;/strong&gt; 系统&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get install mutt
apt-get install swaks
apt-get install mailx
apt-get install sharutils
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在基于Red Hat的系统，如 &lt;strong&gt;CentOS&lt;/strong&gt; 或者 &lt;strong&gt;Fedora&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install mutt
yum install swaks
yum install mailx
yum install sharutils
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;1) 使用 mail / mailx&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;mailx&lt;/code&gt;工具在多数Linux发行版中是默认的邮件程序，现在已经支持发送附件了。如果它不在你的系统中，你可以使用上边的命令安装。有一点需要注意，老版本的mailx可能不支持发送附件，运行如下命令查看是否支持。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ man mail
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一行看起来是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mailx [-BDdEFintv~] [-s subject] [-a attachment ] [-c cc-addr] [-b bcc-addr] [-r from-addr] [-h hops] [-A account] [-S variable[=value]] to-addr . . .
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你看到它支持&lt;code&gt;-a&lt;/code&gt;的选项（-a 文件名，将文件作为附件添加到邮件）和&lt;code&gt;-s&lt;/code&gt;选项（-s 主题，指定邮件的主题），那就是支持的。可以使用如下的几个例子发送邮件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a) 简单的邮件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运行&lt;code&gt;mail&lt;/code&gt;命令，然后&lt;code&gt;mailx&lt;/code&gt;会等待你输入邮件内容。你可以按回车来换行。当输入完成后，按Ctrl + D，&lt;code&gt;mailx&lt;/code&gt;会显示EOT表示结束。&lt;/p&gt;
&lt;p&gt;然后&lt;code&gt;mailx&lt;/code&gt;会自动将邮件发送给收件人。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mail user@example.com

HI,
Good Morning
How are you
EOT
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;b) 发送有主题的邮件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Email text&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; mail -s &lt;span class="s2"&gt;&amp;quot;Test Subject&amp;quot;&lt;/span&gt; user@example.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;-s&lt;/code&gt;的用处是指定邮件的主题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c) 从文件中读取邮件内容并发送&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mail -s &lt;span class="s2"&gt;&amp;quot;message send from file&amp;quot;&lt;/span&gt; user@example.com &amp;lt; /path/to/file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;d) 将从管道获取到的&lt;code&gt;echo&lt;/code&gt;命令输出作为邮件内容发送&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;This is message body&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; mail -s &lt;span class="s2"&gt;&amp;quot;This is Subject&amp;quot;&lt;/span&gt; user@example.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;e) 发送带附件的邮件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; “Body with attachment &lt;span class="s2"&gt;&amp;quot;| mail -a foo.tar.gz -s &amp;quot;&lt;/span&gt;attached file&lt;span class="s2"&gt;&amp;quot; user@example.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;-a&lt;/code&gt;选项用于指定附件。&lt;/p&gt;
&lt;h3&gt;2) mutt&lt;/h3&gt;
&lt;p&gt;Mutt是类Unix系统上的一个文本界面邮件客户端。它有20多年的历史，在Linux历史中也是一个很重要的部分，它是最早支持进程打分和多线程处理的客户端程序之一。按照如下的例子来发送邮件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a) 带有主题，从文件中读取邮件的正文，并发送&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ mutt -s &lt;span class="s2"&gt;&amp;quot;Testing from mutt&amp;quot;&lt;/span&gt; user@example.com &amp;lt; /tmp/message.txt
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;b) 通过管道获取&lt;code&gt;echo&lt;/code&gt;命令输出作为邮件内容发送&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;This is the body&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; mutt -s &lt;span class="s2"&gt;&amp;quot;Testing mutt&amp;quot;&lt;/span&gt; user@example.com
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;c) 发送带附件的邮件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;This is the body&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; mutt -s &lt;span class="s2"&gt;&amp;quot;Testing mutt&amp;quot;&lt;/span&gt; user@example.com -a /tmp/foo.tar.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;d) 发送带有多个附件的邮件&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;This is the body&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; mutt -s &lt;span class="s2"&gt;&amp;quot;Testing&amp;quot;&lt;/span&gt; user@example.com -a foo.tar.gz –a bar.tar.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3) swaks&lt;/h3&gt;
&lt;p&gt;Swaks（Swiss Army Knife，瑞士军刀）是SMTP服务上的瑞士军刀，它是一个功能强大、灵活、可编程、面向事务的SMTP测试工具，由John Jetmore开发和维护。你可以使用如下语法发送带附件的邮件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ swaks -t &lt;span class="s2"&gt;&amp;quot;foo@bar.com&amp;quot;&lt;/span&gt; --header &lt;span class="s2"&gt;&amp;quot;Subject: Subject&amp;quot;&lt;/span&gt; --body &lt;span class="s2"&gt;&amp;quot;Email Text&amp;quot;&lt;/span&gt; --attach foo.tar.gz
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于Swaks一个重要的地方是，它会为你显示整个邮件发送过程，所以如果你想调试邮件发送过程，它是一个非常有用的工具。&lt;/p&gt;
&lt;p&gt;它会给你提供了邮件发送过程的所有细节，包括邮件接收服务器的功能支持、两个服务器之间的每一步交互。&lt;/p&gt;
&lt;h3&gt;4) uuencode&lt;/h3&gt;
&lt;p&gt;邮件传输系统最初是被设计来传送7位编码（类似ASCII）的内容的。这就意味这它是用来发送文本内容，而不能发会使用8位的二进制内容（如程序文件或者图片）。&lt;code&gt;uuencode&lt;/code&gt;（“UNIX to UNIX encoding”，UNIX之间使用的编码方式）程序用来解决这个限制。使用&lt;code&gt;uuencode&lt;/code&gt;，发送端将二进制格式的转换成文本格式来传输，接收端再转换回去。&lt;/p&gt;
&lt;p&gt;我们可以简单地使用&lt;code&gt;uuencode&lt;/code&gt;和&lt;code&gt;mailx&lt;/code&gt;或者&lt;code&gt;mutt&lt;/code&gt;配合，来发送二进制内容，类似这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ uuencode example.jpeg example.jpeg &lt;span class="p"&gt;|&lt;/span&gt; mail user@example.com
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Shell脚本：解释如何发送邮件&lt;/h3&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;

&lt;span class="nv"&gt;FROM&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;SUBJECT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;ATTACHMENTS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;TO&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;BODY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;# 检查文件名对应的文件是否存在&lt;/span&gt;
&lt;span class="k"&gt;function&lt;/span&gt; check_files&lt;span class="o"&gt;()&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="nv"&gt;output_files&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; file in &lt;span class="nv"&gt;$1&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -s &lt;span class="nv"&gt;$file&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nv"&gt;output_files&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;output_files&lt;/span&gt;&lt;span class="si"&gt;}${&lt;/span&gt;&lt;span class="nv"&gt;file&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt; &amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$output_files&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;*********************&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;E-mail sending script.&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;*********************&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt;

&lt;span class="c1"&gt;# 读取用户输入的邮件地址&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; ! &lt;span class="nv"&gt;$FROM&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; -n -e &lt;span class="s2"&gt;&amp;quot;Enter the e-mail address you wish to send mail from:\n[Enter] &amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; -n -e &lt;span class="s2"&gt;&amp;quot;The address you provided is not valid:\n[Enter] &amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="nb"&gt;read&lt;/span&gt; FROM
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$FROM&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep -E &lt;span class="s1"&gt;&amp;#39;^.+@.+$&amp;#39;&lt;/span&gt; &amp;gt; /dev/null
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -eq &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nb"&gt;break&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt;

&lt;span class="c1"&gt;# 读取用户输入的收件人地址&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; ! &lt;span class="nv"&gt;$TO&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; -n -e &lt;span class="s2"&gt;&amp;quot;Enter the e-mail address you wish to send mail to:\n[Enter] &amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; -n -e &lt;span class="s2"&gt;&amp;quot;The address you provided is not valid:\n[Enter] &amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="nb"&gt;read&lt;/span&gt; TO
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$TO&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep -E &lt;span class="s1"&gt;&amp;#39;^.+@.+$&amp;#39;&lt;/span&gt; &amp;gt; /dev/null
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; -eq &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nb"&gt;break&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt;

&lt;span class="c1"&gt;# 读取用户输入的邮件主题&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; -n -e &lt;span class="s2"&gt;&amp;quot;Enter e-mail subject:\n[Enter] &amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;read&lt;/span&gt; SUBJECT

&lt;span class="nb"&gt;echo&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$SUBJECT&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;then&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Proceeding without the subject...&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="c1"&gt;# 读取作为附件的文件名&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; -e &lt;span class="s2"&gt;&amp;quot;Provide the list of attachments. Separate names by space.&lt;/span&gt;
&lt;span class="s2"&gt;If there are spaces in file name, quote file name with \&amp;quot;.&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;read&lt;/span&gt; att

&lt;span class="nb"&gt;echo&lt;/span&gt;

&lt;span class="c1"&gt;# 确保文件名指向真实文件&lt;/span&gt;
&lt;span class="nv"&gt;attachments&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;check_files &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$att&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Attachments: &lt;/span&gt;&lt;span class="nv"&gt;$attachments&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; attachment in &lt;span class="nv"&gt;$attachments&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="nv"&gt;ATTACHMENTS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$ATTACHMENTS&lt;/span&gt;&lt;span class="s2"&gt;-a &lt;/span&gt;&lt;span class="nv"&gt;$attachment&lt;/span&gt;&lt;span class="s2"&gt; &amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;

&lt;span class="nb"&gt;echo&lt;/span&gt;

&lt;span class="c1"&gt;# 读取完整的邮件正文&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Enter message. To mark the end of message type ;; in new line.&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;read&lt;/span&gt; line

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$line&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; !&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;;;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="nv"&gt;BODY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$BODY$line&lt;/span&gt;&lt;span class="s2"&gt;\n&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;read&lt;/span&gt; line
&lt;span class="k"&gt;done&lt;/span&gt;

&lt;span class="nv"&gt;SENDMAILCMD&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;mutt -e \&amp;quot;set from=&lt;/span&gt;&lt;span class="nv"&gt;$FROM&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot; -s \&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$SUBJECT&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot; \&lt;/span&gt;
&lt;span class="nv"&gt;$ATTACHMENTS&lt;/span&gt;&lt;span class="s2"&gt; -- \&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$TO&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot; &amp;lt;&amp;lt;&amp;lt; \&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$BODY&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$SENDMAILCMD&lt;/span&gt;

mutt -e &lt;span class="s2"&gt;&amp;quot;set from=&lt;/span&gt;&lt;span class="nv"&gt;$FROM&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; -s &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$SUBJECT&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$ATTACHMENTS&lt;/span&gt; -- &lt;span class="nv"&gt;$TO&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nv"&gt;$BODY&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;strong&gt; 脚本输出 &lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ bash send_mail.sh
*********************
E-mail sending script.
*********************

Enter the e-mail address you wish to send mail from:
&lt;span class="o"&gt;[&lt;/span&gt;Enter&lt;span class="o"&gt;]&lt;/span&gt; test@gmail.com

Enter the e-mail address you wish to send mail to:
&lt;span class="o"&gt;[&lt;/span&gt;Enter&lt;span class="o"&gt;]&lt;/span&gt; test@gmail.com

Enter e-mail subject:
&lt;span class="o"&gt;[&lt;/span&gt;Enter&lt;span class="o"&gt;]&lt;/span&gt; Message subject

Provide the list of attachments. Separate names by space.
If there are spaces in file name, quote file name with &lt;span class="s2"&gt;&amp;quot;.&lt;/span&gt;
&lt;span class="s2"&gt;send_mail.sh&lt;/span&gt;

&lt;span class="s2"&gt;Attachments: send_mail.sh&lt;/span&gt;

&lt;span class="s2"&gt;Enter message. To mark the end of message type ;; in new line.&lt;/span&gt;
&lt;span class="s2"&gt;This is a message&lt;/span&gt;
&lt;span class="s2"&gt;text&lt;/span&gt;
&lt;span class="s2"&gt;;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;有很多方法可以使用命令行/Shell脚本来发送邮件，这里我们只分享了其中4个类Unix系统可用的工具。希望你喜欢我们的文章，并且提供您的宝贵意见，让我们知道您想了解哪些新工具。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://linoxide.com/linux-shell-script/send-email-subject-body-attachment-linux/&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://linoxide.com/author/bobbin/"&gt;Bobbin Zachariah&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 5 个有趣的 Linux 命令行技巧</title><link href="/yi-5-ge-you-qu-de-linux-ming-ling-xing-ji-qiao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-5-ge-you-qu-de-linux-ming-ling-xing-ji-qiao.html</id><summary type="html">&lt;p&gt;你有将Linux物尽其用吗？对很多Linux用户来说，有很多看起来是技巧的有用特性。有些时候你会需要这些技巧。本文会帮助你更好得使用一些命令，发挥其更强大的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="5个命令行技巧" src="http://www.tecmint.com/wp-content/uploads/2015/03/5-Command-Line-Tips.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图1：5个命令行技巧&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们开始一个新的系列，在这里我们还会写一些技巧，并且用尽量小的篇幅写清楚。&lt;/p&gt;
&lt;h3&gt;1. 我们可以使用&lt;a href="https://linux.cn/article-1143-1.html"&gt;&lt;code&gt;history&lt;/code&gt;命令&lt;/a&gt;来查看曾经运行过的命令。&lt;/h3&gt;
&lt;p&gt;这里是一个&lt;code&gt;history&lt;/code&gt;命令的示例输出。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# history
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="history命令例子" src="http://www.tecmint.com/wp-content/uploads/2015/03/history-command.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图2：history命令例子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;history&lt;/code&gt;命令输出看，很明显，命令的执行时间没有被打出来。有解决方法吗？有的！运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# HISTTIMEFORMAT=&amp;quot;%d/%m/%y %T &amp;quot;
# history
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你想让这个修改永久生效，添加如下的一行内容到&lt;code&gt;~/.bashrc&lt;/code&gt;文件中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;export HISTTIMEFORMAT=&amp;quot;%d/%m/%y %T &amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，在终端中运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# source ~/.bashrc …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;你有将Linux物尽其用吗？对很多Linux用户来说，有很多看起来是技巧的有用特性。有些时候你会需要这些技巧。本文会帮助你更好得使用一些命令，发挥其更强大的功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt="5个命令行技巧" src="http://www.tecmint.com/wp-content/uploads/2015/03/5-Command-Line-Tips.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图1：5个命令行技巧&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们开始一个新的系列，在这里我们还会写一些技巧，并且用尽量小的篇幅写清楚。&lt;/p&gt;
&lt;h3&gt;1. 我们可以使用&lt;a href="https://linux.cn/article-1143-1.html"&gt;&lt;code&gt;history&lt;/code&gt;命令&lt;/a&gt;来查看曾经运行过的命令。&lt;/h3&gt;
&lt;p&gt;这里是一个&lt;code&gt;history&lt;/code&gt;命令的示例输出。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# history
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="history命令例子" src="http://www.tecmint.com/wp-content/uploads/2015/03/history-command.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图2：history命令例子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;history&lt;/code&gt;命令输出看，很明显，命令的执行时间没有被打出来。有解决方法吗？有的！运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# HISTTIMEFORMAT=&amp;quot;%d/%m/%y %T &amp;quot;
# history
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你想让这个修改永久生效，添加如下的一行内容到&lt;code&gt;~/.bashrc&lt;/code&gt;文件中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;export HISTTIMEFORMAT=&amp;quot;%d/%m/%y %T &amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，在终端中运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# source ~/.bashrc
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;命令和选项的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;history – 查看运行过的命令&lt;/li&gt;
&lt;li&gt;HISTIMEFORMAT – 设置时间格式的环境变量&lt;/li&gt;
&lt;li&gt;%d – 天&lt;/li&gt;
&lt;li&gt;%m – 月&lt;/li&gt;
&lt;li&gt;%y – 年&lt;/li&gt;
&lt;li&gt;%T – 时间戳&lt;/li&gt;
&lt;li&gt;source – 简而言之就是将文件内容发送给shell来执行&lt;/li&gt;
&lt;li&gt;.bashrc – BASH以交互方式启动时运行的脚本文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="history命令输出的日志" src="http://www.tecmint.com/wp-content/uploads/2015/03/History-Command-Logs.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图3：&lt;code&gt;history&lt;/code&gt;命令输出的日志&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;2. 如何测试磁盘写入速度？&lt;/h3&gt;
&lt;p&gt;一行&lt;code&gt;dd&lt;/code&gt;命令脚本就可以实现。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# dd if=/dev/zero of=/tmp/output.img bs=8k count=256k conv=fdatasync; rm -rf /tmp/output.img
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="dd命令例子" src="http://www.tecmint.com/wp-content/uploads/2015/03/dd-Command-Example.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图4：&lt;code&gt;dd&lt;/code&gt;命令例子&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;命令和选项的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dd – 转换和复制文件&lt;/li&gt;
&lt;li&gt;if=/dev/zero – 指定输入文件，默认为stdin（标准输入）&lt;/li&gt;
&lt;li&gt;of=/tmp/output.img – 指定输出文件，默认为stdout（标准输出）&lt;/li&gt;
&lt;li&gt;bs – 一次读和写的块大小，最大可以以MB为单位&lt;/li&gt;
&lt;li&gt;count – 复制次数&lt;/li&gt;
&lt;li&gt;conv – 使用逗号分隔的策略来转换文件（LCTT 译注：比如将大写字母转换成小写，echo AA | dd conv=lcase）&lt;/li&gt;
&lt;li&gt;rm – 删除文件和目录&lt;/li&gt;
&lt;li&gt;-rf – （-r） 递归地删除目录和其中的内容，（-f）强行删除而不输出确认信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3. 你如何获取吃掉你磁盘空间的最大的6个文件？&lt;/h3&gt;
&lt;p&gt;一个使用&lt;a href="http://www.tecmint.com/check-linux-disk-usage-of-files-and-directories/"&gt;&lt;code&gt;du&lt;/code&gt;命令&lt;/a&gt;的简单单行脚本即可实现，&lt;code&gt;du&lt;/code&gt;命令主要用于获取文件的空间使用情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# du -hsx * | sort -rh | head -6
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="获取磁盘空间使用情况的方法" src="http://www.tecmint.com/wp-content/uploads/2015/03/check-disk-space-usage.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图5：获取磁盘空间使用情况的方法&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;命令和选项的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;du – 估计文件的空间使用情况&lt;/li&gt;
&lt;li&gt;-hsx – （-h）更易读的格式，（-s）汇总输出，（-x）跳过其他文件系统的文件&lt;/li&gt;
&lt;li&gt;sort – 对文本文件按行排序&lt;/li&gt;
&lt;li&gt;-rf – （-r）将比较的结果逆序输出，（-f）忽略大小写&lt;/li&gt;
&lt;li&gt;head – 输出文件的头几行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;4. 获取一个文件的详细状态信息&lt;/h3&gt;
&lt;p&gt;可以使用&lt;code&gt;stat&lt;/code&gt;命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# stat filename_ext  （例如：stat abc.pdf）
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="获取文件的详细信息" src="http://www.tecmint.com/wp-content/uploads/2015/03/Check-File-Statistics.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图6：获取文件的详细信息&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;5. 显示帮助&lt;/h3&gt;
&lt;p&gt;最后一个技巧是为那些入门者准备的，如果你是有经验的用户，可能不需要它，除非你想从中寻找乐趣。入门者可能有Linux命令行恐惧症，下面的命令会随机显示一个man手册页。对入门者来说，好处是总会学到新的东西，而且不会厌倦。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# man $(ls /bin | shuf | head -1)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="查看随机的man手册页" src="http://www.tecmint.com/wp-content/uploads/2015/03/Generate-Random-Man-Pages.gif"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;图7：查看随机的man手册页&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;命令和选项的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;man – Linux man手册&lt;/li&gt;
&lt;li&gt;ls – 列出文件&lt;/li&gt;
&lt;li&gt;/bin – 系统可执行文件的路径&lt;/li&gt;
&lt;li&gt;shuf – 把输入内容按行随机打乱并输出&lt;/li&gt;
&lt;li&gt;head – 输出文件的头几行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是所有的内容了。如果你知道任何类似的技巧，可以分享给我们，我们会用你的语言在网站上发表出来。&lt;/p&gt;
&lt;p&gt;不要忘记在下边评论框中留下有价值的反馈。保持联系。可以点赞或者将本文分享来帮助我们更好地传播内容。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://www.tecmint.com/5-linux-command-line-tricks/&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://www.tecmint.com/author/avishek/"&gt;Avishek Kumar&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 存储时间序列数据（“Time Series Databases”第三章）</title><link href="/yi-cun-chu-shi-jian-xu-lie-shu-ju-time-series-databasesdi-san-zhang.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-cun-chu-shi-jian-xu-lie-shu-ju-time-series-databasesdi-san-zhang.html</id><summary type="html">&lt;p&gt;就像我们在前一章提到的，一个时间序列是一系列数值，每个数值都伴随着一个时间值，代表数据被记录时的时间。时间序列数据存入后就很少再需要修改了，查询时经常是查询一个连续时间段的数据，也可能查询汇总或者聚合后的数据。时间序列数据库是一种储存多个时间序列的方式，在其中检索一个或几个时间序列的某一个特定时间段的数据是特别高效的。同样地，主要用来查询一个时间段数据的应用程序也适合使用时间序列数据库来实现。像之前所解释的，本书的主题是存储和处理大规模时间序列数据，为了实现这个目标，首选技术是非关系型NoSQL数据库，比如Apache HBase或MapR-DB。&lt;/p&gt;
&lt;p&gt;为大规模时间序列数据库的实际实现提供务实的建议，是本书的目标，所以我们需要聚焦于一些可以简化和增强真实世界中应用程序发展进程的一些基本步骤。我们会简单看看适用于中小型数据集的方法，然后深入探究我们主要关注的问题：如何实现大规模TSDB。&lt;/p&gt;
&lt;p&gt;为了得到一个扎实的实现，有几种可供选择的设计方法。如何选择取决于数据的属性。有多少种不同的时间序列？获得的数据是什么类型的？使用怎样的速度采集数据？需要存储多久的数据？这些问题的答案有助于我们确定最优的实现策略。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;这一章中的主要思想路线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽管我们已经提到处理时间序列数据的一些主要方面，这一章会比之前更深入地探讨存储和访问时间序列数据的基本方法。第四章会提供如何使用现有开源软件来最好地实现这些概念的建议。这两章有比较多的内容需要理解。然后你就可以记住如果将这些关键的想法集中到一起而不是迷失在细节中，这里是一个本章内容的一个简单路线图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平面文件&lt;ul&gt;
&lt;li&gt;对时间序列数据来说是受限的工具，不适合快速增长的数据，查询起来也会效率低下&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;真正的数据库：关系型数据库&lt;ul&gt;
&lt;li&gt;扩展性不好，常见的星型模式（star schema）不适合处理时间序列数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;真正的数据库 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;就像我们在前一章提到的，一个时间序列是一系列数值，每个数值都伴随着一个时间值，代表数据被记录时的时间。时间序列数据存入后就很少再需要修改了，查询时经常是查询一个连续时间段的数据，也可能查询汇总或者聚合后的数据。时间序列数据库是一种储存多个时间序列的方式，在其中检索一个或几个时间序列的某一个特定时间段的数据是特别高效的。同样地，主要用来查询一个时间段数据的应用程序也适合使用时间序列数据库来实现。像之前所解释的，本书的主题是存储和处理大规模时间序列数据，为了实现这个目标，首选技术是非关系型NoSQL数据库，比如Apache HBase或MapR-DB。&lt;/p&gt;
&lt;p&gt;为大规模时间序列数据库的实际实现提供务实的建议，是本书的目标，所以我们需要聚焦于一些可以简化和增强真实世界中应用程序发展进程的一些基本步骤。我们会简单看看适用于中小型数据集的方法，然后深入探究我们主要关注的问题：如何实现大规模TSDB。&lt;/p&gt;
&lt;p&gt;为了得到一个扎实的实现，有几种可供选择的设计方法。如何选择取决于数据的属性。有多少种不同的时间序列？获得的数据是什么类型的？使用怎样的速度采集数据？需要存储多久的数据？这些问题的答案有助于我们确定最优的实现策略。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;这一章中的主要思想路线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;尽管我们已经提到处理时间序列数据的一些主要方面，这一章会比之前更深入地探讨存储和访问时间序列数据的基本方法。第四章会提供如何使用现有开源软件来最好地实现这些概念的建议。这两章有比较多的内容需要理解。然后你就可以记住如果将这些关键的想法集中到一起而不是迷失在细节中，这里是一个本章内容的一个简单路线图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平面文件&lt;ul&gt;
&lt;li&gt;对时间序列数据来说是受限的工具，不适合快速增长的数据，查询起来也会效率低下&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;真正的数据库：关系型数据库&lt;ul&gt;
&lt;li&gt;扩展性不好，常见的星型模式（star schema）不适合处理时间序列数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;真正的数据库：非关系型NoSQL数据库&lt;ul&gt;
&lt;li&gt;首选方案，因为它可扩展型好、高效、能快速响应基于时间段的查询&lt;/li&gt;
&lt;li&gt;基本设计&lt;ul&gt;
&lt;li&gt;使用包含时间序列ID的唯一row key，列是不同时间偏移的数值&lt;/li&gt;
&lt;li&gt;存储多于一个时间序列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可选设计&lt;ul&gt;
&lt;li&gt;使用宽表逐点存储数据&lt;/li&gt;
&lt;li&gt;混合宽表和blob类型的设计&lt;/li&gt;
&lt;li&gt;将数据缓存到内存，然后blob直写&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;我们已经回顾了主要思想，现在我们更详细地重温一下并且解释它们的重要性。&lt;/p&gt;
&lt;h2&gt;最简单的数据存储：平面文件&lt;/h2&gt;
&lt;p&gt;你可以扩展非常简单的设计（比如简单的二维表），使用更聪明的文件格式来使其更先进，比如列存储的Parquet格式。Parquet是一个有效并且简单的现代化格式，可以存储时间和一些可选值。图3-1展示了两种记录时间序列数据的Parquet schema。左图中的schema适合你已经知道怎么合理使用时间序列数据的情况，它是一个特定场景的存储方案。例子中，只存了明确指定的4个时间序列的数据（一个存放时间的t和一个存放数据的tempIn组合起来，为一个时间序列。t和它对应的tempIn、pressureIn、tempOut、pressureOut即4个时间序列），如果需要增加新的，就需要修改schema。右图中的Parguet schema抽象程度更高，对你想要往文件里嵌入更多元数据的场景更适合。并且这种格式没有事先对时间序列的数量做任何限制。如果你想要构建一个给其他人使用的时间序列库，右边的格式会更合适一些。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/009.png"&gt;&lt;/p&gt;
&lt;p&gt;图3-1。使用Parquet格式来存储时间序列数据的两种可能的schema。左边的schema使用固定的类型名称将问题域确定了。在不改变schema的情况下，只可以存储4个时间序列。相反地，右边的schema更加灵活，你可以增加新的时间序列。另外它的抽象层次也更高，把几个单一的时间序列（一对time、value）按照tags分组，然后放到一个单独的block中。&lt;/p&gt;
&lt;p&gt;这样的一种时间序列数据（特别是使用类似Parquet格式的情况）是非常有用的，但前提是你需要分析的时间序列数量相对较小，并且所感兴趣的时间范围相对于单个文件所存储数据的时间跨度很大（比如每个文件存放一个月的数据，你查的时候也应该每次查一个月的数据，而不是每次查一天的）。&lt;/p&gt;
&lt;p&gt;系统最初使用平面文件来实现是一种非常普遍的情况，而且不久之后这种简单的实现不再适应快速增长的数据的情况也是很普遍的。基本问题是单一文件中的时间序列数量增加了，任何特定的查询中，真正有用的数据占所读取数据的比例就下降了，因为多数读取到的数据其实是属于其他时间序列的。&lt;/p&gt;
&lt;p&gt;同样地，在文件中的时间跨度比平均查询的时间范围已经长很多的情况，真正有用的数据占所被读取数据的比例又下降了，因为文件中的大部分数据已经在你感兴趣的时间范围之外了（比如数据记录了1个月的数据，而查询时一般只查某一天的，那为了定位到这一天，需要先读大量前边的实际不需要的数据）。努力解决这些问题的同时一般又会引入其他的问题。使用大量的文件来确保每个文件中只有较少的时间序列，会使文件数量大幅增长。同样地，减少每个文件所存储数据的时间范围会使得文件数量翻倍增长。当在一个类似Apache Hadoop中HDFS的文件系统存储数据时，大量的文件会导致严重的稳定性问题。基于Hadoop的上层系统，如MapR可以轻松处理大量的文件，但检索和管理大量的小文件也是很低效的，因为需要增加很多搜索时间。&lt;/p&gt;
&lt;p&gt;为了避免这些问题，很自然的一步是转而使用某些形式的真正的数据库来存储这些数据。选择合适的数据库的方法并不是显而易见的，但基于数据库的类型和它的设计方案，你有几个选项。我们会研究这些问题来帮助你作选择。&lt;/p&gt;
&lt;h2&gt;改用真正的数据库：RDBMS怎么样？&lt;/h2&gt;
&lt;p&gt;即使是经过良好分区的平面文件，在处理大规模时间序列数据时也会力不从心，所以你也行会考虑使用某些类型的真正的数据库。当第一次在数据库中存储时间序列数据时，使用所谓的星型模式（star schema）设计，并且将数据存放到RDBMS是个很诱人的选择。在这样一种数据库设计中，核心数据存放在事实表（fact table），就像图3-2展示的那样。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/010.png"&gt;&lt;/p&gt;
&lt;p&gt;图3-2。将时间序列数据存放到RDBMS的一个事实表的设计。其中存放了时间（TIme列）、序列ID（Time series ID列）和数值（Value列）三列。序列的细节存放在维表（dimension table）中（这一对Time、Value是一个时间序列，但这个时间序列的细节，比如Value的含义是什么，存放在另一张表中，可以使用Time series ID去那个表查）。&lt;/p&gt;
&lt;p&gt;在星型模式中，一个表存储主要的数据，并且会引用其他表（维表）。该设计一个核心假定是维表要相对小巧，而且不常变动。图3-2中的时间序列事实表里，唯一被引用的维表，就是存放这个时间序列详细信息的维表，它的内容是表中数据（Value列）的含义。比如，如果我们的时间序列数据是从一个工厂的泵或者其他设备从采集的，我们会希望在获取这个泵的多个维度的数据，如入口和出口的压强和温度、泵在不同频段的震动和泵自身的温度等。这其中的每个泵的每一个维度，都是一个单独的时间序列，每个时间序列会有类似泵的序列号、位置、商标、型号等信息，这些信息都存放在维表中。&lt;/p&gt;
&lt;p&gt;实际上一些应用程序已经使用像这样的星型模式来存放时间序列数据了。我们在多数NoSQL数据库中也可以使用这样的设计。星型模式解决了有大量不同时间序列的问题，在数据点的规模达到数亿甚至数十亿的情况下也可以工作得很好。然而就像我们在第一章中看到的，即使是19世纪的航运数据也会产生上十亿的数据点。在2014年，纳斯达克证券交易所在过去三个月就会处理十亿规模的交易量。记录一个中型计算机集群的运行环境的话，一天会产生五亿的数据点。&lt;/p&gt;
&lt;p&gt;并且简单地将这些数据存储起来是一回事，对其检索和处理就是另一回事了。现代的应用程序如机器学习系统甚至状态显示系统都需要每秒检索和处理上百万的数据点。&lt;/p&gt;
&lt;p&gt;虽然RDBMS可以扩展到这些大小、速度需求的下限，但带来的消耗和引入的复杂性会急剧上升。随着数据规模的继续增长，基于RDBMS的应用程序越来越不适合处理这样规模的时间序列数据了。使用星型模式但转而使用NoSQL数据库的话，也没有特别的帮助，因为这个问题的核心是星型模式带来的，而不只是数据量。&lt;/p&gt;
&lt;h2&gt;使用宽表（wide table）的NoSQL数据库&lt;/h2&gt;
&lt;p&gt;星型模式所触及的核心问题是每次测量都要使用一行。一个增加时间序列数据库中数据检索速度的技术是在每一行存储很多数值。在一些像Apache HBase或者MapR-DB的NoSQL数据库中，列的数量几乎是不受限制的，只要任何特定一行中有数据的列的数量在几十万之内。这种能力可以被用来在每行存放多个数值。这样做的话，数据点就可以被更高速地检索，因为扫描数据的最大速度部分取决于需要扫描的行的数量，部分取决于待检索数据点的总数，部分取决于待检索数据的总量。减少行的数量，就大幅减少了一部分检索开销，检索速度就提升了。图3-3展示了使用宽表来减少时间序列数据行数量的一种方式。这个技术和OpenTSDB（一个开源的数据库，我们会在第四章详细讲到）之中使用的默认表结构很相似。需要注意这样的表设计，和那些需要提前定义详细schema的系统的表设计是很不一样的。有一件事情，如果你想把schema写下来，那将异常庞大。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/011.png"&gt;&lt;/p&gt;
&lt;p&gt;图3-3，在NoSQL时间序列数据库中一个宽表的使用。关键的结构是直观的，在真正的应用程序中，使用的会是一个二进制的格式，但这样顺序的属性是一样的。&lt;/p&gt;
&lt;p&gt;因为HBase和MapR-DB都是按照主键的顺序来存储数据，图3-3中的键设计会导致每行包含一小段时间的数据在磁盘上是连续存储的（因为Row key是按时间顺序增长，HBase和MapR-DB是按列族存放数据的，Data values中的数据就会全部按照时间顺序存放在磁盘上）。这个设计意味着检索一个特定时间段的数据，涉及的主要是顺序磁盘操作，就会比数据按行分散开的情况快很多。为了从这个表结构获得性能优势，每个时间窗口的采样点要足够富裕，这样就可以减少行的数量，从而提升检索速度。典型情况，时间窗口会被调整成每一行包括100-1000采样点的样子。&lt;/p&gt;
&lt;h2&gt;混合模式设计的NoSQL数据库&lt;/h2&gt;
&lt;p&gt;图3-3中的表设计可以继续改进，通过将一行中的所有数据压缩成一个单一的被称作blob的数据结构。Blob可以高度压缩，所以需要从磁盘读取的数据量就更少了。并且，如果使用HBase来存储时间序列数据，每行只有一列的情况会减少了每列数据在HBase所使用的磁盘文件格式上的开销，这样又进一步提高了性能。图3-4的混合式表结构中，一些行的数据已经被压缩，另一些行没有。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/012.png"&gt;&lt;/p&gt;
&lt;p&gt;图3-4。在混合模式设计中，行中的数据可以被存储成一个单一的数据结构（blob）。注意实际压缩的数据更可能是二进制的格式。这里使用JSON格式显示是为了更容易理解。&lt;/p&gt;
&lt;p&gt;图3-3中的宽表格式可以进化成图3-4的压缩格式（blob样式），只要确保那些被压缩的行对应的时间窗口不会或者很少再有新增的数据。一般地，一旦时间窗口结束后，新的数据就不属于这个时间窗口了，然后对这个时间窗口中数据的压缩就可以开始了。因为在同一行中，已压缩和未压缩的数据可以共存，如果在对行压缩之后，又有新数据过来了，可以再简单地重新压缩这一行，将新数据合并进来。&lt;/p&gt;
&lt;p&gt;图3-5展示的是概念上的混合式时间序列数据库的数据流。&lt;/p&gt;
&lt;p&gt;在后台将数据从旧格式转换成blob格式，会让renderer（图3-5中所显示的）检索数据并绘制出来的速度有质的提升。例如，在4个节点的MapR集群中，数据以压缩格式存放的话，3千万的数据点可以在大概20秒内被检索、聚合、绘制出来。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/013.png"&gt;&lt;/p&gt;
&lt;p&gt;图3-5。混合式时间序列数据库的数据流。数据从数据源到达catcher，然后被插入到NoSQL数据库中。之后blob maker在后台定时将数据压缩成blob格式。数据由renderer检索和格式化。&lt;/p&gt;
&lt;h2&gt;再进一步：blob直写设计（The Direct Blob Insertion Design）&lt;/h2&gt;
&lt;p&gt;压缩旧数据依然存在一个性能瓶颈。因为数据以未压缩的格式插入进来，每个数据点到来后都需要对行做一个更新来将数值插入到数据库中。对行的更新操作会限制数据的插入速度到每个集群中的每个节点上只有每秒2万个数据点。&lt;/p&gt;
&lt;p&gt;另一方面，图3-6中的blob直写方式的数据流允许插入速度增加了大概1千倍。为什么blob直写方式会带来如此大的性能提升？基本的区别是blob maker被转移到catcher和NoSQL时间序列数据库之间了。使用这种方式，blob maker就可以从内存的数据缓存中直接读取输入的数据，而不是从存储层的宽表中提取之前已经被写入进去的数据。&lt;/p&gt;
&lt;p&gt;基本的思想是数据到达后先被存放在内存中。这些数据同时也被写入到日志文件中。这些日志文件就是图3-6中的restart logs，它们是在Hadoop系统存放的平面文件，不是存储层的一部分。Restart logs允许内存中的数据缓存被重新导入，在数据管道必须被重建的时候。&lt;/p&gt;
&lt;p&gt;在正常操作中，在时间窗口的末尾，新的内存中数据结构会被创建，现在旧的内存中数据结构就可以用来创建压缩的blob然后写入数据库了。一旦blob被写入了，日志文件就被删除了。这样就无需像之前的混合设计中将数据两次写入。在图3-5中的混合设计中，全部的输入数据流都会逐点写入到存储层，然后再被blob maker读取。读的情况和写大致一样。一旦数据被压缩成了blob，它又被写入到数据库中。相反地，在图3-6的blob直写设计的数据流中，完整的数据流只写入到内存中（这样速度很快），而不是写入到数据库中。数据在压缩成blob之前不会被写入到数据库，所以写入速度大幅提升。数据库操作的次数从之前数据点的数量变成了blob的数量，很容易将次数减少到之前几千分之一这样的量级。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/images/014.png"&gt;&lt;/p&gt;
&lt;p&gt;图3-6。Blob直写方式的数据流。Catcher在内存中暂存数据，并且将其写入到restart logs中。Blob maker周期地从缓存中读取数据，然后将压缩成的blob写入到数据库中。这个设计的性能提升来自于renderer可以同时从内存和数据库中获取数据。&lt;/p&gt;
&lt;p&gt;blob直写方式的优势是什么？一个真实世界的例子展示了它可以做什么。使用了这个架构，仅使用了一个10节点的MapR集群中的4个节点，就可以实现每秒往MapR-DB的表中插入超过一亿的数据点。这些节点都有着很高的性能，其中每个节点有15个CPU核、大量内存和12块高配置磁盘，但你使用多数硬件都可以达到这个性能级别的1/5到1/2。&lt;/p&gt;
&lt;p&gt;这个性能级别听起来是用来处理海量数据的，可能超出了我们所需要的处理能力，但是在第五章我们会展示为什么这样的性能是非常有用的，即使是对那些相对温和的应用程序。&lt;/p&gt;
&lt;h2&gt;为什么关系型数据库不是很合适&lt;/h2&gt;
&lt;p&gt;在这一点，询问为什么一个关系型数据库不能处理和使用混合模式的MapR-DB或者HBase所能承受的插入和分析数据的负载是公平的。当只有blob数据被插入而不使用宽表的情况，这个问题特别有趣，因为现代关系型数据库通常支持blob或者array类型。&lt;/p&gt;
&lt;p&gt;这个问题的答案是，关系型数据库主要解决的问题不是提高插入和检索数据的速度，它现在这样运行是有其合理性的。使用关系型数据库的主要原因也不是因为它有更好的性能。如果使用关系系型数据库的blob格式存储数据，就意味着需要放弃大多数其他好处。此外，SQL没有提供一个好的抽象方法，来隐藏访问blob格式数据中的细节。SQL不能用任何合理的方式来访问这些数据，并且像多行事务等特性也完全派不上用场了。事务在这里还会成为问题，因为即使不使用，它也会成为一种消耗。一个关系型数据库需要满足多行事务的需求，这使它更难被扩展到多个节点上。尽管使用如Oracle的高成本数据库可以在单个节点实现很高的性能。而使用类似Apache Hbase或者MapR-DB的NoSQL数据库，你可以简单地通过加硬件的方式实现更高的性能。&lt;/p&gt;
&lt;p&gt;为自己用不到的特性买单的模式在一些高性能系统中是存在的。为了可扩展而牺牲传统关系型数据库的一些固有特性也是常见的，但即使你这样做了，还是得不到自己想要的扩展性。在这种情况，使用类似HBase或者MapR-DB的替代方案是有实质上的好处的，因为你同时得到了性能和可扩展性。&lt;/p&gt;
&lt;h2&gt;混合模式设计：我可以从哪得到一个？&lt;/h2&gt;
&lt;p&gt;这些宽表、blob混合的表设计是非常诱人的。它们所许诺的巨大性能级别令人兴奋，而且它们能运行在有容错机制、基于Hadoop的系统（比如MapR），从运维的角度看也是很吸引人的。这些新方法都不是空想，它们已经被构建出来，并且被证明有着惊人的结果。然而我们在这里呈现的，很大程度都是概念上的东西。有真正已经实现的吗？下一章我们会讲到如何使用OpenTSDB（一个开源时间序列数据库工具）和几个开源的MapR扩展，来实现这些新的设计。结果是利用本章所描述的概念以达到高性能的时间序列数据库是现代使用场景所需要的。&lt;/p&gt;</content></entry><entry><title>[译] Inxi：获取 Linux 的系统和硬件信息</title><link href="/yi-inxihuo-qu-linux-de-xi-tong-he-ying-jian-xin-xi.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-inxihuo-qu-linux-de-xi-tong-he-ying-jian-xin-xi.html</id><summary type="html">&lt;p&gt;我们已经展示了一些不同的&lt;a href="https://linux.cn/article-1947-1.html"&gt;应用程序&lt;/a&gt;和方法来获取Linux的系统和硬件信息。在这一系列里，我们将看到如何使用&lt;strong&gt;inxi&lt;/strong&gt;来获取这些详情信息。在论坛技术支持中，它可以作为调试工具，迅速确定用户的系统配置和硬件信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Inxi&lt;/strong&gt;是一个可以获取完整的系统和硬件详情信息的命令行工具，内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件&lt;/li&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;li&gt;磁盘驱动器&lt;/li&gt;
&lt;li&gt;Xorg&lt;/li&gt;
&lt;li&gt;桌面环境&lt;/li&gt;
&lt;li&gt;内核&lt;/li&gt;
&lt;li&gt;GCC版本&lt;/li&gt;
&lt;li&gt;进程&lt;/li&gt;
&lt;li&gt;内存占用&lt;/li&gt;
&lt;li&gt;和其他有用的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;安装方法&lt;/h3&gt;
&lt;p&gt;Inxi在多数现代GNU/Linux操作系统的默认软件仓库中。所以我们可以简单地运行下列命令安装。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在基于Debian的发行版：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;在Fedora：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;在基于RHEL的发行版：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装EPEL软件仓库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install epel-release
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后使用如下命令安装inxi：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;使用方法&lt;/h3&gt;
&lt;p&gt;在终端运行如下命令可以获取系统的概况信息 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;我们已经展示了一些不同的&lt;a href="https://linux.cn/article-1947-1.html"&gt;应用程序&lt;/a&gt;和方法来获取Linux的系统和硬件信息。在这一系列里，我们将看到如何使用&lt;strong&gt;inxi&lt;/strong&gt;来获取这些详情信息。在论坛技术支持中，它可以作为调试工具，迅速确定用户的系统配置和硬件信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Inxi&lt;/strong&gt;是一个可以获取完整的系统和硬件详情信息的命令行工具，内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件&lt;/li&gt;
&lt;li&gt;CPU&lt;/li&gt;
&lt;li&gt;磁盘驱动器&lt;/li&gt;
&lt;li&gt;Xorg&lt;/li&gt;
&lt;li&gt;桌面环境&lt;/li&gt;
&lt;li&gt;内核&lt;/li&gt;
&lt;li&gt;GCC版本&lt;/li&gt;
&lt;li&gt;进程&lt;/li&gt;
&lt;li&gt;内存占用&lt;/li&gt;
&lt;li&gt;和其他有用的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;安装方法&lt;/h3&gt;
&lt;p&gt;Inxi在多数现代GNU/Linux操作系统的默认软件仓库中。所以我们可以简单地运行下列命令安装。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在基于Debian的发行版：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;在Fedora：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;在基于RHEL的发行版：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装EPEL软件仓库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install epel-release
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后使用如下命令安装inxi：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;使用方法&lt;/h3&gt;
&lt;p&gt;在终端运行如下命令可以获取系统的概况信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;CPU~Dual core Intel Core i3-2350M CPU (-HT-MCP-) clocked at Min:800.000Mhz Max:1200.000Mhz Kernel~3.13.0-45-generic x86_64 Up~6:41 Mem~1537.7/3861.3MB HDD~500.1GB(52.5% used) Procs~183 Client~Shell inxi~1.9.17
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，我们可以获取一个特定硬件的详情信息。比如获取&lt;strong&gt;声音/音频硬件详情信息&lt;/strong&gt;，可以运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -A
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Audio&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;     &lt;span class="n"&gt;Card&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;Series&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;C200&lt;/span&gt; &lt;span class="n"&gt;Series&lt;/span&gt; &lt;span class="n"&gt;Family&lt;/span&gt; &lt;span class="n"&gt;High&lt;/span&gt; &lt;span class="n"&gt;Definition&lt;/span&gt; &lt;span class="n"&gt;Audio&lt;/span&gt; &lt;span class="n"&gt;Controller&lt;/span&gt; &lt;span class="n"&gt;driver&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;snd_hda_intel&lt;/span&gt; 
           &lt;span class="n"&gt;Sound&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Advanced&lt;/span&gt; &lt;span class="n"&gt;Linux&lt;/span&gt; &lt;span class="n"&gt;Sound&lt;/span&gt; &lt;span class="n"&gt;Architecture&lt;/span&gt; &lt;span class="n"&gt;ver&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;k3&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="mf"&gt;13.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;generic&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;很酷是吧？&lt;/p&gt;
&lt;p&gt;同样的，你可以获取&lt;strong&gt;显卡&lt;/strong&gt;的详情信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -G
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;Graphics&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="nl"&gt;Card&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt; &lt;span class="n"&gt;Generation&lt;/span&gt; &lt;span class="n"&gt;Core&lt;/span&gt; &lt;span class="n"&gt;Processor&lt;/span&gt; &lt;span class="n"&gt;Family&lt;/span&gt; &lt;span class="n"&gt;Integrated&lt;/span&gt; &lt;span class="n"&gt;Graphics&lt;/span&gt; &lt;span class="n"&gt;Controller&lt;/span&gt; 
           &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nl"&gt;Org&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;1.15.1&lt;/span&gt; &lt;span class="nl"&gt;drivers&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;intel&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;unloaded&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fbdev&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;vesa&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;Resolution&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1366&lt;/span&gt;&lt;span class="n"&gt;x768&lt;/span&gt;&lt;span class="mf"&gt;@60.0&lt;/span&gt;&lt;span class="n"&gt;hz&lt;/span&gt; 
           &lt;span class="n"&gt;GLX&lt;/span&gt; &lt;span class="nl"&gt;Renderer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="n"&gt;DRI&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="n"&gt;Sandybridge&lt;/span&gt; &lt;span class="n"&gt;Mobile&lt;/span&gt; &lt;span class="n"&gt;GLX&lt;/span&gt; &lt;span class="nl"&gt;Version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;3.0&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="mf"&gt;10.3.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;硬盘信息呢？也是可以的。运行如下命令来获取完整的&lt;strong&gt;硬盘&lt;/strong&gt;信息。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -D
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Drives&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;HDD&lt;/span&gt; &lt;span class="n"&gt;Total&lt;/span&gt; &lt;span class="n"&gt;Size&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;500.1&lt;/span&gt;&lt;span class="n"&gt;GB&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;52.5&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="sr"&gt;/dev/s&lt;/span&gt;&lt;span class="n"&gt;da&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ST9601325BD&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;500.1&lt;/span&gt;&lt;span class="n"&gt;GB&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;显示Bios和主板详情信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -M
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Machine&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Dell&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;portable&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="n"&gt;product&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Inspiron&lt;/span&gt; &lt;span class="n"&gt;N5050&lt;/span&gt;
           &lt;span class="n"&gt;Mobo&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Dell&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;01&lt;/span&gt;&lt;span class="n"&gt;HXXJ&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A05&lt;/span&gt; &lt;span class="n"&gt;Bios&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Dell&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A05&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;&lt;span class="sr"&gt;/03/&lt;/span&gt;&lt;span class="mi"&gt;2012&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不仅是硬性详情信息，它也可以显示我们系统中的&lt;strong&gt;可用软件仓库列表&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -r
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;Repos:&lt;/span&gt;     &lt;span class="err"&gt;Active&lt;/span&gt; &lt;span class="err"&gt;apt&lt;/span&gt; &lt;span class="err"&gt;sources&lt;/span&gt; &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;file:&lt;/span&gt; &lt;span class="err"&gt;/etc/apt/sources.list&lt;/span&gt;
           &lt;span class="err"&gt;deb&lt;/span&gt; &lt;span class="err"&gt;http://ubuntu.excellmedia.net/archive/&lt;/span&gt; &lt;span class="err"&gt;trusty&lt;/span&gt; &lt;span class="err"&gt;main&lt;/span&gt; &lt;span class="err"&gt;restricted&lt;/span&gt;
           &lt;span class="err"&gt;deb-src&lt;/span&gt; &lt;span class="err"&gt;http://ubuntu.excellmedia.net/archive/&lt;/span&gt; &lt;span class="err"&gt;trusty&lt;/span&gt; &lt;span class="err"&gt;main&lt;/span&gt; &lt;span class="err"&gt;restricted&lt;/span&gt;
           &lt;span class="err"&gt;deb&lt;/span&gt; &lt;span class="err"&gt;http://ubuntu.excellmedia.net/archive/&lt;/span&gt; &lt;span class="err"&gt;trusty-updates&lt;/span&gt; &lt;span class="err"&gt;main&lt;/span&gt; &lt;span class="err"&gt;restricted&lt;/span&gt;
           &lt;span class="err"&gt;deb-src&lt;/span&gt; &lt;span class="err"&gt;http://ubuntu.excellmedia.net/archive/&lt;/span&gt; &lt;span class="err"&gt;trusty-updates&lt;/span&gt; &lt;span class="err"&gt;main&lt;/span&gt; &lt;span class="err"&gt;restricted&lt;/span&gt;
           &lt;span class="err"&gt;deb&lt;/span&gt; &lt;span class="err"&gt;http://ubuntu.excellmedia.net/archive/&lt;/span&gt; &lt;span class="err"&gt;trusty&lt;/span&gt; &lt;span class="err"&gt;universe&lt;/span&gt;
           &lt;span class="err"&gt;.&lt;/span&gt;
           &lt;span class="err"&gt;.&lt;/span&gt;
           &lt;span class="err"&gt;Active&lt;/span&gt; &lt;span class="err"&gt;apt&lt;/span&gt; &lt;span class="err"&gt;sources&lt;/span&gt; &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;file:&lt;/span&gt; &lt;span class="err"&gt;/etc/apt/sources.list.d/intellinuxgraphics.list&lt;/span&gt;
           &lt;span class="err"&gt;deb&lt;/span&gt; &lt;span class="err"&gt;https://download.01.org/gfx/ubuntu/14.04/main&lt;/span&gt; &lt;span class="err"&gt;trusty&lt;/span&gt; &lt;span class="err"&gt;main&lt;/span&gt; &lt;span class="c"&gt;#Intel Graphics drivers&lt;/span&gt;
           &lt;span class="err"&gt;Active&lt;/span&gt; &lt;span class="err"&gt;apt&lt;/span&gt; &lt;span class="err"&gt;sources&lt;/span&gt; &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;file:&lt;/span&gt; &lt;span class="err"&gt;/etc/apt/sources.list.d/linrunner-tlp-trusty.list&lt;/span&gt;
           &lt;span class="err"&gt;Active&lt;/span&gt; &lt;span class="err"&gt;apt&lt;/span&gt; &lt;span class="err"&gt;sources&lt;/span&gt; &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;file:&lt;/span&gt; &lt;span class="err"&gt;/etc/apt/sources.list.d/wseverin-ppa-trusty.list&lt;/span&gt;
           &lt;span class="err"&gt;deb&lt;/span&gt; &lt;span class="err"&gt;http://ppa.launchpad.net/wseverin/ppa/ubuntu&lt;/span&gt; &lt;span class="err"&gt;trusty&lt;/span&gt; &lt;span class="err"&gt;main&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Inxi还可以显示你所在位置的天气信息。感到意外吗？是的，它可以。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -W Erode,Tamilnadu
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里&lt;strong&gt;Erode&lt;/strong&gt;是地区，&lt;strong&gt;Tamilnadu&lt;/strong&gt;是印度的一个邦。&lt;/p&gt;
&lt;p&gt;示例输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Weather&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;Conditions&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;79&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Clear&lt;/span&gt; &lt;span class="n"&gt;Time&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;February&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt; &lt;span class="n"&gt;PM&lt;/span&gt; &lt;span class="n"&gt;IST&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;查看完整的硬件详情信息&lt;/h3&gt;
&lt;p&gt;厌倦了逐一获取每种硬件的信息？你可以使用如下命令将所有信息一次列出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;inxi -F
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;示例输出：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;System&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;    &lt;span class="nl"&gt;Host&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;sk&lt;/span&gt; &lt;span class="nl"&gt;Kernel&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;3.13.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;generic&lt;/span&gt; &lt;span class="n"&gt;x86_64&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt; &lt;span class="n"&gt;bit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;Desktop&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;LXDE&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Openbox&lt;/span&gt; &lt;span class="mf"&gt;3.5.2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;Distro&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Ubuntu&lt;/span&gt; &lt;span class="mf"&gt;14.04&lt;/span&gt; &lt;span class="n"&gt;trusty&lt;/span&gt;
&lt;span class="nl"&gt;Machine&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;   &lt;span class="nl"&gt;System&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Dell&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;portable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;product&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Inspiron&lt;/span&gt; &lt;span class="n"&gt;N5050&lt;/span&gt;
           &lt;span class="nl"&gt;Mobo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Dell&lt;/span&gt; &lt;span class="nl"&gt;model&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mo"&gt;01&lt;/span&gt;&lt;span class="n"&gt;HXXJ&lt;/span&gt; &lt;span class="nl"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A05&lt;/span&gt; &lt;span class="nl"&gt;Bios&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Dell&lt;/span&gt; &lt;span class="nl"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A05&lt;/span&gt; &lt;span class="nl"&gt;date&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;08&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mo"&gt;03&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2012&lt;/span&gt;
&lt;span class="nl"&gt;CPU&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;       &lt;span class="n"&gt;Dual&lt;/span&gt; &lt;span class="n"&gt;core&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="n"&gt;Core&lt;/span&gt; &lt;span class="n"&gt;i3&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2350&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="n"&gt;CPU&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;HT&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;MCP&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;cache&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3072&lt;/span&gt; &lt;span class="n"&gt;KB&lt;/span&gt; &lt;span class="nl"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lm&lt;/span&gt; &lt;span class="n"&gt;nx&lt;/span&gt; &lt;span class="n"&gt;sse&lt;/span&gt; &lt;span class="n"&gt;sse2&lt;/span&gt; &lt;span class="n"&gt;sse3&lt;/span&gt; &lt;span class="n"&gt;sse4_1&lt;/span&gt; &lt;span class="n"&gt;sse4_2&lt;/span&gt; &lt;span class="n"&gt;ssse3&lt;/span&gt; &lt;span class="n"&gt;vmx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
           &lt;span class="n"&gt;Clock&lt;/span&gt; &lt;span class="nl"&gt;Speeds&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;800.00&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;1000.00&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;800.00&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;800.00&lt;/span&gt; &lt;span class="n"&gt;MHz&lt;/span&gt;
&lt;span class="nl"&gt;Graphics&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="nl"&gt;Card&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;nd&lt;/span&gt; &lt;span class="n"&gt;Generation&lt;/span&gt; &lt;span class="n"&gt;Core&lt;/span&gt; &lt;span class="n"&gt;Processor&lt;/span&gt; &lt;span class="n"&gt;Family&lt;/span&gt; &lt;span class="n"&gt;Integrated&lt;/span&gt; &lt;span class="n"&gt;Graphics&lt;/span&gt; &lt;span class="n"&gt;Controller&lt;/span&gt; 
           &lt;span class="n"&gt;X&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nl"&gt;Org&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;1.15.1&lt;/span&gt; &lt;span class="nl"&gt;drivers&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;intel&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;unloaded&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fbdev&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;vesa&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;Resolution&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1366&lt;/span&gt;&lt;span class="n"&gt;x768&lt;/span&gt;&lt;span class="mf"&gt;@60.0&lt;/span&gt;&lt;span class="n"&gt;hz&lt;/span&gt; 
           &lt;span class="n"&gt;GLX&lt;/span&gt; &lt;span class="nl"&gt;Renderer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="n"&gt;DRI&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="n"&gt;Sandybridge&lt;/span&gt; &lt;span class="n"&gt;Mobile&lt;/span&gt; &lt;span class="n"&gt;GLX&lt;/span&gt; &lt;span class="nl"&gt;Version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;3.0&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="mf"&gt;10.3.0&lt;/span&gt;
&lt;span class="nl"&gt;Audio&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;     &lt;span class="nl"&gt;Card&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Intel&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;Series&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;C200&lt;/span&gt; &lt;span class="n"&gt;Series&lt;/span&gt; &lt;span class="n"&gt;Family&lt;/span&gt; &lt;span class="n"&gt;High&lt;/span&gt; &lt;span class="n"&gt;Definition&lt;/span&gt; &lt;span class="n"&gt;Audio&lt;/span&gt; &lt;span class="n"&gt;Controller&lt;/span&gt; &lt;span class="nl"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;snd_hda_intel&lt;/span&gt; 
           &lt;span class="nl"&gt;Sound&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Advanced&lt;/span&gt; &lt;span class="n"&gt;Linux&lt;/span&gt; &lt;span class="n"&gt;Sound&lt;/span&gt; &lt;span class="n"&gt;Architecture&lt;/span&gt; &lt;span class="nl"&gt;ver&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;k3&lt;/span&gt;&lt;span class="mf"&gt;.13.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;45&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;generic&lt;/span&gt;
&lt;span class="nl"&gt;Network&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;Card&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Qualcomm&lt;/span&gt; &lt;span class="n"&gt;Atheros&lt;/span&gt; &lt;span class="n"&gt;AR9285&lt;/span&gt; &lt;span class="n"&gt;Wireless&lt;/span&gt; &lt;span class="n"&gt;Network&lt;/span&gt; &lt;span class="n"&gt;Adapter&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PCI&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Express&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ath9k&lt;/span&gt; 
           &lt;span class="nl"&gt;IF&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;wlan0&lt;/span&gt; &lt;span class="nl"&gt;state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;up&lt;/span&gt; &lt;span class="nl"&gt;mac&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
           &lt;span class="n"&gt;Card&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Realtek&lt;/span&gt; &lt;span class="n"&gt;RTL8101E&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;RTL8102E&lt;/span&gt; &lt;span class="n"&gt;PCI&lt;/span&gt; &lt;span class="n"&gt;Express&lt;/span&gt; &lt;span class="n"&gt;Fast&lt;/span&gt; &lt;span class="n"&gt;Ethernet&lt;/span&gt; &lt;span class="n"&gt;controller&lt;/span&gt; &lt;span class="nl"&gt;driver&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;r8169&lt;/span&gt; 
           &lt;span class="nl"&gt;IF&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;eth0&lt;/span&gt; &lt;span class="nl"&gt;state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;down&lt;/span&gt; &lt;span class="nl"&gt;mac&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
&lt;span class="nl"&gt;Drives&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;HDD&lt;/span&gt; &lt;span class="n"&gt;Total&lt;/span&gt; &lt;span class="nl"&gt;Size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;500.1&lt;/span&gt;&lt;span class="n"&gt;GB&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;52.5&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sda&lt;/span&gt; &lt;span class="nl"&gt;model&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ST9500325AS&lt;/span&gt; &lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;500.1&lt;/span&gt;&lt;span class="n"&gt;GB&lt;/span&gt; 
&lt;span class="nl"&gt;Partition&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;ID&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;455&lt;/span&gt;&lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="nl"&gt;used&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;245&lt;/span&gt;&lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;57&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ext4&lt;/span&gt; &lt;span class="nl"&gt;ID&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;boot&lt;/span&gt; &lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;236&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="nl"&gt;used&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;159&lt;/span&gt;&lt;span class="n"&gt;M&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;72&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;ext2&lt;/span&gt; 
           &lt;span class="nl"&gt;ID&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nl"&gt;size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;4.19&lt;/span&gt;&lt;span class="n"&gt;GB&lt;/span&gt; &lt;span class="nl"&gt;used&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.00&lt;/span&gt;&lt;span class="n"&gt;GB&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;swap&lt;/span&gt; 
&lt;span class="nl"&gt;RAID&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;      &lt;span class="n"&gt;No&lt;/span&gt; &lt;span class="n"&gt;RAID&lt;/span&gt; &lt;span class="n"&gt;devices&lt;/span&gt; &lt;span class="n"&gt;detected&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;proc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;mdstat&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;md_mod&lt;/span&gt; &lt;span class="n"&gt;kernel&lt;/span&gt; &lt;span class="n"&gt;raid&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="n"&gt;present&lt;/span&gt;
&lt;span class="nl"&gt;Sensors&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;   &lt;span class="n"&gt;System&lt;/span&gt; &lt;span class="nl"&gt;Temperatures&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;64.5&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="nl"&gt;mobo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; 
           &lt;span class="n"&gt;Fan&lt;/span&gt; &lt;span class="n"&gt;Speeds&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;rpm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nl"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; 
&lt;span class="nl"&gt;Info&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;      &lt;span class="nl"&gt;Processes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;186&lt;/span&gt; &lt;span class="nl"&gt;Uptime&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;52&lt;/span&gt; &lt;span class="nl"&gt;Memory&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;1547.2&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;3861.3&lt;/span&gt;&lt;span class="n"&gt;MB&lt;/span&gt; &lt;span class="nl"&gt;Client&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Shell&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bash&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;inxi&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;1.9.17&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就像上面你看到的那样，inxi显示出了完整的硬件详情信息。&lt;/p&gt;
&lt;p&gt;更多的细节可以参考man手册。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;man inxi
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;结论&lt;/h3&gt;
&lt;p&gt;你在寻找一个可以显示完整的系统和硬件详情信息的简单工具吗？那么不用再找了，inxi会提供你所需要的。并且，它还是在你系统默认的软件仓库中的轻量级工具。你还想要更多东西吗？试一试它，你不会失望。&lt;/p&gt;
&lt;p&gt;欢呼吧！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://www.unixmen.com/inxi-find-system-hardware-information-linux/&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://www.unixmen.com/author/sk/"&gt;SK&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] Linux 用户的 3 个命令行小技巧</title><link href="/yi-linux-yong-hu-de-3-ge-ming-ling-xing-xiao-ji-qiao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-linux-yong-hu-de-3-ge-ming-ling-xing-xiao-ji-qiao.html</id><summary type="html">&lt;p&gt;Linux世界充满了乐趣，我们越深入进去，就会发现越多有趣的事物。我们会努力给你提供一些小技巧，让你和其他人有所不同，下面就是我们准备的3个小技巧。&lt;/p&gt;
&lt;h3&gt;1. 如何在不使用Cron的情况调度Linux下的任务&lt;/h3&gt;
&lt;p&gt;在Linux下，调度一个任务/命令称之为Cron。当我们需要调度一个任务时，我们会使用Cron，但你知道我们在不使用Cron的情况也可以调度一个在将来时间运行的任务吗？你可以按照如下建议操作……&lt;/p&gt;
&lt;p&gt;每5秒钟运行一个命令（date）然后将结果写入到一个文件（data.txt）。为了实现这一点，我们可以直接在命令提示符运行如下单行脚本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="k"&gt;while&lt;/span&gt; true&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; date &amp;gt;&amp;gt; date.txt &lt;span class="p"&gt;;&lt;/span&gt; sleep &lt;span class="m"&gt;5&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述脚本的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while true&lt;/code&gt; ：让脚本进入一个条件总为真的循环中，也就是制造一个死循环，将里边的命令一遍遍地重复运行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;do&lt;/code&gt; ：&lt;code&gt;do&lt;/code&gt;是&lt;code&gt;while&lt;/code&gt;语句中的关键字，它之后的命令会被执行，在它后边可以放置一个或一系列命令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;date &amp;gt;&amp;gt; date.txt&lt;/code&gt; ：运行date命令，并将其输出写入到data.txt文件中 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;Linux世界充满了乐趣，我们越深入进去，就会发现越多有趣的事物。我们会努力给你提供一些小技巧，让你和其他人有所不同，下面就是我们准备的3个小技巧。&lt;/p&gt;
&lt;h3&gt;1. 如何在不使用Cron的情况调度Linux下的任务&lt;/h3&gt;
&lt;p&gt;在Linux下，调度一个任务/命令称之为Cron。当我们需要调度一个任务时，我们会使用Cron，但你知道我们在不使用Cron的情况也可以调度一个在将来时间运行的任务吗？你可以按照如下建议操作……&lt;/p&gt;
&lt;p&gt;每5秒钟运行一个命令（date）然后将结果写入到一个文件（data.txt）。为了实现这一点，我们可以直接在命令提示符运行如下单行脚本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="k"&gt;while&lt;/span&gt; true&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; date &amp;gt;&amp;gt; date.txt &lt;span class="p"&gt;;&lt;/span&gt; sleep &lt;span class="m"&gt;5&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述脚本的解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while true&lt;/code&gt; ：让脚本进入一个条件总为真的循环中，也就是制造一个死循环，将里边的命令一遍遍地重复运行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;do&lt;/code&gt; ：&lt;code&gt;do&lt;/code&gt;是&lt;code&gt;while&lt;/code&gt;语句中的关键字，它之后的命令会被执行，在它后边可以放置一个或一系列命令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;date &amp;gt;&amp;gt; date.txt&lt;/code&gt; ：运行date命令，并将其输出写入到data.txt文件中。注意我们使用&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;，而不是&lt;code&gt;&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ：对文件（date.txt）进行追加写的操作，这样每次运行命令后，输出内容会被追加到文件中。如果使用&lt;code&gt;&amp;gt;&lt;/code&gt;的话，则会一遍遍地覆盖之前的内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sleep 5&lt;/code&gt; ：让脚本处于5秒睡眠状态，然后再运行之后的命令。注意这里的时间单位只能用秒。也就是说如果你想让命令每6分钟运行一次，你应该使用&lt;code&gt;sleep 360&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;done&lt;/code&gt; ：&lt;code&gt;while&lt;/code&gt;循环语句块结束的标记。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; ：将整个进程放到后台运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类似地，我们可以这样运行任何脚本。下边的例子是每100秒运行一个名为&lt;code&gt;script_name.sh&lt;/code&gt;的脚本。&lt;/p&gt;
&lt;p&gt;另外值得一提的是上面提到的脚本文件必须处于当前目录中，否则需要使用完整路径（&lt;code&gt;/home/$USER/…/script_name.sh&lt;/code&gt;）。实现如上功能的单行脚本如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="k"&gt;while&lt;/span&gt; true&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; /bin/sh script_name.sh &lt;span class="p"&gt;;&lt;/span&gt; sleep &lt;span class="m"&gt;100&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;done&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：上述的单行脚本并不是Cron的替代品，因为Cron工具支持众多选项，更加灵活，可定制性也更高。然而如果我们想运行某些测试，比如I/O评测，上述的单行脚本也管用。&lt;/p&gt;
&lt;p&gt;还可以参考：&lt;a href="http://www.tecmint.com/11-cron-scheduling-task-examples-in-linux/"&gt;Linux 下 11 个定时调度任务例子&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2. 如何不使用clear命令清空终端的内容&lt;/h3&gt;
&lt;p&gt;你如何清空终端的内容？你可能会认为这是一个傻问题。好吧，大家都清楚可以使用&lt;code&gt;clear&lt;/code&gt;命令。如果养成使用&lt;code&gt;ctrl + l&lt;/code&gt;快捷键的习惯，我们会节省大量时间。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ctrl + l&lt;/code&gt;快捷键的效果和&lt;code&gt;clear&lt;/code&gt;命令一样。所以下一次你就可以使用&lt;code&gt;ctrl + l&lt;/code&gt;来清空终端的内容了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：因为&lt;code&gt;ctrl + l&lt;/code&gt;是一个快捷键，我们不可以在脚本中使用。所以如果我们需要在脚本中清空屏幕内容，还是需要使用&lt;code&gt;clear&lt;/code&gt;命令。但我能想到的所有其他情况，&lt;code&gt;ctrl + l&lt;/code&gt;都更加有效。&lt;/p&gt;
&lt;h3&gt;3. 在其它目录运行一个命令，然后自动返回当前工作目录&lt;/h3&gt;
&lt;p&gt;这是一个很多人可能不知道的令人吃惊的技巧。你可能想在其它目录运行任何一个命令，然后再回到当前目录。要实现这样的目的，你只需要将命令放在一个圆括号里。&lt;/p&gt;
&lt;p&gt;我们来看一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;avi@deb:~$ (cd /home/avi/Downloads/)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; avi@deb:~
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;它首先会cd到Downloads目录，然后又回到了之前的家目录。也许你认为里边的命令根本没有执行，或者是出了某种错误，因为从命令提示符看不出任何变化。让我们简单修改一下这个命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;avi@deb:~$ (cd /home/avi/Downloads/ &amp;amp;&amp;amp; ls -l)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;-rw-r-----  1 avi  avi     54272 May  3 18:37 text1.txt
-rw-r-----  1 avi  avi     54272 May  3 18:37 text2.txt
-rw-r-----  1 avi  avi     54272 May  3 18:37 text3.txt
avi@deb:~$
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在上述命令中，它首先进入Downloads目录，然后列出文件内容，最后又回到了当前目录。并且它证明了命令成功执行了。你可以在括号中包含任何命令，执行完都会顺利返回到当前目录。&lt;/p&gt;
&lt;p&gt;这就是全部内容了，如果你知道任何类似的Linux技巧，你可以在文章下面的评论框中分享给我们，不要忘记将本文和朋友分享 :)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://www.tecmint.com/useful-linux-hacks-commands/&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://www.tecmint.com/author/avishek/"&gt;Avishek Kumar&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="https://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 如何使用 Monit 部署服务器监控系统</title><link href="/yi-ru-he-shi-yong-monit-bu-shu-fu-wu-qi-jian-kong-xi-tong.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-ru-he-shi-yong-monit-bu-shu-fu-wu-qi-jian-kong-xi-tong.html</id><summary type="html">&lt;p&gt;很多Linux系统管理员依赖一个集中式的远程监控系统（比如&lt;a href="http://xmodulo.com/monitor-common-services-nagios.html"&gt;Nagios&lt;/a&gt;或者&lt;a href="http://xmodulo.com/monitor-linux-servers-snmp-cacti.html"&gt;Cacti&lt;/a&gt;）来检查他们网络基础设备的健康状况。虽然集中式监控让管理员的生活更简单了，然而处理很多机器和服务时，专用的监控中心显然成为了一个单点故障，如果监控中心挂了或者因为什么原因（比如硬件或者网络故障）不可访问了，你就会失去整个网络基础设备情况的任何信息。&lt;/p&gt;
&lt;p&gt;一个给你的监控系统增加冗余度的方法是安装独立的监控软件（作为后备），至少在网络中的关键/核心服务器上。这样在集中式监控系统挂掉的情况，你还有能力通过后备的监控方式来获取核心服务器的运行状况。&lt;/p&gt;
&lt;h3&gt;Monit是什么？&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://mmonit.com/monit/"&gt;Monit&lt;/a&gt;是一个跨平台的用来监控Unix/linux系统（比如Linux、BSD、OSX、Solaris）的工具。Monit特别易于安装，而且非常轻量级（只有500KB大小），并且不依赖任何第三方程序、插件或者库。然而，Monit可以胜任全面监控、进程状态监控、文件系统变动监控、邮件通知和对核心服务的自定义动作等场景。易于安装、轻量级的实现以及强大的功能，让Monit成为一个理想的后备监控工具。&lt;/p&gt;
&lt;p&gt;我已经在一些机器使用Monit几年了，而且我对它的可靠性非常满意。甚至作为全面的监控系统，对任何Linux系统管理员来说Monit也是非常有用和强大的。在这篇教程中，我会展示如何在一个本地服务器部署Monit（作为后备监控系统）来监控常见的服务。在部署过程中 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;很多Linux系统管理员依赖一个集中式的远程监控系统（比如&lt;a href="http://xmodulo.com/monitor-common-services-nagios.html"&gt;Nagios&lt;/a&gt;或者&lt;a href="http://xmodulo.com/monitor-linux-servers-snmp-cacti.html"&gt;Cacti&lt;/a&gt;）来检查他们网络基础设备的健康状况。虽然集中式监控让管理员的生活更简单了，然而处理很多机器和服务时，专用的监控中心显然成为了一个单点故障，如果监控中心挂了或者因为什么原因（比如硬件或者网络故障）不可访问了，你就会失去整个网络基础设备情况的任何信息。&lt;/p&gt;
&lt;p&gt;一个给你的监控系统增加冗余度的方法是安装独立的监控软件（作为后备），至少在网络中的关键/核心服务器上。这样在集中式监控系统挂掉的情况，你还有能力通过后备的监控方式来获取核心服务器的运行状况。&lt;/p&gt;
&lt;h3&gt;Monit是什么？&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://mmonit.com/monit/"&gt;Monit&lt;/a&gt;是一个跨平台的用来监控Unix/linux系统（比如Linux、BSD、OSX、Solaris）的工具。Monit特别易于安装，而且非常轻量级（只有500KB大小），并且不依赖任何第三方程序、插件或者库。然而，Monit可以胜任全面监控、进程状态监控、文件系统变动监控、邮件通知和对核心服务的自定义动作等场景。易于安装、轻量级的实现以及强大的功能，让Monit成为一个理想的后备监控工具。&lt;/p&gt;
&lt;p&gt;我已经在一些机器使用Monit几年了，而且我对它的可靠性非常满意。甚至作为全面的监控系统，对任何Linux系统管理员来说Monit也是非常有用和强大的。在这篇教程中，我会展示如何在一个本地服务器部署Monit（作为后备监控系统）来监控常见的服务。在部署过程中，我只会展示我们用到的部分。&lt;/p&gt;
&lt;h3&gt;在Linux安装Monit&lt;/h3&gt;
&lt;p&gt;Monit已经被包含在多数Linux发行版的软件仓库中了。&lt;/p&gt;
&lt;p&gt;Debian、Ubuntu或者Linux Mint：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo aptitude install monit
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Fedora或者CentOS/RHEL：&lt;/p&gt;
&lt;p&gt;在CentOS/RHEL中，你必须首先启用&lt;a href="https://linux.cn/article-2324-1.html"&gt;EPEL&lt;/a&gt;或者&lt;a href="http://xmodulo.com/how-to-set-up-rpmforge-repoforge-repository-on-centos.html"&gt;Repoforge&lt;/a&gt;软件仓库.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# yum install monit
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Monit自带一个文档完善的配置文件，其中包含了很多例子。主配置文件在/etc/monit.conf（Fedora/CentOS/RHEL 中），或者/etc/monit/monitrc（Debian/Ubuntu/Mint 中）。Monit配置文件有两部分：“Global”（全局）和“Services”（服务）。&lt;/p&gt;
&lt;h3&gt;Global Configuration: Web Status Page （全局配置：Web状态页面）&lt;/h3&gt;
&lt;p&gt;Monit可以使用邮件服务来发送通知，也可以使用HTTP/HTTPS页面来展示。我们先使用如下配置的web状态页面吧：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Monit监听1966端口。&lt;/li&gt;
&lt;li&gt;对web状态页面的访问是通过SSL加密的。&lt;/li&gt;
&lt;li&gt;使用monituser/romania作为用户名/口令登录。&lt;/li&gt;
&lt;li&gt;只允许通过localhost、myhost.mydomain.ro和在局域网内部（192.168.0.0/16）访问。&lt;/li&gt;
&lt;li&gt;Monit使用pem格式的SSL证书。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后的步骤，我会使用一个基于Red Hat的系统。在基于Debian的系统中的步骤也是类似的。&lt;/p&gt;
&lt;p&gt;首先，在/var/cert生成一个自签名的证书（monit.pem）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# mkdir /var/certs
# cd /etc/pki/tls/certs
# ./make-dummy-cert monit.pem
# cp monit.pem /var/certs
# chmod 0400 /var/certs/monit.pem
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在将下列代码片段放到Monit的主配置文件中。你可以创建一个空配置文件，或者基于自带的配置文件修改。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set httpd port 1966 and
     SSL ENABLE
     PEMFILE  /var/certs/monit.pem
     allow monituser:romania
     allow localhost
     allow 192.168.0.0/16
     allow myhost.mydomain.ro
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Global Configuration: Email Notification （全局配置：邮件通知）&lt;/h3&gt;
&lt;p&gt;然后，我们来设置Monit的邮件通知。我们至少需要一个可用的&lt;a href="http://xmodulo.com/mail-server-ubuntu-debian.html"&gt;SMTP服务器&lt;/a&gt;来让Monit发送邮件。这样就可以（按照你的实际情况修改）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邮件服务器的机器名：smtp.monit.ro&lt;/li&gt;
&lt;li&gt;Monit使用的发件人：monit@monit.ro&lt;/li&gt;
&lt;li&gt;邮件的收件人：guletz@monit.ro&lt;/li&gt;
&lt;li&gt;邮件服务器使用的SMTP端口：587（默认是25）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了以上信息，邮件通知就可以这样配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set mailserver  smtp.monit.ro port 587
set mail-format {
 from: monit@monit.ro
 subject: $SERVICE $EVENT at $DATE on $HOST
 message: Monit $ACTION $SERVICE $EVENT at $DATE on $HOST : $DESCRIPTION.

       Yours sincerely,
          Monit

  }

set alert guletz@monit.ro
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就像你看到的，Monit会提供几个内部变量（&lt;code&gt;$DATE&lt;/code&gt;、&lt;code&gt;$EVENT&lt;/code&gt;、&lt;code&gt;$HOST&lt;/code&gt;等），你可以按照你的需求自定义邮件内容。如果你想要从Monit所在机器发送邮件，就需要一个已经安装的与sendmail兼容的程序（如postfix或者ssmtp）。&lt;/p&gt;
&lt;h3&gt;Global Configuration: Monit Daemon （全局配置：Monit守护进程）&lt;/h3&gt;
&lt;p&gt;接下来就该配置Monit守护进程了。可以将其设置成这样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在120秒后进行第一次检测。&lt;/li&gt;
&lt;li&gt;每3分钟检测一次服务。&lt;/li&gt;
&lt;li&gt;使用syslog来记录日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下代码段可以满足上述需求。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set daemon 120
   with start delay 240
set logfile syslog facility log_daemon
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们必须定义“idfile”，Monit守护进程的一个独一无二的ID文件；以及“eventqueue”，当monit的邮件因为SMTP或者网络故障发不出去，邮件会暂存在这里；以及确保/var/monit路径是存在的。然后使用下边的配置就可以了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set idfile /var/monit/id
set eventqueue
     basedir /var/monit
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;测试全局配置&lt;/h3&gt;
&lt;p&gt;现在“Global”部分就完成了。Monit配置文件看起来像这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;#  Global Section

# status webpage and acl&amp;#39;s
set httpd port 1966 and
     SSL ENABLE
     PEMFILE  /var/certs/monit.pem
     allow monituser:romania
     allow localhost
     allow 192.168.0.0/16
     allow myhost.mydomain.ro

# mail-server
set mailserver  smtp.monit.ro port 587
# email-format
set mail-format {
 from: monit@monit.ro
 subject: $SERVICE $EVENT at $DATE on $HOST
 message: Monit $ACTION $SERVICE $EVENT at $DATE on $HOST : $DESCRIPTION.

       Yours sincerely,
          Monit

  }

set alert guletz@monit.ro

# delay checks
set daemon 120
   with start delay 240
set logfile syslog facility log_daemon

# idfile and mail queue path
set idfile /var/monit/id
 set eventqueue
     basedir /var/monit
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在是时候验证我们的工作了，你可以通过运行如下命令来验证存在的配置文件（/etc/monit.conf）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# monit -t

Control file syntax OK
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果monit提示任何错误，请再检查下配置文件。幸运的是，错误/警告信息是可以帮助你发现问题的，比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;monit&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Cannot&lt;/span&gt; &lt;span class="n"&gt;stat&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;SSL&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="n"&gt;PEM&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/var/certs/monit.pem&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;No&lt;/span&gt; &lt;span class="n"&gt;such&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;directory&lt;/span&gt;
&lt;span class="sr"&gt;/etc/monit/&lt;/span&gt;&lt;span class="n"&gt;monitrc&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Warning&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;hostname&lt;/span&gt; &lt;span class="n"&gt;did&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;resolve&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;smtp.monit.ro&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一旦你确认配置文件没问题了，可以启动monit守护进程，然后等2到3分钟：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# service monit start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你使用的是systemd，运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# systemctl start monit
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在打开一个浏览器窗口，然后访问&lt;code&gt;https://&amp;lt;monit_host&amp;gt;:1966&lt;/code&gt;。将&lt;code&gt;&amp;lt;monit_host&amp;gt;&lt;/code&gt;替换成Monit所在机器的机器名或者IP地址。&lt;/p&gt;
&lt;p&gt;如果你使用的是自签名的SSL证书，你会在浏览器中看到一个警告信息。继续访问即可。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="https://farm8.staticflickr.com/7596/16737206479_96b9f7dfdb_c.jpg"&gt;&lt;/p&gt;
&lt;p&gt;你完成登录后，就会看到这个页面。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="https://farm8.staticflickr.com/7594/16303369973_6019482dea_c.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在这个教程的其余部分，我们演示监控一个本地服务器和常见服务的方法。你会在&lt;a href="http://mmonit.com/wiki/Monit/ConfigurationExamples"&gt;官方wiki页面&lt;/a&gt;看到很多有用的例子。其中的多数是可以直接复制粘贴的！&lt;/p&gt;
&lt;h3&gt;Service Configuration: CPU/Memory Monitoring （服务配置：CPU、内存监控）&lt;/h3&gt;
&lt;p&gt;我们先来监控本地服务器的CPU、内存占用。复制如下代码段到配置文件中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;check system localhost
    if loadavg (1min) &amp;gt; 10 then alert
    if loadavg (5min) &amp;gt; 6 then alert
    if memory usage &amp;gt; 75% then alert
    if cpu usage (user) &amp;gt; 70% then alert
    if cpu usage (system) &amp;gt; 60% then alert
    if cpu usage (wait) &amp;gt; 75% then alert
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你可以很容易理解上边的配置。最上边的check是指每个监控周期（全局配置里设置的120秒）都对本机进行下面的操作。如果满足了任何条件，monit守护进程就会使用邮件发送一条报警。&lt;/p&gt;
&lt;p&gt;如果某个监控项不需要每个周期都检查，可以使用如下格式，它会每240秒检查一次平均负载。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if loadavg (1min) &amp;gt; 10 for 2 cycles then alert
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Service Configuration: SSH Service Monitoring （服务配置：SSH服务监控）&lt;/h3&gt;
&lt;p&gt;先检查我们的sshd是否安装在/usr/sbin/sshd：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;check file sshd_bin with path /usr/sbin/sshd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们还想检查sshd的启动脚本是否存在：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;check file sshd_init with path /etc/init.d/sshd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后，我们还想检查sshd守护进程是否存活，并且在监听22端口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;check process sshd with pidfile /var/run/sshd.pid
   start program  &amp;quot;/etc/init.d/sshd start&amp;quot;
   stop program  &amp;quot;/etc/init.d/sshd stop&amp;quot;
   if failed port 22 protocol ssh then restart
   if 5 restarts within 5 cycles then timeout
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以这样解释上述配置：我们检查是否存在名为sshd的进程，并且有一个保存其pid的文件存在（/var/run/sshd.pid）。如果任何一个不存在，我们就使用启动脚本重启sshd。我们检查是否有进程在监听22端口，并且使用的是SSH协议。如果没有，我们还是重启sshd。如果在最近的5个监控周期（5x120秒）至少重启5次了，sshd就被认为是不能用的，我们就不再检查了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="https://farm9.staticflickr.com/8685/16735725998_62c26a24bc_c.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;Service Configuration: SMTP Service Monitoring （服务配置：SMTP服务监控）&lt;/h3&gt;
&lt;p&gt;现在我们来设置一个检查远程SMTP服务器（如192.168.111.102）的监控。假定SMTP服务器运行着SMTP、IMAP、SSH服务。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;check host MAIL with address 192.168.111.102
   if failed icmp type echo within 10 cycles then alert
   if failed port 25  protocol smtp then alert
             else if recovered then exec &amp;quot;/scripts/mail-script&amp;quot;
   if failed port 22  protocol ssh  then alert
   if failed port 143 protocol imap then alert
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们检查远程主机是否响应ICMP协议。如果我们在10个周期内没有收到ICMP回应，就发送一条报警。如果监测到25端口上的SMTP协议是异常的，就发送一条报警。如果在一次监测失败后又监测成功了，就运行一个脚本（/scripts/mail-script）。如果检查22端口上的SSH或者143端口上的IMAP协议不正常，同样发送报警。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;在这个教程，我演示了如何在本地服务器设置Monit，当然这只是Monit功能的冰山一角。你可以花些时间阅读Monit的man手册（写得很好）。Monit可以为任何Linux系统管理员做很多事情，并且具有非常优美和易于理解的语法。如果你将一个集中式的远程监控系统和Monit一同使用，你会得到一个更可靠的监控系统。你感觉Monit怎么样？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://xmodulo.com/server-monitoring-system-monit.html&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://xmodulo.com/author/iulian"&gt;Iulian Murgulet&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 如何在 Linux 下创建一个不可变更的文件</title><link href="/yi-ru-he-zai-linux-xia-chuang-jian-yi-ge-bu-ke-bian-geng-de-wen-jian.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-ru-he-zai-linux-xia-chuang-jian-yi-ge-bu-ke-bian-geng-de-wen-jian.html</id><summary type="html">&lt;p&gt;假如你想对Linux中的一些重要文件做写保护，这样它们就不能被删除或者被篡改成之前的版本或者其他东西，或者在其他情况下，你可能想避免某些配置文件被软件自动修改。使用&lt;code&gt;chown&lt;/code&gt;和&lt;code&gt;chmod&lt;/code&gt;命令修改文件的归属关系或者权限位是处理这种情况的一个解决方法，但这并不完美，因为这样无法避免有root权限的操作。这时&lt;code&gt;chattr&lt;/code&gt;就派上用场了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chattr&lt;/code&gt;是一个可以设置或取消文件的标志位的Linux命令，它和标准的文件权限（读、写、执行）是分离的。与此相关的另一个命令是&lt;code&gt;lsattr&lt;/code&gt;，它可以显示文件的哪些标志位被设置上了。最初只有EXT文件系统（EXT2/3/4）支持&lt;code&gt;chattr&lt;/code&gt;和&lt;code&gt;lsattr&lt;/code&gt;所管理的标志位，但现在很多其他的原生的Linux文件系统都支持了，比如XFS、Btrfs、ReiserFS等等。&lt;/p&gt;
&lt;p&gt;在这个教程中，我会示范如果使用&lt;code&gt;chattr&lt;/code&gt;来让Linux中的文件不可变更。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chattr&lt;/code&gt;和&lt;code&gt;lsattr&lt;/code&gt;命令是e2fsprogs包的一部分，它在所有现代Linux发行版都预装了。&lt;/p&gt;
&lt;p&gt;下面是&lt;code&gt;chattr&lt;/code&gt;的基本语法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ chattr …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;假如你想对Linux中的一些重要文件做写保护，这样它们就不能被删除或者被篡改成之前的版本或者其他东西，或者在其他情况下，你可能想避免某些配置文件被软件自动修改。使用&lt;code&gt;chown&lt;/code&gt;和&lt;code&gt;chmod&lt;/code&gt;命令修改文件的归属关系或者权限位是处理这种情况的一个解决方法，但这并不完美，因为这样无法避免有root权限的操作。这时&lt;code&gt;chattr&lt;/code&gt;就派上用场了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chattr&lt;/code&gt;是一个可以设置或取消文件的标志位的Linux命令，它和标准的文件权限（读、写、执行）是分离的。与此相关的另一个命令是&lt;code&gt;lsattr&lt;/code&gt;，它可以显示文件的哪些标志位被设置上了。最初只有EXT文件系统（EXT2/3/4）支持&lt;code&gt;chattr&lt;/code&gt;和&lt;code&gt;lsattr&lt;/code&gt;所管理的标志位，但现在很多其他的原生的Linux文件系统都支持了，比如XFS、Btrfs、ReiserFS等等。&lt;/p&gt;
&lt;p&gt;在这个教程中，我会示范如果使用&lt;code&gt;chattr&lt;/code&gt;来让Linux中的文件不可变更。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chattr&lt;/code&gt;和&lt;code&gt;lsattr&lt;/code&gt;命令是e2fsprogs包的一部分，它在所有现代Linux发行版都预装了。&lt;/p&gt;
&lt;p&gt;下面是&lt;code&gt;chattr&lt;/code&gt;的基本语法。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ chattr &lt;span class="o"&gt;[&lt;/span&gt;-RVf&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;操作符&lt;span class="o"&gt;][&lt;/span&gt;标志位&lt;span class="o"&gt;]&lt;/span&gt; 文件...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中操作符可以是“+”（把选定的标志位添加到标志位列表）、“-”（从标志位列表中移除选定的标志位）、或者“=”（强制使用选定的标志位）。&lt;/p&gt;
&lt;p&gt;下面是一些可用的标志位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;a&lt;/strong&gt;: 只能以追加模式打开。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A&lt;/strong&gt;: 不能更新atime（文件访问时间）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;c&lt;/strong&gt;: 当被写入磁盘时被自动压缩。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C&lt;/strong&gt;: 关掉“写时复制”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;i&lt;/strong&gt;: 不可变更。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;s&lt;/strong&gt;: 通过自动归零来安全删除。（LCTT 译注：一般情况文件被删后内容不会被修改，改标志位会使得文件被删后原有内容被“0”取代）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;“不可变更”标志位&lt;/h3&gt;
&lt;p&gt;为了让一个文件不可变更，你需要按照如下方法为这个文件添加“不可变更”标志位。例如，对/etc/passwd文件做写保护：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo chattr +i /etc/passwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意设置或取消一个文件的“不可变更”标志位是需要root用户权限的。现在检查该文件“不可变更”标志位是否被添加上了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ lsattr /etc/passwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一旦文件被设置为不可变更，任何用户都将无法修改该文件。即使是root用户也不可以修改、删除、覆盖、移动或者重命名这个文件。如果你想再次修改这个文件，需要先把“不可变更”标志位取消了。&lt;/p&gt;
&lt;p&gt;用如下命令取消“不可变更”标志位：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo chattr -i /etc/passwd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="image" src="https://farm9.staticflickr.com/8613/16152651317_076a65cf50_b.jpg"&gt;&lt;/p&gt;
&lt;p&gt;如果你想让一个目录（比如/etc）连同它下边的所有内容不可变更，使用“-R”选项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo chattr -R +i /etc
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;“只可追加”标志位&lt;/h3&gt;
&lt;p&gt;另一个有用的的标志位是“只可追加”，它只允许文件内容被追加的方式修改。你不能覆盖或者删除一个设置了“只可追加”标志位的文件。这个标志位在你想避免日志文件被意外清理掉的情况很有用。&lt;/p&gt;
&lt;p&gt;和“不可变更”标志位类似，你可以使用如下命令让文件变成“只可追加”模式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo chattr +a /var/log/syslog
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意当你复制一个“不可变更”或者“只可追加”的文件到其他地方后，新文件不会保留这些标志位！&lt;/p&gt;
&lt;h3&gt;结论&lt;/h3&gt;
&lt;p&gt;在这个教程中，我展示了如何使用&lt;code&gt;chattr&lt;/code&gt;和&lt;code&gt;lsattr&lt;/code&gt;命令来管理额外的文件标志位，来避免文件被篡改（意外或者其他情况）的方法。注意你不能将&lt;code&gt;chattr&lt;/code&gt;作为一个安全措施，因为“不可变更”标志位可以很容易被取消掉。解决这个问题的一个可能的方式是限制&lt;code&gt;chattr&lt;/code&gt;命令自身的可用性，或者去掉CAP_LINUX_IMMUTABLE内核权能标志。关于&lt;code&gt;chattr&lt;/code&gt;以及可用的标志位的更多细节，请参考它的man手册。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://xmodulo.com/make-file-immutable-linux.html&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://xmodulo.com/author/nanni"&gt;Dan Nanni&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] 如何在云服务提供商的平台上使用 Docker Machine</title><link href="/yi-ru-he-zai-yun-fu-wu-ti-gong-shang-de-ping-tai-shang-shi-yong-docker-machine.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-ru-he-zai-yun-fu-wu-ti-gong-shang-de-ping-tai-shang-shi-yong-docker-machine.html</id><summary type="html">&lt;p&gt;大家好，今天我们来了解如何使用Docker Machine在各种云服务提供商的平台上部署Docker。Docker Machine是一个可以帮助我们在自己的电脑、云服务提供商的平台以及我们数据中心的机器上创建Docker机器的应用程序。它为创建服务器、在服务器中安装Docker、根据用户需求配置Docker客户端提供了简单的解决方案。驱动API对本地机器、数据中心的虚拟机或者公用云机器都适用。Docker Machine支持Windows、OSX和Linux，并且提供一个独立的二进制文件，可以直接使用。它让我们可以充分利用支持Docker的基础设施的生态环境合作伙伴，并且使用相同的接口进行访问。它让人们可以使用一个命令来简单而迅速地在不同的云平台部署Docker容器。&lt;/p&gt;
&lt;h3&gt;1. 安装Docker Machine&lt;/h3&gt;
&lt;p&gt;Docker Machine可以很好地支持每一种Linux发行版。首先，我们需要从Github网站下载最新版本的。这里我们使用curl来下载目前最新0.2.0版本的Docker Machine。&lt;/p&gt;
&lt;p&gt;在64位操作系统运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# curl -L https://github.com/docker/machine/releases/download/v0.2.0/docker-machine_linux-amd64 &amp;gt; /usr/local/bin/docker-machine
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在32位操作系统运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# curl …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;大家好，今天我们来了解如何使用Docker Machine在各种云服务提供商的平台上部署Docker。Docker Machine是一个可以帮助我们在自己的电脑、云服务提供商的平台以及我们数据中心的机器上创建Docker机器的应用程序。它为创建服务器、在服务器中安装Docker、根据用户需求配置Docker客户端提供了简单的解决方案。驱动API对本地机器、数据中心的虚拟机或者公用云机器都适用。Docker Machine支持Windows、OSX和Linux，并且提供一个独立的二进制文件，可以直接使用。它让我们可以充分利用支持Docker的基础设施的生态环境合作伙伴，并且使用相同的接口进行访问。它让人们可以使用一个命令来简单而迅速地在不同的云平台部署Docker容器。&lt;/p&gt;
&lt;h3&gt;1. 安装Docker Machine&lt;/h3&gt;
&lt;p&gt;Docker Machine可以很好地支持每一种Linux发行版。首先，我们需要从Github网站下载最新版本的。这里我们使用curl来下载目前最新0.2.0版本的Docker Machine。&lt;/p&gt;
&lt;p&gt;在64位操作系统运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# curl -L https://github.com/docker/machine/releases/download/v0.2.0/docker-machine_linux-amd64 &amp;gt; /usr/local/bin/docker-machine
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在32位操作系统运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# curl -L https://github.com/docker/machine/releases/download/v0.2.0/docker-machine_linux-i386 &amp;gt; /usr/local/bin/docker-machine
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下载最新版本的Docker Machine并将docker-machine文件放到了/usr/local/bin/后，添加执行权限：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# chmod +x /usr/local/bin/docker-machine
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;完成如上操作后，我们需要确认已经成功安装docker-machine了。可以运行如下命令检查，它会输出系统中docker-machine的版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine -v
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Installing Docker Machine" src="http://blog.linoxide.com/wp-content/uploads/2015/05/installing-docker-machine.png"&gt;&lt;/p&gt;
&lt;p&gt;要在我们的机器上启用docker命令，需要使用如下命令安装Docker客户端：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    # curl -L https://get.docker.com/builds/linux/x86_64/docker-latest &amp;gt; /usr/local/bin/docker
    # chmod +x /usr/local/bin/docker
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. 创建机器&lt;/h3&gt;
&lt;p&gt;在自己的Linux机器上安装好了Docker Machine之后，我们想要将一个docker虚拟机部署到云服务器上。Docker Machine支持几个流行的云平台，如igital Ocean、Amazon Web Services（AWS）、Microsoft Azure、Google Cloud Computing及其它等等，所以我们可以在不同的平台使用相同的接口来部署Docker。本文中我们会使用digitalocean驱动在Digital Ocean的服务器上部署Docker，--driver选项指定digitalocean驱动，--digitalocean-access-token选项指定&lt;a href="https://cloud.digitalocean.com/settings/applications"&gt;Digital Ocean Control Panel&lt;/a&gt;提供的API Token，命令最后的是我们创建的Docker虚拟机的机器名。运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine create --driver digitalocean --digitalocean-access-token &amp;lt;API-Token&amp;gt; linux-dev

# eval &amp;quot;$(docker-machine env linux-dev)&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Docker Machine Digitalocean Cloud" src="http://blog.linoxide.com/wp-content/uploads/2015/05/docker-machine-digitalocean-cloud.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;： 这里linux-dev是我们将要创建的机器的名称。&lt;code&gt;&amp;lt;API-Token&amp;gt;&lt;/code&gt;是一个安全key，可以在Digtal Ocean Control Panel生成。要找到这个key，我们只需要登录到我们的Digital Ocean Control Panel，然后点击API，再点击 Generate New Token，填写一个名称，选上Read和Write。然后我们就会得到一串十六进制的key，那就是&lt;code&gt;&amp;lt;API-Token&amp;gt;&lt;/code&gt;，简单地替换到上边的命令中即可。&lt;/p&gt;
&lt;p&gt;运行如上命令后，我们可以在Digital Ocean Droplet Panel中看到一个具有默认配置的droplet已经被创建出来了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="DigitalOcean Droplet Panel" src="http://blog.linoxide.com/wp-content/uploads/2015/05/digitalocean-droplet-panel.png"&gt;&lt;/p&gt;
&lt;p&gt;简便起见，docker-machine会使用默认配置来部署Droplet。我们可以通过增加选项来定制我们的Droplet。这里是一些digitalocean相关的选项，我们可以使用它们来覆盖Docker Machine所使用的默认配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;--digitalocean-image "ubuntu-14-04-x64" 用于选择Droplet的镜像&lt;/li&gt;
&lt;li&gt;--digitalocean-ipv6 enable 启用IPv6网络支持&lt;/li&gt;
&lt;li&gt;--digitalocean-private-networking enable 启用专用网络&lt;/li&gt;
&lt;li&gt;--digitalocean-region "nyc3" 选择部署Droplet的区域&lt;/li&gt;
&lt;li&gt;--digitalocean-size "512mb" 选择内存大小和部署的类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你想在其他云服务使用docker-machine，并且想覆盖默认的配置，可以运行如下命令来获取Docker Mackine默认支持的对每种平台适用的参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine create -h
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3. 选择活跃主机&lt;/h3&gt;
&lt;p&gt;部署Droplet后，我们想马上运行一个Docker容器，但在那之前，我们需要检查下活跃主机是否是我们需要的机器。可以运行如下命令查看。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine ls
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Docker Machine List" src="http://blog.linoxide.com/wp-content/uploads/2015/05/docker-machine-ls.png"&gt;&lt;/p&gt;
&lt;p&gt;ACTIVE一列有“*”标记的是活跃主机。&lt;/p&gt;
&lt;p&gt;现在，如果我们想将活跃主机切换到需要的主机，运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine active linux-dev
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里，linux-dev是机器名，我们打算激活这个机器，并且在其上运行Docker容器。&lt;/p&gt;
&lt;h3&gt;4. 运行一个Docker容器&lt;/h3&gt;
&lt;p&gt;现在，我们已经选择了活跃主机，就可以运行Docker容器了。可以测试一下，运行一个busybox容器来执行&lt;code&gt;echo hello word&lt;/code&gt;命令，这样就可以得到输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker run busybox echo hello world
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意：如果你试图在一个装有32位操作系统的宿主机部署Docker容器，使用SSH来运行docker是个好办法。这样你就可以简单跳过这一步，直接进入下一步。&lt;/p&gt;
&lt;h3&gt;5. SSH到Docker机器中&lt;/h3&gt;
&lt;p&gt;如果我们想在机器或者Droplet上控制之前部署的Docker机器，可以使用docker-machine ssh命令来SSH到机器上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine ssh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Docker Machine SSH" src="http://blog.linoxide.com/wp-content/uploads/2015/05/docker-machine-ssh.png"&gt;&lt;/p&gt;
&lt;p&gt;SSH到机器上之后，我们可以在上边运行任何Docker容器。这里我们运行一个nginx：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker run -itd -p 80:80 nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;操作完毕后，我们需要运行exit命令来退出Droplet或者服务器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# exit
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;5. 删除主机&lt;/h3&gt;
&lt;p&gt;删除在运行的主机以及它的所有镜像和容器，我们可以使用docker-machine rm命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine rm linux-dev
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Docker Machine Remove All" src="http://blog.linoxide.com/wp-content/uploads/2015/05/docker-machine-remove-machine.png"&gt;&lt;/p&gt;
&lt;p&gt;使用docker-machine ls命令检查是否成功删除了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine ls
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="Docker Machine Remove Check" src="http://blog.linoxide.com/wp-content/uploads/2015/05/docker-machine-remove-check.png"&gt;&lt;/p&gt;
&lt;h3&gt;6. 在不使用驱动的情况新增一个主机&lt;/h3&gt;
&lt;p&gt;我们可以在不使用驱动的情况往Docker增加一台主机，只需要一个URL。它可以使用一个已有机器的别名，所以我们就不需要每次在运行docker命令时输入完整的URL了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker-machine create --url&lt;span class="o"&gt;=&lt;/span&gt;tcp://104.131.50.36:2376 custombox
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;7. 管理主机&lt;/h3&gt;
&lt;p&gt;如果你已经让Docker运行起来了，可以使用简单的&lt;strong&gt;docker-machine stop&lt;/strong&gt;命令来停止所有正在运行的主机，如果需要再启动的话可以运行&lt;strong&gt;docker-machine start&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# docker-machine stop
# docker-machine start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你也可以使用如下命令来使用机器名作为参数来将其停止或启动：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker-machine stop linux-dev
$ docker-machine start linux-dev
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;Docker Machine是一个非常棒的工具，可以使用Docker容器快速地部署服务。文中我们使用Digital Ocean Platform作演示，但Docker Machine还支持其他平台，如Amazon Web Service、Google Cloud Computing。使用Docker Machine，快速、安全地在几种不同平台部署Docker容器变得很简单了。因为Docker Machine还是Beta版本，不建议在生产环境使用。如果你有任何问题、建议、反馈，请在下方的评论框中写下来，我们会改进或者更新我们的内容。谢谢！享受吧 :-)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;via: http://linoxide.com/linux-how-to/use-docker-machine-cloud-provider/&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://linoxide.com/author/arunp/"&gt;Arun Pyasi&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="https://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>[译] zBackup：一个多功能的去重备份工具</title><link href="/yi-zbackupyi-ge-duo-gong-neng-de-qu-zhong-bei-fen-gong-ju.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/yi-zbackupyi-ge-duo-gong-neng-de-qu-zhong-bei-fen-gong-ju.html</id><summary type="html">&lt;p&gt;zbackup是一个基于rsync思想的全局去重数据备份工具。给它传入一个大的tar文件后，它会仅存储一次该文件的重复部分，然后对结果进行压缩，并根据参数确定是否对其加密。传入另一个tar文件后，它会从之前的已备份文件中复用重复数据。只有新的改动会被保存，并且只要文件差异不是很大，需要的存储空间非常少。无论何时，之前的已备份文件都可以被完整地读出来。&lt;/p&gt;
&lt;h3&gt;zBackup特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用并行的LZMA或者LZO压缩算法压缩已备份数据&lt;/li&gt;
&lt;li&gt;使用内置的AES加密算法加密已备份数据&lt;/li&gt;
&lt;li&gt;可以删除旧的已备份数据&lt;/li&gt;
&lt;li&gt;使用一个64位滚动哈希，保持软碰撞数量为0&lt;/li&gt;
&lt;li&gt;备份库由不可更改的文件组成，只有库中不存在的文件才能修改&lt;/li&gt;
&lt;li&gt;使用C++语言编写，并且只有适量的依赖库&lt;/li&gt;
&lt;li&gt;可以在生产环境安全使用&lt;/li&gt;
&lt;li&gt;可以在不同备份库中交换数据而无需重新压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;在ubuntu中安装zBackup&lt;/h3&gt;
&lt;p&gt;打开终端并运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install zbackup
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;使用zBackup&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;zbackup init&lt;/code&gt;命令会初始化一个备份库，用来存放待备份的数据。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;zbackup init [--non-encrypted] [--password-file ~/.my_backup_password ] /my/backup/repo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;zbackup backup&lt;/code&gt;命令备份一个由&lt;code&gt;tar c&lt;/code&gt;命令创建的tar文件到刚才使用 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;zbackup是一个基于rsync思想的全局去重数据备份工具。给它传入一个大的tar文件后，它会仅存储一次该文件的重复部分，然后对结果进行压缩，并根据参数确定是否对其加密。传入另一个tar文件后，它会从之前的已备份文件中复用重复数据。只有新的改动会被保存，并且只要文件差异不是很大，需要的存储空间非常少。无论何时，之前的已备份文件都可以被完整地读出来。&lt;/p&gt;
&lt;h3&gt;zBackup特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用并行的LZMA或者LZO压缩算法压缩已备份数据&lt;/li&gt;
&lt;li&gt;使用内置的AES加密算法加密已备份数据&lt;/li&gt;
&lt;li&gt;可以删除旧的已备份数据&lt;/li&gt;
&lt;li&gt;使用一个64位滚动哈希，保持软碰撞数量为0&lt;/li&gt;
&lt;li&gt;备份库由不可更改的文件组成，只有库中不存在的文件才能修改&lt;/li&gt;
&lt;li&gt;使用C++语言编写，并且只有适量的依赖库&lt;/li&gt;
&lt;li&gt;可以在生产环境安全使用&lt;/li&gt;
&lt;li&gt;可以在不同备份库中交换数据而无需重新压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;在ubuntu中安装zBackup&lt;/h3&gt;
&lt;p&gt;打开终端并运行如下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install zbackup
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;使用zBackup&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;zbackup init&lt;/code&gt;命令会初始化一个备份库，用来存放待备份的数据。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;zbackup init [--non-encrypted] [--password-file ~/.my_backup_password ] /my/backup/repo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;zbackup backup&lt;/code&gt;命令备份一个由&lt;code&gt;tar c&lt;/code&gt;命令创建的tar文件到刚才使用&lt;code&gt;zbackup init&lt;/code&gt;初始化的备份库。（LCTT 译注：实际使用时类似这样，tar c files | zbackup ...）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;zbackup [--password-file ~/.my_backup_password ] [--threads number_of_threads ] backup /my/backup/repo/backups/backup-`date ‘+%Y-%m-%d&amp;#39;`
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;zbackup restore&lt;/code&gt;命令从备份库中恢复一个已备份文件到tar文件中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;zbackup [--password-file ~/.my_backup_password ] [--cache-size cache_size_in_mb ] restore /my/backup/repo/backups/backup-`date ‘+%Y-%m-%d&amp;#39;` &amp;gt; /my/precious/backup-restored.tar
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;可用选项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;-non-encrypted -- 不加密备份库。&lt;/li&gt;
&lt;li&gt;--password-file ~/.my_backup_password -- 使用位于~/.my_backup_password的口令文件来加密备份库和待备份文件，以及解密已备份文件。&lt;/li&gt;
&lt;li&gt;--threads number_of_threads -- 限制并行LZMA压缩的线程数为 number_of_threads。建议在32位的系统平台使用。&lt;/li&gt;
&lt;li&gt;--cache-size cache_size_in_mb -- 使用cache_size_in_mb中的缓存大小来加速恢复文件的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;上述命令中 zBackup 相关文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;~/.my_backup_password 用来加密备份库和待备份文件，以及解密已备份文件。更多细节见zbackup。&lt;/li&gt;
&lt;li&gt;/my/backup/repo 存放备份库的目录。&lt;/li&gt;
&lt;li&gt;/my/precious/restored-tar 用来恢复已备份文件的tar文件。&lt;/li&gt;
&lt;li&gt;/my/backup/repo/backups/backup-&lt;code&gt;date ‘+%Y-%m-%d'&lt;/code&gt; 指定的之前已备份文件的文件名。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;via: http://www.ubuntugeek.com/zbackup-a-versatile-deduplicating-backup-tool.html&lt;/p&gt;
&lt;p&gt;作者：&lt;a href="http://www.ubuntugeek.com/author/ubuntufix"&gt;ruchi&lt;/a&gt;
译者：&lt;a href="https://github.com/goreliu"&gt;goreliu&lt;/a&gt;
校对：&lt;a href="https://github.com/wxy"&gt;wxy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文由 &lt;a href="https://github.com/LCTT/TranslateProject"&gt;LCTT&lt;/a&gt; 原创翻译，&lt;a href="http://linux.cn/"&gt;Linux中国&lt;/a&gt; 荣誉推出&lt;/p&gt;</content></entry><entry><title>在 Archlinux 编译 Termux 包</title><link href="/zai-archlinux-bian-yi-termux-bao.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zai-archlinux-bian-yi-termux-bao.html</id><summary type="html">&lt;p&gt;&lt;a href="https://termux.com/"&gt;Termux&lt;/a&gt; 是 Android 上的一个非常强大的终端模拟器。强大之处在于支持使用 apt 安装 zsh、git、vim、python、ruby、nodejs、openssh、gcc、golang 等几乎所有常用的终端软件，从此不用忍受功能孱弱的 busybox。&lt;/p&gt;
&lt;p&gt;目前 termux 源中有 400 多个包，显然还有很多不那么常用的没有覆盖到，除了在 &lt;a href="https://github.com/termux/termux-packages/issues"&gt;Issues · termux/termux-packages&lt;/a&gt; 上反馈外，自己编译也是个不错的主意。但目前相关文档比较匮乏（主页的 Readme 有错误），一不留神就会将简单的事情复杂化，耽误时间，故整理此文。&lt;/p&gt;
&lt;p&gt;需要注意的是，虽然 Termux 包使用的是 deb 格式，但无需使用基于 Debian 或者 Ubuntu 的发行版。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/termux/termux-packages"&gt;主页的 …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="https://termux.com/"&gt;Termux&lt;/a&gt; 是 Android 上的一个非常强大的终端模拟器。强大之处在于支持使用 apt 安装 zsh、git、vim、python、ruby、nodejs、openssh、gcc、golang 等几乎所有常用的终端软件，从此不用忍受功能孱弱的 busybox。&lt;/p&gt;
&lt;p&gt;目前 termux 源中有 400 多个包，显然还有很多不那么常用的没有覆盖到，除了在 &lt;a href="https://github.com/termux/termux-packages/issues"&gt;Issues · termux/termux-packages&lt;/a&gt; 上反馈外，自己编译也是个不错的主意。但目前相关文档比较匮乏（主页的 Readme 有错误），一不留神就会将简单的事情复杂化，耽误时间，故整理此文。&lt;/p&gt;
&lt;p&gt;需要注意的是，虽然 Termux 包使用的是 deb 格式，但无需使用基于 Debian 或者 Ubuntu 的发行版。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/termux/termux-packages"&gt;主页的 Readme &lt;/a&gt; 提供了两种方式，一种是使用 Docker 中的 Ubuntu 镜像，一种是直接在 Ubuntu 搭建环境。&lt;/p&gt;
&lt;p&gt;我图省事先用的 Docker 方式，虽然看起来很简单，只需要执行两条命令，但我折腾了几十分钟也没搞定。&lt;/p&gt;
&lt;p&gt;因为执行 &lt;code&gt;docker build --rm=true -t termux .&lt;/code&gt; 后会安装和升级大量（1G 左右）的包，默认的官方源速度是很不给力的。这样或者修改 &lt;code&gt;Dockerfile&lt;/code&gt; 修改源，或者直接手动进 Docker 里操作。这就不是两条命令的事情了，需要对 Docker 比较熟悉。我选择直接手动进 Docker 里操作。在安装过程中，我发现安装了大量看起来没有用的包，占用了大量空间。同时我看了下 &lt;code&gt;build-package.sh&lt;/code&gt; 脚本，发现并没有依赖 Ubuntu 特有的命令，于是改用直接在 Archlinux 里搭建环境，这样能节省很多时间。&lt;/p&gt;
&lt;p&gt;大概看了下几个脚本，发现步骤很简单：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载 termux-packages （&lt;code&gt;git clone https://github.com/termux/termux-packages.git&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;安装 android-ndk。下载 http://dl.google.com/android/android-sdk_r24.3.4-linux.tgz ，解压到 $HOME/lib/android-ndk （该目录下有 source.properties 文件）。（android-sdk 通常不需要，如需要，方法类似）&lt;/li&gt;
&lt;li&gt;创建 /data/data/com.termux/files/usr 目录，并把 /data 的属主改成当前用户。&lt;/li&gt;
&lt;li&gt;进入 termux-packages ，就可以直接用 &lt;code&gt;./build-package.sh packagename&lt;/code&gt; 编译包了（如果提示命令找不到，安装对应的包即可）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;搭建完可以随便编译一个包试试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;build&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;package&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="s s-Atom"&gt;sh&lt;/span&gt; &lt;span class="s s-Atom"&gt;bc&lt;/span&gt;
&lt;span class="s s-Atom"&gt;termux&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="s s-Atom"&gt;building&lt;/span&gt; &lt;span class="s s-Atom"&gt;bc&lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
  &lt;span class="c1"&gt;% Total    % Received % Xferd  Average Speed   Time    Time     Time  Current&lt;/span&gt;
                                 &lt;span class="nv"&gt;Dload&lt;/span&gt;  &lt;span class="nv"&gt;Upload&lt;/span&gt;   &lt;span class="nv"&gt;Total&lt;/span&gt;   &lt;span class="nv"&gt;Spent&lt;/span&gt;    &lt;span class="nv"&gt;Left&lt;/span&gt;  &lt;span class="nv"&gt;Speed&lt;/span&gt;
&lt;span class="mi"&gt;100&lt;/span&gt;  &lt;span class="mi"&gt;283&lt;/span&gt;&lt;span class="s s-Atom"&gt;k&lt;/span&gt;  &lt;span class="mi"&gt;100&lt;/span&gt;  &lt;span class="mi"&gt;283&lt;/span&gt;&lt;span class="s s-Atom"&gt;k&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;     &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;12885&lt;/span&gt;      &lt;span class="mi"&gt;0&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;00&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt; &lt;span class="s s-Atom"&gt;--:--:--&lt;/span&gt; &lt;span class="mi"&gt;74740&lt;/span&gt;
&lt;span class="nn"&gt;sed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s s-Atom"&gt;no&lt;/span&gt; &lt;span class="s s-Atom"&gt;input&lt;/span&gt; &lt;span class="s s-Atom"&gt;files&lt;/span&gt;
&lt;span class="nn"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;WARNING&lt;/span&gt;&lt;span class="s s-Atom"&gt;:&lt;/span&gt; &lt;span class="nv"&gt;If&lt;/span&gt; &lt;span class="s s-Atom"&gt;you&lt;/span&gt; &lt;span class="s s-Atom"&gt;wanted&lt;/span&gt; &lt;span class="s s-Atom"&gt;to&lt;/span&gt; &lt;span class="s s-Atom"&gt;set&lt;/span&gt; &lt;span class="s s-Atom"&gt;the&lt;/span&gt; &lt;span class="s s-Atom"&gt;--build&lt;/span&gt; &lt;span class="s s-Atom"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s s-Atom"&gt;don&amp;#39;t use --host.&lt;/span&gt;
&lt;span class="s s-Atom"&gt;    If a cross compiler is detected then cross compile mode will be used.&lt;/span&gt;
&lt;span class="s s-Atom"&gt;checking for a BSD-compatible install... /usr/bin/install -c&lt;/span&gt;
&lt;span class="s s-Atom"&gt;checking whether build environment is sane... yes&lt;/span&gt;
&lt;span class="s s-Atom"&gt;checking for gawk... gawk&lt;/span&gt;
&lt;span class="s s-Atom"&gt;checking whether make sets $(MAKE)... yes&lt;/span&gt;
&lt;span class="s s-Atom"&gt;...&lt;/span&gt;
&lt;span class="s s-Atom"&gt;make[2]: Leaving directory &amp;#39;&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;goreliu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;termux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;build&amp;#39;dc&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="s s-Atom"&gt;make[1]: Leaving directory &amp;#39;&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;goreliu&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;termux&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;build&amp;#39;-- &amp;quot;/data/data/com.termux/files/usr/bin&amp;quot;&lt;/span&gt;
&lt;span class="s s-Atom"&gt;termux-elf-cleaner: Removing the DT_VERNEEDED dynamic section entry from &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bc&amp;#39;&lt;/span&gt;
&lt;span class="s s-Atom"&gt;termux-elf-cleaner: Removing the DT_VERNEEDNUM dynamic section entry from &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bc&amp;#39;&lt;/span&gt;
&lt;span class="s s-Atom"&gt;termux-elf-cleaner: Removing the DT_VERNEEDED dynamic section entry from &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;dc&amp;#39;&lt;/span&gt;
&lt;span class="s s-Atom"&gt;termux-elf-cleaner: Removing the DT_VERNEEDNUM dynamic section entry from &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="s s-Atom"&gt;dc&amp;#39;/files/usr/info&amp;quot;&lt;/span&gt;
&lt;span class="s s-Atom"&gt;termux - build of &amp;#39;bc&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; &lt;span class="s s-Atom"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为 &lt;code&gt;build-package.sh&lt;/code&gt; 这个脚本写得比较渣，可能提示一些错误，但不影响功能，编译出来了。结果在 &lt;code&gt;$HOME/termux/_deb/bc_1.06.95-1_arm.deb&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;这里需要注意的是 &lt;code&gt;build-package.sh&lt;/code&gt; 编译的是 32 位 arm 版本，如果需要的不是这个，可以直接改 &lt;code&gt;build-package.sh&lt;/code&gt; ，将&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;: &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;TERMUX_ARCH&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;arm&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; # (arm|aarch64|i686|x86_64) - the 64 bit variants do not work yet
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;里的 &lt;code&gt;"arm"&lt;/code&gt;改成后边括号内的，比如 aarch64 是64 位 arm 的。&lt;/p&gt;
&lt;p&gt;还有因为 android-ndk 目录体积巨大，在编译完一个包后，这个目录的同级目录下会产生一个类似 android-standalone-toolchain-aarch64-api21-gcc4.9 的目录，然后我们就可以只保留 android-ndk 下的 source.properties 文件，将该目录其他文件删除（试验如此，保险的话还是先保留）。&lt;/p&gt;
&lt;p&gt;验证没问题了，我们就可以添加源里没有的包了，拿 atool 举例：&lt;/p&gt;
&lt;p&gt;新建 termux-packages/packages/atool 目录，在该目录创建 build.sh 文件，内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;TERMUX_PKG_HOMEPAGE=http://www.nongnu.org/atool
TERMUX_PKG_DESCRIPTION=&amp;quot;A script for managing file archives of various types&amp;quot;
TERMUX_PKG_VERSION=0.39.0
TERMUX_PKG_BUILD_REVISION=1
TERMUX_PKG_SRCURL=https://savannah.nongnu.org/download/atool/atool-&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;TERMUX_PKG_VERSION&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;.tar.gz
TERMUX_PKG_DEPENDS=&amp;quot;file, perl&amp;quot;
TERMUX_PKG_PLATFORM_INDEPENDENT=yes
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这些字段都比较简单，参考 termux-packages/packages 下的例子就可以写出来（有疑问的话，可以看 build-package.sh 脚本的实现）。&lt;/p&gt;
&lt;p&gt;然后在 termux-packages 目录运行 &lt;code&gt;./build-package.sh atool&lt;/code&gt; 就可以了。&lt;/p&gt;</content></entry><entry><title>Zookeeper 和 etcd 使用场景</title><link href="/zookeeper-he-etcd-shi-yong-chang-jing.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zookeeper-he-etcd-shi-yong-chang-jing.html</id><summary type="html">&lt;h3&gt;1、Zookeeper和etcd共同点&lt;/h3&gt;
&lt;p&gt;Zookeeper和etcd的功能和使用场景都很类似。&lt;/p&gt;
&lt;h3&gt;2、Zookeeper选主方法&lt;/h3&gt;
&lt;h4&gt;Paxos &amp;amp; fast paxos&lt;/h4&gt;
&lt;p&gt;参考 &lt;a href="http://blog.csdn.net/xhh198781/article/details/10949697"&gt;Paxos算法与Zookeeper分析&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、Zookeeper复制数据方法&lt;/h3&gt;
&lt;h4&gt;Zab&lt;/h4&gt;
&lt;p&gt;Zab协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在leader崩溃后，Zab就进入了恢复模式，当leader被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和follower具有相同的系统状态。&lt;/p&gt;
&lt;h5&gt;广播模式&lt;/h5&gt;
&lt;p&gt;Leader向follower发送请求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leader向follower依次发送prepare请求，并等待回应，半数以上回复即prepare成功。&lt;/li&gt;
&lt;li&gt;Leader按相同顺序依次发送commit请求，并等待回应，半数以上回复即commit成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果client连上的是follower，写请求会转发给leader处理，读请求如果要读到最新数据也需要转发给leader，如果不需要可以直接在follower中读取。&lt;/p&gt;
&lt;h5&gt;恢复模式&lt;/h5&gt;
&lt;p&gt;这种情况主要解决的是新老交互的问题，即新leader是否需要继续老leader未完成的状态。&lt;/p&gt;
&lt;p&gt;这里要看老leader挂掉时的情况：
1. 多数follower还没有收到老leader的commit。
2. 多数follower已经收到老leader的commit，并且操作完成。&lt;/p&gt;
&lt;p&gt;第一种情况，因为多数follower还没有commit，该commit失败。完成commit的server需要在新leader选出后将该commit回滚。&lt;/p&gt;
&lt;p&gt;第二种情况 …&lt;/p&gt;</summary><content type="html">&lt;h3&gt;1、Zookeeper和etcd共同点&lt;/h3&gt;
&lt;p&gt;Zookeeper和etcd的功能和使用场景都很类似。&lt;/p&gt;
&lt;h3&gt;2、Zookeeper选主方法&lt;/h3&gt;
&lt;h4&gt;Paxos &amp;amp; fast paxos&lt;/h4&gt;
&lt;p&gt;参考 &lt;a href="http://blog.csdn.net/xhh198781/article/details/10949697"&gt;Paxos算法与Zookeeper分析&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、Zookeeper复制数据方法&lt;/h3&gt;
&lt;h4&gt;Zab&lt;/h4&gt;
&lt;p&gt;Zab协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在leader崩溃后，Zab就进入了恢复模式，当leader被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和follower具有相同的系统状态。&lt;/p&gt;
&lt;h5&gt;广播模式&lt;/h5&gt;
&lt;p&gt;Leader向follower发送请求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leader向follower依次发送prepare请求，并等待回应，半数以上回复即prepare成功。&lt;/li&gt;
&lt;li&gt;Leader按相同顺序依次发送commit请求，并等待回应，半数以上回复即commit成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果client连上的是follower，写请求会转发给leader处理，读请求如果要读到最新数据也需要转发给leader，如果不需要可以直接在follower中读取。&lt;/p&gt;
&lt;h5&gt;恢复模式&lt;/h5&gt;
&lt;p&gt;这种情况主要解决的是新老交互的问题，即新leader是否需要继续老leader未完成的状态。&lt;/p&gt;
&lt;p&gt;这里要看老leader挂掉时的情况：
1. 多数follower还没有收到老leader的commit。
2. 多数follower已经收到老leader的commit，并且操作完成。&lt;/p&gt;
&lt;p&gt;第一种情况，因为多数follower还没有commit，该commit失败。完成commit的server需要在新leader选出后将该commit回滚。&lt;/p&gt;
&lt;p&gt;第二种情况，新leader通过一个多数派获得老leader提交的最新数据，老leader重启后，可能还会认为自己是leader，可能会继续发送未完成的请求，从而因为两个leader同时存在导致算法过程失败，解决办法是把leader信息加入每条消息的id中，Zookeeper中称为zxid，zxid为一64位数字，高32位为leader信息又称为epoch，每次leader转换时递增；低32位为消息编号，leader转换时应该从0重新开始编号。通过zxid，follower能很容易发现请求是否来自老leader，从而拒绝老leader的请求。新leader首先要获得大多数节点的支持，然后从状态最新的节点同步事务（如何同步见下文），完成后才可正式成为leader发起事务。&lt;/p&gt;
&lt;p&gt;选出新leader以后，zookeeper就进入状态同步过程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leader等待server连接；&lt;/li&gt;
&lt;li&gt;Follower连接leader，将最大的zxid发送给leader；&lt;/li&gt;
&lt;li&gt;Leader根据follower的zxid确定同步点（需要多数派都在这种状态或更新状态）&lt;/li&gt;
&lt;li&gt;完成同步后通知follower已经成为uptodate状态；&lt;/li&gt;
&lt;li&gt;Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;4、Etcd选主方法&lt;/h3&gt;
&lt;p&gt;Raftppt-understandable-cons-protocol.pdf&lt;/p&gt;
&lt;h3&gt;5、Etcd复制数据方法&lt;/h3&gt;
&lt;p&gt;Raftppt-understandable-cons-protocol.pdf&lt;/p&gt;
&lt;h3&gt;6、Zookeeper常见使用场景&lt;/h3&gt;
&lt;h4&gt;配置管理、数据分发与订阅&lt;/h4&gt;
&lt;p&gt;管理配置是zookeeper最常见的应用场景。比如一个服务的多个实例部署在不同机器上，如果使用本地配置文件，修改、实例迁移等操作都比较麻烦，可以把配置存放到zookeeper的某个路径下。每个实例启动后都去zookeeper读取配置，如果需要追踪配置的更新，可以监视节点的变更。&lt;/p&gt;
&lt;p&gt;这个配置不局限为服务运行所需要的配置信息，符合分发、订阅方法使用的数据都可，也可以指不同服务实例运行时的中间状态（对应单机进程使用的内存中状态数据或者状态文件），这样各个实例可以实现为无状态的，一旦实例挂掉不会丢失数据，方便服务迁移（具体迁移方式参考集群管理部分）。&lt;/p&gt;
&lt;h4&gt;集群管理与Master选举&lt;/h4&gt;
&lt;h5&gt;集群机器监控&lt;/h5&gt;
&lt;p&gt;这通常用于那种对集群中机器状态，机器在线率有较高要求的场景，能够快速对集群中机器变化作出响应。这样的场景中，往往有一个监控系统，实时检测集群机器是否存活。&lt;/p&gt;
&lt;p&gt;利用ZooKeeper可以实现一种集群机器存活性监控系统：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个机器在/Machines/下创建一个临时节点（如/Machines/${hostname}，可以把具体的状态作为节点内容）。&lt;/li&gt;
&lt;li&gt;服务端监视/Machines/下节点的变动，来判断机器是否存活以及具体状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;Master选举&lt;/h5&gt;
&lt;p&gt;在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行master选举。&lt;/p&gt;
&lt;p&gt;利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 /currentMaster 节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选举了。&lt;/p&gt;
&lt;p&gt;此外，也可以利用Zookeeper的EPHEMERAL_SEQUENTIAL节点，实现动态选举：每个客户端都在/Master/下创建一个EPHEMERAL_SEQUENTIAL节点,由于ZooKeeper保证SEQUENTIAL的有序性，因此我们可以简单的把节点号最小的作为Master，就完成了选主。&lt;/p&gt;
&lt;h4&gt;分布式锁&lt;/h4&gt;
&lt;h5&gt;屏障&lt;/h5&gt;
&lt;p&gt;似乎不是很常用，参考官方文档（http://zookeeper.apache.org/doc/r3.4.6/recipes.html#sc_recipes_eventHandles）&lt;/p&gt;
&lt;h5&gt;独占锁&lt;/h5&gt;
&lt;p&gt;获取锁时如果不需要等待（只使用try_lock()、unlock()，不使用lock()），可以直接以一个节点（如/Lock，事先不存在）作为锁，试图获取这个锁的客户端直接创建这个节点，只有一个可以成功，使用完了则删除这个节点（或者使用临时节点，关闭会话）。如果需要等待，参考控制时序的锁。&lt;/p&gt;
&lt;h5&gt;控制时序的锁&lt;/h5&gt;
&lt;p&gt;就是所有试图来获取这个锁的客户端，最终都会获得（除非有人一直不释放），只是有个全局时序。&lt;/p&gt;
&lt;p&gt;预先创建/Lock/，客户端在它下面创建临时有序节点lock-（Zk的父节点维持一份子节点创建的时序），然后获取/Lock/下的子节点（设置监视标志），直到自己拥有的是最小的序号则获得锁，释放时只需要删除该节点。&lt;/p&gt;
&lt;p&gt;如果每个客户端都不可撤销锁（包括设置获取锁的超时时间），也可以改成这样。预先创建/Lock/，客户端在它下面创建有序节点lock-（非临时，否则某还没得到锁的客户端会话意外关闭后，会使得下一个客户端获得锁，导致混乱），然后获取/Lock/下的子节点（不设置监视标志），如果自己拥有的是最小的序号则获得锁，否则只监视比自己小的最大子节点，直到该节点被删除后获得锁，释放时删除自己的节点。和前一种方法相比，每次锁被释放时只有下一个获取该锁的客户端被唤醒。&lt;/p&gt;
&lt;h5&gt;共享锁（读写锁）&lt;/h5&gt;
&lt;p&gt;获取读锁过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在/Lock/（/Lock/是预先创建的）下创建有序节点read-。&lt;/li&gt;
&lt;li&gt;获得/Lock/下的子节点（不设置监视标志）。&lt;/li&gt;
&lt;li&gt;如果没有以write-开头并且比自己小（一个目录里的序号是统一的，不区分节点名）的节点，则获得了读锁。&lt;/li&gt;
&lt;li&gt;否则监视这个以write-开头并且比自己小的节点，直到这个节点被删除了，返回2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;获取写锁的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在/Lock/下创建有序节点write-。&lt;/li&gt;
&lt;li&gt;获得/Lock/下的子节点（不设置监视标志）。&lt;/li&gt;
&lt;li&gt;如果没有比自己小的节点，则获得了写锁。&lt;/li&gt;
&lt;li&gt;否则监视这个以比自己小的节点，直到这个节点被删除了，返回2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但前提是每个客户端都不可撤销锁（包括设置获取锁的超时时间），否则请参考&lt;a href="http://zookeeper.apache.org/doc/r3.4.6/recipes.html#Shared+Locks"&gt;Shared+Locks&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;名字服务&lt;/h4&gt;
&lt;p&gt;这个主要是作为分布式命名服务，通过调用zk的create node api，能够很容易创建一个全局唯一的path，这个path就可以作为一个名称。&lt;/p&gt;
&lt;p&gt;命名服务是指通过指定的名字来获取资源或者服务的地址，提供者的信息。利用Zookeeper很容易创建一个全局的路径，而这个路径就可以作为一个名字，它可以指向集群中的集群，提供的服务的地址，远程对象等。简单来说使用Zookeeper做命名服务就是用路径作为名字，路径上的数据就是其名字指向的实体。&lt;/p&gt;
&lt;p&gt;服务提供者在启动的时候，向ZK上的指定节点（如/${serviceName}/providers）目录下写入自己的URL地址，这个操作就完成了服务的发布。
服务消费者启动的时候，订阅/${serviceName}/providers/目录下的提供者URL地址（如果一次性使用直接读取即可），并向/${serviceName}/consumers/目录下写入自己的URL地址（如果服务提供者者需要通过ZK获取服务消费者身份，可选）。
所有向ZK上注册的地址都是临时节点，这样就能够保证服务提供者和消费者能够自动感应资源的变化。&lt;/p&gt;
&lt;p&gt;典型例子（参考http://blog.csdn.net/qq910894904/article/details/40833859，省略其中的服务监控者）：
nameservice：
    -m 程序运行的方式，指定是服务提供者provider还是服务消费者consumer
    -n 服务名称
    -s Zookeeper的服务地址IP:PORT&lt;/p&gt;
&lt;p&gt;服务提供者：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nameservice -m provider -n ServiceDemo -s 172.17.0.36:2181&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;服务消费者：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nameservice -m consumer -n ServiceDemo -s 172.17.0.36:2181&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一条命令启动服务提供者，它提供一个ServiceDemo的服务，首次启动后会创建/NameService/、/NameService/ServiceDemo/、/NameService/ServiceDemo/provider/几个路径（永久节点）。然后在服务提供进程在/NameService/ServiceDemo/provider/下创建临时序列节点。&lt;/p&gt;
&lt;p&gt;第二条命令启动一个服务消费进程,它在/NameService/ServiceDemo/consumer/下创建临时序列节点，并watch /NameService/ServiceDemo/provider/下的子节点变化事件，及时更新provider列表。&lt;/p&gt;
&lt;h4&gt;分布式通知/协调&lt;/h4&gt;
&lt;p&gt;通知的典型实现方式是被通知方监听一个端口，等待通知方往端口发送消息。双方耦合比较严重，如果双方需要互相通知，有多个通知方和被通知方自己交互则逻辑复杂、难于实现。&lt;/p&gt;
&lt;p&gt;典型的通知就是被通知方监视一个节点，通知方修改或者删除这个节点。&lt;/p&gt;
&lt;h4&gt;分布式队列&lt;/h4&gt;
&lt;h5&gt;队列&lt;/h5&gt;
&lt;p&gt;预先创建/Queue/。&lt;/p&gt;
&lt;p&gt;push：创建一个有序的/Queue/queue-节点。
pop：取出/Queue/下序列号最小的节点（先获取到所有节点，然后删除序号最小的节点表示取出，如果删除之前节点已经被别人删了也没事，直接跳过。也可以获取所有节点是设置监视标志，这样可以及时处理新添加的节点）。&lt;/p&gt;
&lt;p&gt;zookeeeper源码的recipes/queue目录有示例。&lt;/p&gt;
&lt;h5&gt;优先队列&lt;/h5&gt;
&lt;p&gt;在上边普通队列的基础上作2个小改动即可实现优先队列。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;push时，创建以queue-x-的节点，x是代表优先级的数字。&lt;/li&gt;
&lt;li&gt;pop时，取出x最小的节点，而不是序列号最小的节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;7、Etcd常见使用场景&lt;/h3&gt;
&lt;p&gt;Etcd和zookeeper的使用场景大致相同，主要不同在于接口和部分周边功能上。&lt;/p&gt;
&lt;h3&gt;8、Zookeeper和etcd使用场景比较&lt;/h3&gt;
&lt;p&gt;Etcd支持更方便的HTTP API，多语言支持比zookeeper也要好一些。&lt;/p&gt;
&lt;p&gt;Etcd没有acl权限控制。&lt;/p&gt;
&lt;p&gt;性能上，需要自己根据使用场景做测试。&lt;/p&gt;
&lt;h3&gt;9、参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/linhaohong/archive/2012/11/26/2789394.html"&gt;Chubby 和Zookeeper 的理解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/qq910894904/article/details/40835105"&gt;ZooKeeper场景实践系列&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.coder4.com/archives/3856"&gt;ZooKeeper典型应用场景一览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/haippy/archive/2012/07/23/2603583.html"&gt;Zookeeper 进阶之——典型应用场景（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/haippy/archive/2012/07/23/2604556.html"&gt;Zookeeper 进阶之——典型应用场景（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://zookeeper.apache.org/doc/r3.4.6/recipes.html"&gt;ZooKeeper Recipes and Solutions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/xinguan1267/article/details/38422149"&gt;ZooKeeper原理及使用 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.kuqin.com/system-analysis/20111120/315148.html"&gt;ZooKeeper典型使用场景一览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/"&gt;分布式服务框架 Zookeeper -- 管理分布式环境中的数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cwiki.apache.org/confluence/display/ZOOKEEPER/Zab+vs.+Paxos"&gt;Zab vs. Paxos&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/xhh198781/article/details/10949697"&gt;Paxos算法与Zookeeper分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>做视频剪辑整理的一些记录</title><link href="/zuo-shi-pin-jian-ji-zheng-li-de-yi-xie-ji-lu.html" rel="alternate"></link><published>2017-09-18T20:29:00+08:00</published><updated>2017-09-18T20:29:00+08:00</updated><author><name>goreliu</name></author><id>tag:None,2017-09-18:/zuo-shi-pin-jian-ji-zheng-li-de-yi-xie-ji-lu.html</id><summary type="html">&lt;p&gt;这几天做了一个视频剪辑，接触了一些相关工具，整理一下。&lt;/p&gt;
&lt;h2&gt;视频切割合并&lt;/h2&gt;
&lt;p&gt;视频切割合并是非常基础和常用的功能，往往是处理视频素材的第一步。我之前简单处理过一些音频，用的是开源软件audacity，所有想应该也有类似的处理视频的开源软件。找了一圈试用了好几个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Shotcut
据说是很有名的开源视频剪辑软件，安装后没用明白……上网搜教程还是没用明白（智商堪忧），没找到视频如何导出，也没找到切割和合并的功能。我知道一定是我的问题，放弃了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;爱剪辑
国内的免费软件。用户体验还好，格式支持也比较多。本来打算用这个了，结果发现导出的视频会强行加入开头和结尾，无法取消（至少免费版不能取消），也罢。另外我没找到可以保持原视频分辨率的选项，自己选和原视频相同的分辨率后，导出的视频有黑边，也许是我用得有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mencoder
强大的命令行工具，可以完成视频切割合并操作，麻烦是自然的。我本来想先用爱剪辑编辑，然后再用mencoder把开头和结尾去掉，因为开头和结尾时间是固定的，所以应该是可行的。但发现一个问题，视频的aac音频不能使用-oac copy，换了好几个版本的mencoder都不行（有的不支持libfaac，有的可以选择-oac faac重新编码），必须重新编码，也就是说每用mencoder处理一次，音频就得重新编码一次 …&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;这几天做了一个视频剪辑，接触了一些相关工具，整理一下。&lt;/p&gt;
&lt;h2&gt;视频切割合并&lt;/h2&gt;
&lt;p&gt;视频切割合并是非常基础和常用的功能，往往是处理视频素材的第一步。我之前简单处理过一些音频，用的是开源软件audacity，所有想应该也有类似的处理视频的开源软件。找了一圈试用了好几个。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Shotcut
据说是很有名的开源视频剪辑软件，安装后没用明白……上网搜教程还是没用明白（智商堪忧），没找到视频如何导出，也没找到切割和合并的功能。我知道一定是我的问题，放弃了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;爱剪辑
国内的免费软件。用户体验还好，格式支持也比较多。本来打算用这个了，结果发现导出的视频会强行加入开头和结尾，无法取消（至少免费版不能取消），也罢。另外我没找到可以保持原视频分辨率的选项，自己选和原视频相同的分辨率后，导出的视频有黑边，也许是我用得有问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mencoder
强大的命令行工具，可以完成视频切割合并操作，麻烦是自然的。我本来想先用爱剪辑编辑，然后再用mencoder把开头和结尾去掉，因为开头和结尾时间是固定的，所以应该是可行的。但发现一个问题，视频的aac音频不能使用-oac copy，换了好几个版本的mencoder都不行（有的不支持libfaac，有的可以选择-oac faac重新编码），必须重新编码，也就是说每用mencoder处理一次，音频就得重新编码一次，或者使用更麻烦的方法（比如先转成其他格式，-oac copy，最后再转回来）。另外考虑到对时间线的痛苦，我还是不直接使用这么原始的工具了，ffmpeg等命令行工具同理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AVS Video Editor 
据说是免费软件，安装后发现不注册的话，导出的视频是带水印的……&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Adobe Premiere Pro
我本来不想用它，因为体积比较大（比前几个合在一起还大），而且是商业软件。但找了一圈没有其他能用的，只好用它了。功能方面，导入视频就发现个问题，不支持导入h264+aac的flv视频，好在我之前找到了一个FLV_Extract（http://www.moitah.net ）工具可以把flv中的视频和音频提取成.264和.aac格式，然后就可以导入到Adobe Premiere Pro，导入后可以把视频和音频关联到一起，虽然麻烦点至少能用了。
操作界面没有爱剪辑那么易懂，但折腾了一会，没看教程也算会用切割合并功能了。但有时用鼠标拖动时会卡住（鼠标旁边的图示也会变，没看明白是什么功能），不知道是什么原因。还有当视频片段比较多，而且是从不同视频剪辑出来的时，播放起来容易卡顿，但看资源管理器，瓶颈貌似不在读磁盘速度上（ssd的系统盘，看Adobe Premiere Pro的磁盘读取速度在50M/s以下），CPU是i5 4590，性能上应该问题不大。
使用了几天后，发现Adobe Premiere Pro在复杂的剪辑操作上（需要导入几十个视频用来编辑，有多条音频，需要按帧把视频对齐到音频，需要能调整选定的片段到原视频前后的部分等等）还是很有优势的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenShot
补充一个OpenShot，前几天恰好看到的。
界面很简洁友好。
不支持选和源视频相同的分辨率，需要手动填写。导出视频时，导出30%后卡住了（未响应）……选h264和mpeg4编码都是，可能是视频文件的问题（一个2分多钟，h264+aac的flv文件）。换了一个（6分多钟，h264+aac的mp4文件）后，到50%多卡住了。又换了一个（6分多钟，h264+aac的mkv文件），没改分辨率导出成功了，改成和原始视频一样的分辨率后，到50%多又卡住了……
可能因为是beta版本（2.0.6），稳定性很差，经常导出视频中未响应，没法用。但看功能方面，基本的切割合并功能还是不错的，如果稳定性没有问题也许可以应付一些简单场景。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;视频压缩&lt;/h2&gt;
&lt;p&gt;使用Adobe Premiere Pro导出的视频体积很大（原始视频是h264+aac 1104x622 30fps的，6分多钟，导出后400多M），我之前想直接用ffmpeg之类的命令行工具压缩（但因为调参数比较麻烦，暂时放下了），但在做字幕时搜了各种软件，找到一个小丸工具箱（https://www.maruko.in/ ）发现很好用，基本不用管参数，处理后大小变成了30多M，没看出画质降低（6分钟的原始视频大概也是这个大小）。&lt;/p&gt;
&lt;p&gt;修正一下，我导出的视频体积很大的原因是没有修改默认的“目标比特率”，改成和原始视频差不多，然后导出就小很多了，但这样画质损失比较大。还是不修改它，直接再压一遍吧。&lt;/p&gt;
&lt;h2&gt;字幕&lt;/h2&gt;
&lt;p&gt;为了弄字幕，我折腾了不少时间。
先用的srt字幕（因为是mv，从lrc歌词转换的，没找到方便的工具。用在线网站转的，但貌似有bug，下载不了转换完的字幕文件，直接复制会有部分乱码……），但我需要右侧竖排的字幕，没找到能让srt字幕显示在屏幕右侧的方法。后来发现ass字幕可以。Aegisub（http://www.aegisub.org/ ）可以把srt字幕转成ass，然后设置字体、位置等，还是很好用的。
但发现一个问题，设置成竖排字幕后，如果Alignment设置成6的话，字幕显示不是纵向居中的，而是偏上，甚至超出了视频边界，选3又太低了。选5是正常的，但通过调整Margins-&amp;gt;Left调到右边又发现问题了。原来一行字幕中带空格是不自动换行的，但调整到视频右侧后，每个空格都换行了。我试过使用中文空格和\h，但间距和半角空格不一样，看起来很别扭。
期间试了试另一个字幕编辑软件PopSub，感觉没有Aegisub好用，没怎么用明白就放弃了。
后来用文本编辑器打开ass文件，发现可以直接编辑。上网搜了半天，说可以每行添加\pos调整位置，尝试了多次终于把位置调对了。&lt;/p&gt;
&lt;p&gt;然后是字幕封装的问题，我的一个视频对应了两种语言的字幕，mpv不能方便地选择显示不同的字幕。Mkvtoolnix（https://mkvtoolnix.download/downloads.html ）可以将视频和多个字幕合并到一个mkv文件，并且设置默认是否显示字幕，很好用。另外还可以在附件里添加字体，就不用担心播放时没有匹配的字体了。&lt;/p&gt;
&lt;p&gt;但有些视频网站（比如B站）是不支持带字幕的mkv文件的，只好把字幕压到视频里。之前提到的小丸工具箱（https://www.maruko.in/ ）有这个功能。&lt;/p&gt;</content></entry></feed>